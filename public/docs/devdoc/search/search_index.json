{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Artemis Development Documentation Selamat Datang di dokumentasi pengembangan aplikasi di Artemis. Dokumen ini dapat digunakan sebagai modul pelatihan, dokumen ini dibagi menjadi 3 bagian: Artemis Documentation for Developer Artemis Documentation for Server System Admin Artemis Documentation for Functionals Dokumentasi ini akan berkembang mengikuti perkembangan Artemis. Dokumentasi ini dibuat menggunakan python script mkdocs , sehingga para developer juga dapat mengembangkannya di kemudian hari. Dokumentasi eksternal aplikasi pendukung, Git Documentation Composer Documentation Laravel Documentation JQuery Documentation CSS Documentation Mkdocs Documentation","title":"Home"},{"location":"#artemis-development-documentation","text":"Selamat Datang di dokumentasi pengembangan aplikasi di Artemis. Dokumen ini dapat digunakan sebagai modul pelatihan, dokumen ini dibagi menjadi 3 bagian: Artemis Documentation for Developer Artemis Documentation for Server System Admin Artemis Documentation for Functionals Dokumentasi ini akan berkembang mengikuti perkembangan Artemis. Dokumentasi ini dibuat menggunakan python script mkdocs , sehingga para developer juga dapat mengembangkannya di kemudian hari.","title":"Artemis Development Documentation"},{"location":"#dokumentasi-eksternal-aplikasi-pendukung","text":"Git Documentation Composer Documentation Laravel Documentation JQuery Documentation CSS Documentation Mkdocs Documentation","title":"Dokumentasi eksternal aplikasi pendukung,"},{"location":"developerdoc/","text":"Artemis Documentation for Developer Dokumen ini berisi tentang bagaimana mempersiapkan lingkungan pengembangan aplikasi web di Artemis. Developer Skill Requirements Programming Logic PHP basic Javascript & JQuery programming CSS styling Materi yang akan dipelajari Installation Git Composer Laravel basic Laravel Database Setting Laravel Routing Laravel Blade Templating Laravel Database Query Laravel Database Migration Laravel Eloquent Laravel Queue Laravel Schedule Laravel Class Testing Artemis Introduction Artemis Coding Standard Artemis UI Design Standard Artemis Documentation Editing Tugas Latihan","title":"Home"},{"location":"developerdoc/#artemis-documentation-for-developer","text":"Dokumen ini berisi tentang bagaimana mempersiapkan lingkungan pengembangan aplikasi web di Artemis.","title":"Artemis Documentation for Developer"},{"location":"developerdoc/#developer-skill-requirements","text":"Programming Logic PHP basic Javascript & JQuery programming CSS styling","title":"Developer Skill Requirements"},{"location":"developerdoc/#materi-yang-akan-dipelajari","text":"Installation Git Composer Laravel basic Laravel Database Setting Laravel Routing Laravel Blade Templating Laravel Database Query Laravel Database Migration Laravel Eloquent Laravel Queue Laravel Schedule Laravel Class Testing Artemis Introduction Artemis Coding Standard Artemis UI Design Standard Artemis Documentation Editing","title":"Materi yang akan dipelajari"},{"location":"developerdoc/#tugas-latihan","text":"","title":"Tugas Latihan"},{"location":"developerdoc/artemis_coding_standard/","text":"Artemis Coding Standard Struktur Penulisan file kode Penulisan komentar di bagian awal file Komentar diskripsi file harus dituliskan di awal file. Contoh PHP: <?php namespace app\\mylibrary; /** * Filename: app/Repositories/BaseFMRepository.php * Description: Repository dasar untuk semua function module, abstract sehingga tidak dapat di-instance-kan * Author: rudy.gunawan@polytron.co.id * Created: 25/07/2019 */ Contoh blade: <!-- * Filename: resource/view/myblade.blade.php * Description: menyediakan tampilan menu apalah * Author: udin@polybag.com * Created: 31/02/2023 --> Penulisan komentar di definisi class /** * class MyClass digunakan untuk bla bla bla ... */ Class MyClass { ... } Penulisan komentar di deklarasi variable /** * @var varName type dan diskripsi variable */ $varName = 'value'; Penulisan komentar di deklarasi function /** * mendapatkan satu object berdasarkan id * @param id id dari object yang dicari * @return object Illuminate\\Database\\Eloquent\\Model instance */ public function find($id) { // ... } Penulisan namespace pada class php namespace pada class php ditulis satu baris dengan tag pembuka PHP <?php namespace Vendor\\PackageName; Penulisan kurung kurawal pembuka Penulisan kurung kurawal pembuka harus satu baris dengan bagian sebelumnya Contoh: class Test { public function testFunction() { } } Tag Pembuka PHP Tag pembuka PHP yang boleh digunakan hanya <?php dan <?= . Format text file PHP File PHP harus disimpan menggunakan text file format UTF-8 Nama Class Nama class harus dideklarasikan dalam format StudlyCaps (diawali huruf kapital, jika lebih dari satu kata disambung menjadi satu dengan huruf kapital setiap huruf awal kata). Nama Konstanta Konstanta harus dideklarasikan dalam format semua huruf kapital dengan pemisah kata menggunakan tanda garis bawah (_). const PHI = 3.14; const KONSTANTA_SATU = 1; Nama Fungsi atau method Nama Fungsi atau method harus ditulis dalam camelCase (huruf awal huruf kecil, jika lebih dari satu kata ditulis menyambung dengan permulaan kata baru ditulis dengan huruf kapital). Nama Variable Nama variable harus ditulis dalam camelCase (huruf awal huruf kecil, jika lebih dari satu kata ditulis menyambung dengan permulaan kata baru ditulis dengan huruf kapital). Nama Model Eloquent Penamaan model Eloquent menggunakan bahasa Inggris dalam bentuk tunggal, misal: Human, Address Nama relasi dalam Eloquent Jika relasi itu menghasilkan satu object misal belongsTo, hasOne maka ditulis dalam bentuk tunggal. Jika relasi itu menghasilkan lebih dari satu object misal belongsToMany, hasMany maka ditulis dalam bentuk jamak. Nama array dan collection nama array dan collection ditulis dalam bentuk jamak, misal humans, addressses. Nama Tabel dalam database Nama tabel dalam database ditulis dengan snake_case (huruf kecil semua, dengan pemisah kata menggunakan garis-bawah _ ). Nama tabel dalam bahasa Inggris bentuk jamak, misal: humans, addresses. untuk tabel pivot menggunakan nama model yang dihubungkan dalam bentuk tunggal, contoh: human_address. Nama kolom menggunakan snake_case juga. Nama kolom untuk foreign key menggunakan nama model lain yang dihubungkan dan kolom dalam tabel lain yang menghubungkan, contoh: book_id, employee_id. Model Repository dan Function Module Model Repository Function Module Istilah Function module kita adopsi dari SAP, function module adalah modul-modul atau bagian dari aplikasi yang melakukan tugas-tugas functional, dalam pengertian logika utama aplikasi yang berhubungan dengan database. Di dalam Artemis kita menggunakan model repository sebagai function module. Function module ini akan dipanggil dari controller masing-masing menu dan juga dapat dijalankan secara manual oleh system analyst dan developer dalam menu khusus function module. Artemis Builder Artemis memiliki beberapa builder script yang dijalankan melalui perintah artisan. Builder akan mempercepat developer dalam melakukan development suatu aplikasi. Artemis Helper Artemis memiliki beberapa helper untuk mempermudah development. Helper adalah fungsi-fungsi kecil yang dapat dipanggil dimanapun dalam aplikasi.","title":"Artemis Coding Standard"},{"location":"developerdoc/artemis_coding_standard/#artemis-coding-standard","text":"","title":"Artemis Coding Standard"},{"location":"developerdoc/artemis_coding_standard/#struktur-penulisan-file-kode","text":"","title":"Struktur Penulisan file kode"},{"location":"developerdoc/artemis_coding_standard/#penulisan-komentar-di-bagian-awal-file","text":"Komentar diskripsi file harus dituliskan di awal file. Contoh PHP: <?php namespace app\\mylibrary; /** * Filename: app/Repositories/BaseFMRepository.php * Description: Repository dasar untuk semua function module, abstract sehingga tidak dapat di-instance-kan * Author: rudy.gunawan@polytron.co.id * Created: 25/07/2019 */ Contoh blade: <!-- * Filename: resource/view/myblade.blade.php * Description: menyediakan tampilan menu apalah * Author: udin@polybag.com * Created: 31/02/2023 -->","title":"Penulisan komentar di bagian awal file"},{"location":"developerdoc/artemis_coding_standard/#penulisan-komentar-di-definisi-class","text":"/** * class MyClass digunakan untuk bla bla bla ... */ Class MyClass { ... }","title":"Penulisan komentar di definisi class"},{"location":"developerdoc/artemis_coding_standard/#penulisan-komentar-di-deklarasi-variable","text":"/** * @var varName type dan diskripsi variable */ $varName = 'value';","title":"Penulisan komentar di deklarasi variable"},{"location":"developerdoc/artemis_coding_standard/#penulisan-komentar-di-deklarasi-function","text":"/** * mendapatkan satu object berdasarkan id * @param id id dari object yang dicari * @return object Illuminate\\Database\\Eloquent\\Model instance */ public function find($id) { // ... }","title":"Penulisan komentar di deklarasi function"},{"location":"developerdoc/artemis_coding_standard/#penulisan-namespace-pada-class-php","text":"namespace pada class php ditulis satu baris dengan tag pembuka PHP <?php namespace Vendor\\PackageName;","title":"Penulisan namespace pada class php"},{"location":"developerdoc/artemis_coding_standard/#penulisan-kurung-kurawal-pembuka","text":"Penulisan kurung kurawal pembuka harus satu baris dengan bagian sebelumnya Contoh: class Test { public function testFunction() { } }","title":"Penulisan kurung kurawal pembuka"},{"location":"developerdoc/artemis_coding_standard/#tag-pembuka-php","text":"Tag pembuka PHP yang boleh digunakan hanya <?php dan <?= .","title":"Tag Pembuka PHP"},{"location":"developerdoc/artemis_coding_standard/#format-text-file-php","text":"File PHP harus disimpan menggunakan text file format UTF-8","title":"Format text file PHP"},{"location":"developerdoc/artemis_coding_standard/#nama-class","text":"Nama class harus dideklarasikan dalam format StudlyCaps (diawali huruf kapital, jika lebih dari satu kata disambung menjadi satu dengan huruf kapital setiap huruf awal kata).","title":"Nama Class"},{"location":"developerdoc/artemis_coding_standard/#nama-konstanta","text":"Konstanta harus dideklarasikan dalam format semua huruf kapital dengan pemisah kata menggunakan tanda garis bawah (_). const PHI = 3.14; const KONSTANTA_SATU = 1;","title":"Nama Konstanta"},{"location":"developerdoc/artemis_coding_standard/#nama-fungsi-atau-method","text":"Nama Fungsi atau method harus ditulis dalam camelCase (huruf awal huruf kecil, jika lebih dari satu kata ditulis menyambung dengan permulaan kata baru ditulis dengan huruf kapital).","title":"Nama Fungsi atau method"},{"location":"developerdoc/artemis_coding_standard/#nama-variable","text":"Nama variable harus ditulis dalam camelCase (huruf awal huruf kecil, jika lebih dari satu kata ditulis menyambung dengan permulaan kata baru ditulis dengan huruf kapital).","title":"Nama Variable"},{"location":"developerdoc/artemis_coding_standard/#nama-model-eloquent","text":"Penamaan model Eloquent menggunakan bahasa Inggris dalam bentuk tunggal, misal: Human, Address","title":"Nama Model Eloquent"},{"location":"developerdoc/artemis_coding_standard/#nama-relasi-dalam-eloquent","text":"Jika relasi itu menghasilkan satu object misal belongsTo, hasOne maka ditulis dalam bentuk tunggal. Jika relasi itu menghasilkan lebih dari satu object misal belongsToMany, hasMany maka ditulis dalam bentuk jamak.","title":"Nama relasi dalam Eloquent"},{"location":"developerdoc/artemis_coding_standard/#nama-array-dan-collection","text":"nama array dan collection ditulis dalam bentuk jamak, misal humans, addressses.","title":"Nama array dan collection"},{"location":"developerdoc/artemis_coding_standard/#nama-tabel-dalam-database","text":"Nama tabel dalam database ditulis dengan snake_case (huruf kecil semua, dengan pemisah kata menggunakan garis-bawah _ ). Nama tabel dalam bahasa Inggris bentuk jamak, misal: humans, addresses. untuk tabel pivot menggunakan nama model yang dihubungkan dalam bentuk tunggal, contoh: human_address. Nama kolom menggunakan snake_case juga. Nama kolom untuk foreign key menggunakan nama model lain yang dihubungkan dan kolom dalam tabel lain yang menghubungkan, contoh: book_id, employee_id.","title":"Nama Tabel dalam database"},{"location":"developerdoc/artemis_coding_standard/#model-repository-dan-function-module","text":"","title":"Model Repository dan Function Module"},{"location":"developerdoc/artemis_coding_standard/#model-repository","text":"","title":"Model Repository"},{"location":"developerdoc/artemis_coding_standard/#function-module","text":"Istilah Function module kita adopsi dari SAP, function module adalah modul-modul atau bagian dari aplikasi yang melakukan tugas-tugas functional, dalam pengertian logika utama aplikasi yang berhubungan dengan database. Di dalam Artemis kita menggunakan model repository sebagai function module. Function module ini akan dipanggil dari controller masing-masing menu dan juga dapat dijalankan secara manual oleh system analyst dan developer dalam menu khusus function module.","title":"Function Module"},{"location":"developerdoc/artemis_coding_standard/#artemis-builder","text":"Artemis memiliki beberapa builder script yang dijalankan melalui perintah artisan. Builder akan mempercepat developer dalam melakukan development suatu aplikasi.","title":"Artemis Builder"},{"location":"developerdoc/artemis_coding_standard/#artemis-helper","text":"Artemis memiliki beberapa helper untuk mempermudah development. Helper adalah fungsi-fungsi kecil yang dapat dipanggil dimanapun dalam aplikasi.","title":"Artemis Helper"},{"location":"developerdoc/artemis_documentation_editing/","text":"Artemis Documentation Editing","title":"Artemis Documentation Editing"},{"location":"developerdoc/artemis_documentation_editing/#artemis-documentation-editing","text":"","title":"Artemis Documentation Editing"},{"location":"developerdoc/artemis_intro/","text":"Artemis Introduction","title":"Artemis Introduction"},{"location":"developerdoc/artemis_intro/#artemis-introduction","text":"","title":"Artemis Introduction"},{"location":"developerdoc/artemis_ui_standard/","text":"Artemis UI Standard","title":"Artemis UI Design Standard"},{"location":"developerdoc/artemis_ui_standard/#artemis-ui-standard","text":"","title":"Artemis UI Standard"},{"location":"developerdoc/composer/","text":"Composer Composer adalah tool untuk mengatur dependensi pustaka dalam PHP, kita dapat mendefinisikan kebutuhan pustaka yang diperlukan (dependensi) project kita dan composer akan mengaturnya (install/update) untuk kita. Pustaka PHP adalah kumpulan class atau source code PHP yang dibuat untuk dapat digunakan dalam project lain. Saat kita menjalankan install/update composer, Pustaka tersebut diinstall oleh composer ke dalam folder vendor di dalam folder project kita. Definisi dependensi ditulis dalam file composer.json sebagai contoh dibawah ini { \"require\": { \"monolog/monolog\": \"1.0.*\" } } artinya project ini membutuhkan package monolog dari vendor monolog versi lebih besar atau sama dengan 1.0 dan kurang dari 1.1. Install Dependensi untuk menginstall dependensi, di folder project jalankan php composer.phar install atau composer install Update Dependensi untuk mengupdate dependensi, di folder project jalankan php composer.phar update atau composer update untuk menambahkan dependensi kita dapat mengedit langsung composer.json atau dengan menjalankan php composer.phar require vendorname/projectname Composer membuat lock file sesuai update terakhir pada file composer.lock, dan akan memunculkan peringatan jika composer.json dan composer.lock tidak sesuai. Dimana mencari paket pustaka yang mungkin dibutuhkan Paket pustaka PHP opensource yang menggunakan composer dapat ditemukan di repository utama composer yaitu Packagist.org . Class Autoloader Untuk pustaka yang memuat info autoload, composer akan membuat vendor/autoload.php sehingga Anda lebih mudah dalam menyertakan class-class yang diperlukan, hanya dengan menyertakan file autoload ini. contoh dalam kode project Anda, require __DIR__ . '/vendor/autoload.php'; $log = new Monolog\\Logger('name'); $log->pushHandler(new Monolog\\Handler\\StreamHandler('app.log', Monolog\\Logger::WARNING)); $log->addWarning('Foo'); Cara update script composer Kadangkala script composer itu sendiri perlu diupdate. jalankan perintah di bawah ini untuk mengupdate composer composer self-update","title":"Composer"},{"location":"developerdoc/composer/#composer","text":"Composer adalah tool untuk mengatur dependensi pustaka dalam PHP, kita dapat mendefinisikan kebutuhan pustaka yang diperlukan (dependensi) project kita dan composer akan mengaturnya (install/update) untuk kita. Pustaka PHP adalah kumpulan class atau source code PHP yang dibuat untuk dapat digunakan dalam project lain. Saat kita menjalankan install/update composer, Pustaka tersebut diinstall oleh composer ke dalam folder vendor di dalam folder project kita. Definisi dependensi ditulis dalam file composer.json sebagai contoh dibawah ini { \"require\": { \"monolog/monolog\": \"1.0.*\" } } artinya project ini membutuhkan package monolog dari vendor monolog versi lebih besar atau sama dengan 1.0 dan kurang dari 1.1.","title":"Composer"},{"location":"developerdoc/composer/#install-dependensi","text":"untuk menginstall dependensi, di folder project jalankan php composer.phar install atau composer install","title":"Install Dependensi"},{"location":"developerdoc/composer/#update-dependensi","text":"untuk mengupdate dependensi, di folder project jalankan php composer.phar update atau composer update untuk menambahkan dependensi kita dapat mengedit langsung composer.json atau dengan menjalankan php composer.phar require vendorname/projectname Composer membuat lock file sesuai update terakhir pada file composer.lock, dan akan memunculkan peringatan jika composer.json dan composer.lock tidak sesuai.","title":"Update Dependensi"},{"location":"developerdoc/composer/#dimana-mencari-paket-pustaka-yang-mungkin-dibutuhkan","text":"Paket pustaka PHP opensource yang menggunakan composer dapat ditemukan di repository utama composer yaitu Packagist.org .","title":"Dimana mencari paket pustaka yang mungkin dibutuhkan"},{"location":"developerdoc/composer/#class-autoloader","text":"Untuk pustaka yang memuat info autoload, composer akan membuat vendor/autoload.php sehingga Anda lebih mudah dalam menyertakan class-class yang diperlukan, hanya dengan menyertakan file autoload ini. contoh dalam kode project Anda, require __DIR__ . '/vendor/autoload.php'; $log = new Monolog\\Logger('name'); $log->pushHandler(new Monolog\\Handler\\StreamHandler('app.log', Monolog\\Logger::WARNING)); $log->addWarning('Foo');","title":"Class Autoloader"},{"location":"developerdoc/composer/#cara-update-script-composer","text":"Kadangkala script composer itu sendiri perlu diupdate. jalankan perintah di bawah ini untuk mengupdate composer composer self-update","title":"Cara update script composer"},{"location":"developerdoc/git/","text":"GIT Dalam lingkungan pengembangan ini kita menggunakan git sebagai source code version control sehingga menggunakan paradigma pemrograman terdistribusi, masing-masing programmer memiliki salinan source code, web server dan bahkan database server di PC masing-masing. Mereka memodifikasi source code project yang sama di PC mereka masing-masing. Mereka juga mencoba (trial) aplikasi mereka di PC masing-masing. Jika aplikasi berjalan dengan baik di webserver lokal, programmer dapat mengirimkan modifikasi source code ke gitserver, kemudian project maintainer akan memeriksa source code mereka. Setelah source code dinilai layak dan bebas bug, project maintainer akan memasang (publish) source code ke webserver PRODUCTION. Keamanan Server Karena source code terdistribusi ke masing-masing PC programmer, setting yang berhubungan keamanan misal akses ke DB server PRODUCTION diharuskan tidak tertulis (hard-coded) di source code. sehingga setting di webserver trial dan di webserver PRODUCTION berbeda. Hanya webserver administrator yang mengetahui setting di webserver PRODUCTION. Alur Pengembangan Aplikasi dengan GIT Git Repository Git Repository adalah suatu monitoring perubahan terhadap suatu kumpulan file atau folder. Biasanya berada di dalam folder yang dimonitor. Git repository bisa berada di PC lokal dan di remote/server. Lingkungan pengembangan aplikasi ESD-Application memiliki git repositories server, yang berfungsi sebagai penampung project-project yang sedang/sudah dikerjakan oleh tim developer aplikasi inhouse. Alamat intranet git repositories server ESD-Application di https://artemisdev.polytron.co.id:3000 . Satu repository mewakili satu project aplikasi, masing-masing developer dapat meng-clone repository ke PC lokal masing-masing, dan/atau ke repository milik developer tersebut di repository server. Berikut ini cara melakukan clone git repository dari server mkdir /d/gits cd /d/gits/ git clone [url_git_repository_sumber] [nama_folder_local_repository] Anda juga bisa clone git repository dari folder lain di PC lokal Anda. Perintah untuk menjadikan suatu folder menjadi git repository di PC lokal Anda adalah sebagai berikut, cd /d/gits mkdir my-project-1 cd my-project-1 git init Git repository yang di PC lokal Anda dapat diedit isi folder seperti folder biasa. Sedangkan git repository di server hanya berisi informasi perubahan isi file di repository tersebut, repository ini disebut bare repository. Anda dapat membuat bare repository di PC lokal Anda dengan perintah berikut, cd /d/gits mkdir my-project-2 cd my-project-2 git init --bare Di dalam bare repository tidak terdapat file dan folder isi dari repository tersebut, jadi tidak memungkinkan editing di bare repository. Perintah git yang sering digunakan Git Remote Repository git repository di lokal dapat memiliki remote repository di server ataupun di lokasi lain dalam PC tersebut/USB flashdisk. untuk melihat remote repository yang sudah terdaftar di repository itu git remote git remote -v untuk menambahkan remote repository baru git remote add [alias_remote_repository] [url_remote_repository] git remote add flash /e/gits/projectname git remote add dev https://artemisdev.polytron.co.id:3000/appdev/projectname Remote repository sumber dari proses git clone akan disebut dengan alias origin untuk menghapus remote repository dari pc lokal git remote remove [alias] git remote remove flash Git add Untuk menambahkan file/folder ke daftar file/folder yang di-monitor/di-track perubahannya. git add *.php git add -A git add --all git add -A digunakan untuk menambahkan/update semua file/folder yang ada di path sekarang ke proses staging git. tahapan umum dalam git: untracked/modified files -> staged changes -> commited changes Git status Untuk melihat status git repository saat ini git status akan memperlihatkan status file/folder dalam repository, apakah ada perubahan/ file baru / status commit. Git commit untuk menyimpan perubahan ke dalam git repository. git commit -a -m \"keterangan commit\" -a artinya secara otomatis akan menambahkan semua file yang dimodif dan dihapus ke dalam staging git sebelum di-commit. -m \"pesan\" artinya menambahkan keterangan commit langsung dari parameter setelahnya. Setiap commit mempunyai commitID tertentu, Untuk mendapatkan beberapa commit terakhir dapat digunakan alias berikut * HEAD = commit terakhir. * HEAD^ = 1 commit sebelum commit terakhir. * HEAD~2 = 2 commit sebelum commit terakhir. * dst... Git log untuk melihat log/history proses commit pada repository git. git log untuk keluar dari tampilan git log, gunakan tombol q. Git diff untuk menampilkan perubahan antara masing-masing commit, commit dan working tree, dan lain-lain. git diff HEAD filename git diff HEAD git diff branchname git diff commitID filename HEAD adalah alias dari commitID terakhir yang di-commit. Git Branch Git repository dapat memiliki satu atau lebih branch. Branch adalah suatu percabangan development. Branch utama disebut master. Cara melihat branch yang dimiliki suatu repository $ git branch Cara membuat branch baru $ git branch branchname Cara menghapus branch $ git branch -d branchname Cara berpindah ke branch tertentu $ git checkout branchname Git Pull Untuk menarik perubahan dari upstream remote repository ke repository lokal pada branch yang aktif, dan sekaligus melakukan automatic merge jika tidak ada konflik. $ git pull remoteAlias branchname Git Push Untuk mengirim perubahan dari repository lokal branch yang aktif ke upstream remote repository. Jika terjadi konflik, proses push akan ditolak, konflik harus diselesaikan di repository lokal terlebih dahulu. $ git push remoteAlias branchname Git reset Reset HEAD ke kondisi yang ditentukan Contoh: undo add edit filename1 git add filename1 git reset kondisi working tree disamakan ke kondisi commit terakhir dengan membiarkan perubahan di filename1 tetap ada di working tree dengan status belum di-add ke staging. Contoh: undo commit dan redo git commit ... git reset --soft HEAD^ edit git commit -a -c ORIG_HEAD Suatu waktu, Anda ingat commit yang Anda lakukan sebelumnya tidak lengkap atau ada yang salah dengan keterangan commit sebelumnya. kembalikan working tree ke kondisi semula sebelumnya. Buat koreksi di working tree. proses \"reset\" menyalin head semula ke .git/ORIG_HEAD, melakukan commit ulang dengan pesan log baru. Jika Anda tidak ingin mengganti pesan log, Anda cukup menggunakan opsi -C. Contoh: Undo Commit secara permanen git commit ... git reset --hard HEAD~3 Jika 3 commit sebelumnya dianggap jelek / tidak mau dipakai lebih lanjut. kita merasa perlu menghapus 3 commit terakhir. maka gunakan --hard untuk menghapus commit tersebut. JANGAN GUNAKAN ini jika Anda sudah membagikan commit yang Anda lakukan ke orang lain (sudah dikirim ke remote server). Contoh: Undo merge atau pull $ git pull Auto-merging master CONFLICT (content): Merge conflict in master Automatic merge failed; fix conflicts and then commit the result. $ git reset --hard $ git pull . topic/branch Updating from 41223... to 13134... Fast-forward $ git reset --hard ORIG_HEAD Mencoba update dari upstream, ternyata menghasilkan banyak konflik, saat Anda tidak ada waktu untuk menyelesaikan konflik dan melakukan merge, Anda bisa melakukannya lain waktu. \"pull\" belum melakukan merge, jadi git reset --hard yang sinonim dengan git reset --hard HEAD menghapus semua perubahan yang belum di-commit dalam git maupun working tree. Merge sebuah branch topic ke branch aktif sekarang berhasil. Tapi Anda ingin meng-undo proses merge tersebut, proses \"pull\" or \"merge\" selalu meninggalkan tautan commit sebelumnya dari branch aktif dalam ORIG_HEAD, jadi dengan me-reset hard ke ORIG_HEAD akan mengembalikan git index dan working tree ke kondisi sebelumnya, dan mengembalikan juga tautan branch tersebut ke commit tersebut. Contoh: Undo merge atau pull ke working tree yang kotor $ git pull (1) Auto-merging master Merge made by recursive. master | 20 +++++---- ... $ git reset --merge ORIG_HEAD (2) Saat di dalam working tree Anda masih ada modifikasi yang belum disimpan sekalipun, Anda dapat melakukan git pull secara aman ketika Anda tahu bahwa perubahan yang Anda tarik tidak berpengaruh pada file yang sedang Anda modif di working tree Anda. Setelah memeriksa hasil merge dari proses pull, ternyata Anda menemukan branch yang Anda pull kurang sesuai dengan keinginan Anda. Anda dapat melakukan reset, menjalankan git reset --hard ORIG_HEAD akan mengembalikannya tapi proses ini akan menghapus juga modifikasi yang Anda lakukan di working tree Anda, untuk itu gunakan git reset --merge untuk membiarkan modifikasi Anda tetap ada di working tree Anda. Contoh: Saat ada interupsi project Seandainya pekerjaan Anda diinterupsi oleh tugas bug fix yang urgent dan Anda tidak ingin melakukan commit pekerjaan Anda saat ini, Anda butuh membuat branch lain untuk bugfix tersebut. $ git checkout feature ;# you were working in \"feature\" branch and $ work work work ;# got interrupted $ git commit -a -m \"snapshot WIP\" (1) $ git checkout master $ fix fix fix $ git commit ;# commit with real log $ git checkout feature $ git reset --soft HEAD^ ;# go back to WIP state (2) $ git reset (3) Commit perubahan work-in-progress. Commit history kembali ke sebelum \"snapshot WIP\" commit. Update index untuk menunjukkan file yang termasuk dalam \"snapshot WIP\" commit sebagai belum di-commit. ada cara lain untuk kasus ini yaitu menggunakan stash , yang akan dibahas pada bagian selanjutnya. Contoh: Reset satu file tertentu Seandainya Anda telah menambahkkan sebuah perubahan file ke staging index, kemudian tidak ingin menambahkan file tersebut ke commit berikutnya. Anda dapat mengeluarkan perubahan file yang sudah di-staging dengan git reset. $ git reset -- frotz.c (1) $ git commit -m \"Commit files in index\" (2) $ git add frotz.c (3) menghapus perubahan dari staging. commit perubahan yang sudah di-staging. menambahkan kembali perubahan file tadi ke staging. Contoh: Membiarkan perubahan di working tree dan menghapus commit sebelumnya Seandainya Anda telah melakukan banyak perubahan yang secara logis dapat dipisahkan ke branch lain dan telah melakukan commit semua perubahan itu bersamaan. Kemudian, Anda memutuskan mungkin lebih baik kalo commit dilakukan dalam branch terpisah masing-masing bagiannya. Anda dapat menggunakan git reset untuk mengembalikan history tanpa mengubah isi file di lokal working tree, kemudian menambahkan satu persatu bagian untuk di-commit pada branch terpisah, gunakan git commit -c untuk memakai kembali keterangan commit sebelumnya. $ git tag start $ git checkout -b branch1 $ edit $ git commit ... (1) $ edit $ git checkout -b branch2 (2) $ git reset --keep start (3) melakukan commit bagian pertama di branch branch1. Anda ingin kalo perubahan yang sudah di-commit di branch1 tidak ingin Anda masukkan di branch2. Anda dapat menggunakan git reset --keep <tagname> untuk menghapus perubahan terakhir di branch1. Git Stash Misal saat terjadi interupsi, yang mengharuskan kita berpindah ke kondisi source code tertentu, padahal kita tidak ingin hasil kerja kita hilang dan saat itu kita juga tidak ingin melakukan commit hasil kerja kita, kita dapat menggunakan stash . Stash adalah tampungan sementara perubahan yang belum masuk tahap staging, untuk menyingkirkan sementara perubahan itu, saat kita bekerja dengan perubahan lain tanpa melakukan branching dan commit. Modifikasi yang masuk dalam stash dapat dilihat dengan git stash list , diperiksa dengan git stash show , dan dikembalikan dengan git stash apply . menjalankan git stash tanpa parameter sama dengan menjalankan git stash push . Sebuah stash secara default didaftar sebagai \"WIP on branchname ...\", tapi Anda juga dapat menambahkan komentar yang lebih deskriptif saat membuatnya dengan parameter git stash -m \"komentar\" . Stash terakhir yang Anda buat akan tersimpan dalam refs/stash . Stash yang lebih lama akan tersimpan dalam reflog dari referensi ini dan dapat dinamai menggunakan sintaks reflog, misal: stash@{0} adalah stash yang paling terakhir dibuat, stash@{1} adalah stash 1 sebelum yang terakhir, stash@{2.hours.ago} juga mungkin digunakan). Stash juga dapat direferensikan dengan hanya menyebutkan stash index -nya, misal: integer n sama dengan stash@{n}. Contoh: Pull ke Working Tree yang tidak bersih Ketika Anda sedang mengerjakan suatu perubahan, Anda mendapat kabar bahwa di upstream repository ada perubahan yang kemungkinan berkaitan dengan yang sedang Anda kerjakan. Ketika perubahan yang sedang Anda kerjakan tidak konflik dengan upstream, git pull akan otomatis merge. Tetapi, jika terjadi konflik dengan upstream, Anda dapat melakukan stash terlebih dulu kemudian melakukan pull , selanjutnya unstash , $ git pull ... file foobar not up to date, cannot merge. $ git stash $ git pull $ git stash pop Contoh: Pekerjaan yang terinterupsi Ketika Anda sedang mengerjakan suatu perubahan, tiba-tiba ada laporan bug, Anda harus memperbaikinya segera, Anda harus menyimpan pekerjaan Anda dengan commit ke branch sementara dan meninggalkannya, dan kemudian Anda akan kembali ke branch awal untuk melakukan perubahan perbaikan darurat (bug fix) seperti ini, # ... hack hack hack ... $ git checkout -b my_wip $ git commit -a -m \"WIP\" $ git checkout master $ edit emergency fix $ git commit -a -m \"Fix in a hurry\" $ git checkout my_wip $ git reset --soft HEAD^ # ... continue hacking ... langkah di atas cukup rumit bukan? Anda dapat menggunakan git stash untuk menyederhanakan langkah di atas seperti sebagai berikut, # ... hack hack hack ... $ git stash $ edit emergency fix $ git commit -a -m \"Fix in a hurry\" $ git stash pop # ... continue hacking ... Contoh: Testing partial commits Anda dapat menggunakan git stash push --keep-index ketika Anda ingin membuat 2 atau lebih commit dari perubahan dalam work tree, dan ingin melakukan test sebelum masing-masing commit, # ... hack hack hack ... $ git add --patch filename.php # interactively select which part to be add to stage, add just first part to the index $ git stash push --keep-index # save all other changes to the stash $ edit/build/test first part $ git commit -m 'First part' # commit fully tested change $ git stash pop # prepare to work on all other changes # ... repeat above five steps until one commit remains ... $ edit/build/test remaining parts $ git commit filename.php -m 'Remaining parts' Git tag Tag adalah semacam alias/reference untuk menunjuk ke commitID tertentu. Digunakan misal untuk membuat release version. Tag akan disimpan di folder .git/refs/tags/ . Untuk melihat daftar tag yang sudah ada git tag -l Untuk membuat tag baru $ git tag tagname $ git tag v.0.0.1 untuk menghapus tag yang sudah ada git tag -d tagname","title":"Git"},{"location":"developerdoc/git/#git","text":"Dalam lingkungan pengembangan ini kita menggunakan git sebagai source code version control sehingga menggunakan paradigma pemrograman terdistribusi, masing-masing programmer memiliki salinan source code, web server dan bahkan database server di PC masing-masing. Mereka memodifikasi source code project yang sama di PC mereka masing-masing. Mereka juga mencoba (trial) aplikasi mereka di PC masing-masing. Jika aplikasi berjalan dengan baik di webserver lokal, programmer dapat mengirimkan modifikasi source code ke gitserver, kemudian project maintainer akan memeriksa source code mereka. Setelah source code dinilai layak dan bebas bug, project maintainer akan memasang (publish) source code ke webserver PRODUCTION.","title":"GIT"},{"location":"developerdoc/git/#keamanan-server","text":"Karena source code terdistribusi ke masing-masing PC programmer, setting yang berhubungan keamanan misal akses ke DB server PRODUCTION diharuskan tidak tertulis (hard-coded) di source code. sehingga setting di webserver trial dan di webserver PRODUCTION berbeda. Hanya webserver administrator yang mengetahui setting di webserver PRODUCTION.","title":"Keamanan Server"},{"location":"developerdoc/git/#alur-pengembangan-aplikasi-dengan-git","text":"","title":"Alur Pengembangan Aplikasi dengan GIT"},{"location":"developerdoc/git/#git-repository","text":"Git Repository adalah suatu monitoring perubahan terhadap suatu kumpulan file atau folder. Biasanya berada di dalam folder yang dimonitor. Git repository bisa berada di PC lokal dan di remote/server. Lingkungan pengembangan aplikasi ESD-Application memiliki git repositories server, yang berfungsi sebagai penampung project-project yang sedang/sudah dikerjakan oleh tim developer aplikasi inhouse. Alamat intranet git repositories server ESD-Application di https://artemisdev.polytron.co.id:3000 . Satu repository mewakili satu project aplikasi, masing-masing developer dapat meng-clone repository ke PC lokal masing-masing, dan/atau ke repository milik developer tersebut di repository server. Berikut ini cara melakukan clone git repository dari server mkdir /d/gits cd /d/gits/ git clone [url_git_repository_sumber] [nama_folder_local_repository] Anda juga bisa clone git repository dari folder lain di PC lokal Anda. Perintah untuk menjadikan suatu folder menjadi git repository di PC lokal Anda adalah sebagai berikut, cd /d/gits mkdir my-project-1 cd my-project-1 git init Git repository yang di PC lokal Anda dapat diedit isi folder seperti folder biasa. Sedangkan git repository di server hanya berisi informasi perubahan isi file di repository tersebut, repository ini disebut bare repository. Anda dapat membuat bare repository di PC lokal Anda dengan perintah berikut, cd /d/gits mkdir my-project-2 cd my-project-2 git init --bare Di dalam bare repository tidak terdapat file dan folder isi dari repository tersebut, jadi tidak memungkinkan editing di bare repository.","title":"Git Repository"},{"location":"developerdoc/git/#perintah-git-yang-sering-digunakan","text":"","title":"Perintah git yang sering digunakan"},{"location":"developerdoc/git/#git-remote-repository","text":"git repository di lokal dapat memiliki remote repository di server ataupun di lokasi lain dalam PC tersebut/USB flashdisk. untuk melihat remote repository yang sudah terdaftar di repository itu git remote git remote -v untuk menambahkan remote repository baru git remote add [alias_remote_repository] [url_remote_repository] git remote add flash /e/gits/projectname git remote add dev https://artemisdev.polytron.co.id:3000/appdev/projectname Remote repository sumber dari proses git clone akan disebut dengan alias origin untuk menghapus remote repository dari pc lokal git remote remove [alias] git remote remove flash","title":"Git Remote Repository"},{"location":"developerdoc/git/#git-add","text":"Untuk menambahkan file/folder ke daftar file/folder yang di-monitor/di-track perubahannya. git add *.php git add -A git add --all git add -A digunakan untuk menambahkan/update semua file/folder yang ada di path sekarang ke proses staging git. tahapan umum dalam git: untracked/modified files -> staged changes -> commited changes","title":"Git add"},{"location":"developerdoc/git/#git-status","text":"Untuk melihat status git repository saat ini git status akan memperlihatkan status file/folder dalam repository, apakah ada perubahan/ file baru / status commit.","title":"Git status"},{"location":"developerdoc/git/#git-commit","text":"untuk menyimpan perubahan ke dalam git repository. git commit -a -m \"keterangan commit\" -a artinya secara otomatis akan menambahkan semua file yang dimodif dan dihapus ke dalam staging git sebelum di-commit. -m \"pesan\" artinya menambahkan keterangan commit langsung dari parameter setelahnya. Setiap commit mempunyai commitID tertentu, Untuk mendapatkan beberapa commit terakhir dapat digunakan alias berikut * HEAD = commit terakhir. * HEAD^ = 1 commit sebelum commit terakhir. * HEAD~2 = 2 commit sebelum commit terakhir. * dst...","title":"Git commit"},{"location":"developerdoc/git/#git-log","text":"untuk melihat log/history proses commit pada repository git. git log untuk keluar dari tampilan git log, gunakan tombol q.","title":"Git log"},{"location":"developerdoc/git/#git-diff","text":"untuk menampilkan perubahan antara masing-masing commit, commit dan working tree, dan lain-lain. git diff HEAD filename git diff HEAD git diff branchname git diff commitID filename HEAD adalah alias dari commitID terakhir yang di-commit.","title":"Git diff"},{"location":"developerdoc/git/#git-branch","text":"Git repository dapat memiliki satu atau lebih branch. Branch adalah suatu percabangan development. Branch utama disebut master. Cara melihat branch yang dimiliki suatu repository $ git branch Cara membuat branch baru $ git branch branchname Cara menghapus branch $ git branch -d branchname Cara berpindah ke branch tertentu $ git checkout branchname","title":"Git Branch"},{"location":"developerdoc/git/#git-pull","text":"Untuk menarik perubahan dari upstream remote repository ke repository lokal pada branch yang aktif, dan sekaligus melakukan automatic merge jika tidak ada konflik. $ git pull remoteAlias branchname","title":"Git Pull"},{"location":"developerdoc/git/#git-push","text":"Untuk mengirim perubahan dari repository lokal branch yang aktif ke upstream remote repository. Jika terjadi konflik, proses push akan ditolak, konflik harus diselesaikan di repository lokal terlebih dahulu. $ git push remoteAlias branchname","title":"Git Push"},{"location":"developerdoc/git/#git-reset","text":"Reset HEAD ke kondisi yang ditentukan","title":"Git reset"},{"location":"developerdoc/git/#contoh-undo-add","text":"edit filename1 git add filename1 git reset kondisi working tree disamakan ke kondisi commit terakhir dengan membiarkan perubahan di filename1 tetap ada di working tree dengan status belum di-add ke staging.","title":"Contoh: undo add"},{"location":"developerdoc/git/#contoh-undo-commit-dan-redo","text":"git commit ... git reset --soft HEAD^ edit git commit -a -c ORIG_HEAD Suatu waktu, Anda ingat commit yang Anda lakukan sebelumnya tidak lengkap atau ada yang salah dengan keterangan commit sebelumnya. kembalikan working tree ke kondisi semula sebelumnya. Buat koreksi di working tree. proses \"reset\" menyalin head semula ke .git/ORIG_HEAD, melakukan commit ulang dengan pesan log baru. Jika Anda tidak ingin mengganti pesan log, Anda cukup menggunakan opsi -C.","title":"Contoh: undo commit dan redo"},{"location":"developerdoc/git/#contoh-undo-commit-secara-permanen","text":"git commit ... git reset --hard HEAD~3 Jika 3 commit sebelumnya dianggap jelek / tidak mau dipakai lebih lanjut. kita merasa perlu menghapus 3 commit terakhir. maka gunakan --hard untuk menghapus commit tersebut. JANGAN GUNAKAN ini jika Anda sudah membagikan commit yang Anda lakukan ke orang lain (sudah dikirim ke remote server).","title":"Contoh: Undo Commit secara permanen"},{"location":"developerdoc/git/#contoh-undo-merge-atau-pull","text":"$ git pull Auto-merging master CONFLICT (content): Merge conflict in master Automatic merge failed; fix conflicts and then commit the result. $ git reset --hard $ git pull . topic/branch Updating from 41223... to 13134... Fast-forward $ git reset --hard ORIG_HEAD Mencoba update dari upstream, ternyata menghasilkan banyak konflik, saat Anda tidak ada waktu untuk menyelesaikan konflik dan melakukan merge, Anda bisa melakukannya lain waktu. \"pull\" belum melakukan merge, jadi git reset --hard yang sinonim dengan git reset --hard HEAD menghapus semua perubahan yang belum di-commit dalam git maupun working tree. Merge sebuah branch topic ke branch aktif sekarang berhasil. Tapi Anda ingin meng-undo proses merge tersebut, proses \"pull\" or \"merge\" selalu meninggalkan tautan commit sebelumnya dari branch aktif dalam ORIG_HEAD, jadi dengan me-reset hard ke ORIG_HEAD akan mengembalikan git index dan working tree ke kondisi sebelumnya, dan mengembalikan juga tautan branch tersebut ke commit tersebut.","title":"Contoh: Undo merge atau pull"},{"location":"developerdoc/git/#contoh-undo-merge-atau-pull-ke-working-tree-yang-kotor","text":"$ git pull (1) Auto-merging master Merge made by recursive. master | 20 +++++---- ... $ git reset --merge ORIG_HEAD (2) Saat di dalam working tree Anda masih ada modifikasi yang belum disimpan sekalipun, Anda dapat melakukan git pull secara aman ketika Anda tahu bahwa perubahan yang Anda tarik tidak berpengaruh pada file yang sedang Anda modif di working tree Anda. Setelah memeriksa hasil merge dari proses pull, ternyata Anda menemukan branch yang Anda pull kurang sesuai dengan keinginan Anda. Anda dapat melakukan reset, menjalankan git reset --hard ORIG_HEAD akan mengembalikannya tapi proses ini akan menghapus juga modifikasi yang Anda lakukan di working tree Anda, untuk itu gunakan git reset --merge untuk membiarkan modifikasi Anda tetap ada di working tree Anda.","title":"Contoh: Undo merge atau pull ke working tree yang kotor"},{"location":"developerdoc/git/#contoh-saat-ada-interupsi-project","text":"Seandainya pekerjaan Anda diinterupsi oleh tugas bug fix yang urgent dan Anda tidak ingin melakukan commit pekerjaan Anda saat ini, Anda butuh membuat branch lain untuk bugfix tersebut. $ git checkout feature ;# you were working in \"feature\" branch and $ work work work ;# got interrupted $ git commit -a -m \"snapshot WIP\" (1) $ git checkout master $ fix fix fix $ git commit ;# commit with real log $ git checkout feature $ git reset --soft HEAD^ ;# go back to WIP state (2) $ git reset (3) Commit perubahan work-in-progress. Commit history kembali ke sebelum \"snapshot WIP\" commit. Update index untuk menunjukkan file yang termasuk dalam \"snapshot WIP\" commit sebagai belum di-commit. ada cara lain untuk kasus ini yaitu menggunakan stash , yang akan dibahas pada bagian selanjutnya.","title":"Contoh: Saat ada interupsi project"},{"location":"developerdoc/git/#contoh-reset-satu-file-tertentu","text":"Seandainya Anda telah menambahkkan sebuah perubahan file ke staging index, kemudian tidak ingin menambahkan file tersebut ke commit berikutnya. Anda dapat mengeluarkan perubahan file yang sudah di-staging dengan git reset. $ git reset -- frotz.c (1) $ git commit -m \"Commit files in index\" (2) $ git add frotz.c (3) menghapus perubahan dari staging. commit perubahan yang sudah di-staging. menambahkan kembali perubahan file tadi ke staging.","title":"Contoh: Reset satu file tertentu"},{"location":"developerdoc/git/#contoh-membiarkan-perubahan-di-working-tree-dan-menghapus-commit-sebelumnya","text":"Seandainya Anda telah melakukan banyak perubahan yang secara logis dapat dipisahkan ke branch lain dan telah melakukan commit semua perubahan itu bersamaan. Kemudian, Anda memutuskan mungkin lebih baik kalo commit dilakukan dalam branch terpisah masing-masing bagiannya. Anda dapat menggunakan git reset untuk mengembalikan history tanpa mengubah isi file di lokal working tree, kemudian menambahkan satu persatu bagian untuk di-commit pada branch terpisah, gunakan git commit -c untuk memakai kembali keterangan commit sebelumnya. $ git tag start $ git checkout -b branch1 $ edit $ git commit ... (1) $ edit $ git checkout -b branch2 (2) $ git reset --keep start (3) melakukan commit bagian pertama di branch branch1. Anda ingin kalo perubahan yang sudah di-commit di branch1 tidak ingin Anda masukkan di branch2. Anda dapat menggunakan git reset --keep <tagname> untuk menghapus perubahan terakhir di branch1.","title":"Contoh: Membiarkan perubahan di working tree dan menghapus commit sebelumnya"},{"location":"developerdoc/git/#git-stash","text":"Misal saat terjadi interupsi, yang mengharuskan kita berpindah ke kondisi source code tertentu, padahal kita tidak ingin hasil kerja kita hilang dan saat itu kita juga tidak ingin melakukan commit hasil kerja kita, kita dapat menggunakan stash . Stash adalah tampungan sementara perubahan yang belum masuk tahap staging, untuk menyingkirkan sementara perubahan itu, saat kita bekerja dengan perubahan lain tanpa melakukan branching dan commit. Modifikasi yang masuk dalam stash dapat dilihat dengan git stash list , diperiksa dengan git stash show , dan dikembalikan dengan git stash apply . menjalankan git stash tanpa parameter sama dengan menjalankan git stash push . Sebuah stash secara default didaftar sebagai \"WIP on branchname ...\", tapi Anda juga dapat menambahkan komentar yang lebih deskriptif saat membuatnya dengan parameter git stash -m \"komentar\" . Stash terakhir yang Anda buat akan tersimpan dalam refs/stash . Stash yang lebih lama akan tersimpan dalam reflog dari referensi ini dan dapat dinamai menggunakan sintaks reflog, misal: stash@{0} adalah stash yang paling terakhir dibuat, stash@{1} adalah stash 1 sebelum yang terakhir, stash@{2.hours.ago} juga mungkin digunakan). Stash juga dapat direferensikan dengan hanya menyebutkan stash index -nya, misal: integer n sama dengan stash@{n}.","title":"Git Stash"},{"location":"developerdoc/git/#contoh-pull-ke-working-tree-yang-tidak-bersih","text":"Ketika Anda sedang mengerjakan suatu perubahan, Anda mendapat kabar bahwa di upstream repository ada perubahan yang kemungkinan berkaitan dengan yang sedang Anda kerjakan. Ketika perubahan yang sedang Anda kerjakan tidak konflik dengan upstream, git pull akan otomatis merge. Tetapi, jika terjadi konflik dengan upstream, Anda dapat melakukan stash terlebih dulu kemudian melakukan pull , selanjutnya unstash , $ git pull ... file foobar not up to date, cannot merge. $ git stash $ git pull $ git stash pop","title":"Contoh: Pull ke Working Tree yang tidak bersih"},{"location":"developerdoc/git/#contoh-pekerjaan-yang-terinterupsi","text":"Ketika Anda sedang mengerjakan suatu perubahan, tiba-tiba ada laporan bug, Anda harus memperbaikinya segera, Anda harus menyimpan pekerjaan Anda dengan commit ke branch sementara dan meninggalkannya, dan kemudian Anda akan kembali ke branch awal untuk melakukan perubahan perbaikan darurat (bug fix) seperti ini, # ... hack hack hack ... $ git checkout -b my_wip $ git commit -a -m \"WIP\" $ git checkout master $ edit emergency fix $ git commit -a -m \"Fix in a hurry\" $ git checkout my_wip $ git reset --soft HEAD^ # ... continue hacking ... langkah di atas cukup rumit bukan? Anda dapat menggunakan git stash untuk menyederhanakan langkah di atas seperti sebagai berikut, # ... hack hack hack ... $ git stash $ edit emergency fix $ git commit -a -m \"Fix in a hurry\" $ git stash pop # ... continue hacking ...","title":"Contoh: Pekerjaan yang terinterupsi"},{"location":"developerdoc/git/#contoh-testing-partial-commits","text":"Anda dapat menggunakan git stash push --keep-index ketika Anda ingin membuat 2 atau lebih commit dari perubahan dalam work tree, dan ingin melakukan test sebelum masing-masing commit, # ... hack hack hack ... $ git add --patch filename.php # interactively select which part to be add to stage, add just first part to the index $ git stash push --keep-index # save all other changes to the stash $ edit/build/test first part $ git commit -m 'First part' # commit fully tested change $ git stash pop # prepare to work on all other changes # ... repeat above five steps until one commit remains ... $ edit/build/test remaining parts $ git commit filename.php -m 'Remaining parts'","title":"Contoh: Testing partial commits"},{"location":"developerdoc/git/#git-tag","text":"Tag adalah semacam alias/reference untuk menunjuk ke commitID tertentu. Digunakan misal untuk membuat release version. Tag akan disimpan di folder .git/refs/tags/ . Untuk melihat daftar tag yang sudah ada git tag -l Untuk membuat tag baru $ git tag tagname $ git tag v.0.0.1 untuk menghapus tag yang sudah ada git tag -d tagname","title":"Git tag"},{"location":"developerdoc/installation/","text":"Installation Dokumen ini menjelaskan tentang instalasi software yang dibutuhkan dan persiapan lingkungan pengembangan di PC lokal developer. Software yang dibutuhkan instalasi ini dapat diperoleh di lokal server share section folder ESD-Application: M:\\Share\\master\\php-laravel Software Requirements for Artemis Developer PC Git RSync Composer XAMPP - Apache2 web server, MariaDB database server, PHP, phpMyAdmin (optional, untuk debuging di PC lokal) Visual Studio Code Modelio Pencil MkDocs (optional, untuk pengembangan dokumentasi) Langkah Instalasi akan terdiri dari, instalasi XAMPP (Apache2 web server, MariaDB database server, PHP, phpMyAdmin) instalasi git for windows instalasi rsync di dalam gitbash instalasi composer instalasi Microsoft Visual Studio Code instalasi Modelio instalasi Pencil instalasi MkDocs XAMPP Installation Download XAMPP dari https://www.apachefriends.org/download.html . Jalankan dan ikuti proses instalasi di Windows 10. Setting agar php.exe dapat mudah ditemukan yaitu dengan menambahkannya di PATH environment variable. Cara setting PATH PHP: Buka Windows Start menu search (shortcut: Windows + s ), ketik env, akan muncul Edit Environment Variable for Your Account pilih PATH, pilih tombol Edit pilih NEW pilih Browse, pilih lokasi php.exe di folder instalasi XAMPP. contoh: d:\\xampp\\php . pilih simpan/OK Git Installation Download git for Windows di https://git-scm.com/downloads . Jalankan dan ikuti proses instalasi di Windows. untuk melihat php sudah dapat dijalankan di gitbash, buka gitbash dan ketik, which php php --version versi php setidaknya PHP >= 7.1.3 untuk Laravel 5.8 RSync Installation Jangan gunakan cwRsync karena gitbash tidak menggunakan cygwin seperti yang digunakan di cwRsync. gitbash menggunakan msys seperti yang digunakan pacman. Download rsync dari repository pacman . Ekstrak dan salin rsync.exe ke folder /usr/bin/ di dalam gitbash. Composer Installation composer setup untuk Windows dapat didownload di https://getcomposer.org/Composer-Setup.exe . Aplikasi ini akan mengunduh composer versi terbaru dan mengatur PATH sehingga dapat dijalankan hanya dengan mengetik composer di dalam command line atau gitbash. Visual Studio Code Installation Sebagai editor source code disarankan menggunakan Ms.VS Code yang sudah terintegrasi dengan git download dari https://code.visualstudio.com/ . Gunakan yang user installer, agar tanpa hak akses administrator. Aplikasi ini opensource dan gratis dari Microsoft, tersedia di Windows dan Linux. Jalankan dan ikuti proses instalasi di Windows. Modelio Installation Sebagai editor UML untuk use case diagram dan diagram lain yang dibutuhkan untuk proses non teknis development. Modelio dapat diunduh di https://www.modelio.org . Jalankan dan ikuti proses instalasi di Windows. Pencil Installation Sebagai editor UI design untuk proses mockup tampilan aplikasi. Pencil dapat diunduh di https://pencil.evolus.vn . Jalankan dan ikuti proses instalasi di Windows. MkDocs Installation MkDocs adalah script python yang digunakan untuk membuat dokumentasi menggunakan sintak Markdown. Dokumentasi Artemis untuk developer menggunakan MkDocs agar mudah dikembangkan lebih lanjut, karena menggunakan Markdown (lebih sederhana, penulisan lebih cepat dan lebih mudah dipelajari daripada sintak Html). Karena MkDocs adalah script python, maka Anda harus menginstall python terlebih dahulu. Install Python Installation Periksa apakah python sudah terinstall dalam sistem Anda, python --version --version pip --version Kalo belum terinstall, Anda dapat mengunduh python installer dari python.org sesuai sistem operasi Anda (rekomendasi: gunakan versi 64 bit). Jika Anda menginstall di Windows, pastikan centang opsi Add python to PATH (default tidak dicentang). Python memiliki package manager bawaan yang biasanya sudah termasuk dalam instalasi python, yaitu pip. Jika Anda ingin meng-upgrade pip, Anda dapat menjalankan perintah berikut, pip install --upgrade pip Jika pip belum terinstall dalam sistem Anda, download script get-pip.py . Kemudian jalankan python get-pip.py Install MkDocs Install dengan pip, (install juga beberapa plugin MkDocs yang dibutuhkan) pip install mkdocs pip install mkdocs-material pip install mkdocs-pdf-export-plugin NB: Untuk menggunakan pdf-export plugin, Anda perlu install GTK+, jika Anda menggunakan Python 64 bit gunakan installer GTK+ 64 bit . Jika sudah terinstall, Anda dapat memeriksa versi MkDocs, mkdocs --version Cara Menggunakan MkDocs MkDocs digunakan untuk mengedit dokumentasi, maka ini hanya diperlukan saat kita bekerja git repository dari dokumentasi. Hal ini akan dijelaskan pada modul Artemis Documentation Editing . Setting Proxy jika composer/ pip / git problem koneksi Setting Proxy server pada system Windows (PC belum Join domain AD) Setting System Proxy di Windows > Settings > Network & Internet > Proxy, dalam manual proxy, Set use proxy server: ON Address: http://proxy002.hit.local Port: 8080 Proxy Exception: localhost;127.0.0.1;10.*;mail.polytron.co.id;apps.polytron.co.id;*hit*;*hefaistos.app;artemisdev.polytron.co.id;artemis.polytron.co.id Centang pada Dont use proxy server for local (intranet) address. Setting tambahan pada environment variable Windows Dengan shortcut tombol Windows + s masuk ke search windows, ketik \"env\", dan pilih \"Edit Environment Variable for your Account\", Jika belum ada tambahkan variable baru NO_PROXY dengan tombol NEW . isi nilainya dengan: localhost;127.0.0.1;artemis.polytron.co.id;artemisdev.polytron.co.id Jika PC belum Join Domain AD tambahkan: 1. Jika belum ada tambahkan variable baru http_proxy dengan tombol NEW . 2. isi nilainya dengan: http://proxy002.hit.local:8080 3. Jika belum ada tambahkan variable baru https_proxy dengan tombol NEW . 4. isi nilainya dengan: http://proxy002.hit.local","title":"Installation"},{"location":"developerdoc/installation/#installation","text":"Dokumen ini menjelaskan tentang instalasi software yang dibutuhkan dan persiapan lingkungan pengembangan di PC lokal developer. Software yang dibutuhkan instalasi ini dapat diperoleh di lokal server share section folder ESD-Application: M:\\Share\\master\\php-laravel","title":"Installation"},{"location":"developerdoc/installation/#software-requirements-for-artemis-developer-pc","text":"Git RSync Composer XAMPP - Apache2 web server, MariaDB database server, PHP, phpMyAdmin (optional, untuk debuging di PC lokal) Visual Studio Code Modelio Pencil MkDocs (optional, untuk pengembangan dokumentasi)","title":"Software Requirements for Artemis Developer PC"},{"location":"developerdoc/installation/#langkah-instalasi-akan-terdiri-dari","text":"instalasi XAMPP (Apache2 web server, MariaDB database server, PHP, phpMyAdmin) instalasi git for windows instalasi rsync di dalam gitbash instalasi composer instalasi Microsoft Visual Studio Code instalasi Modelio instalasi Pencil instalasi MkDocs","title":"Langkah Instalasi akan terdiri dari,"},{"location":"developerdoc/installation/#xampp-installation","text":"Download XAMPP dari https://www.apachefriends.org/download.html . Jalankan dan ikuti proses instalasi di Windows 10. Setting agar php.exe dapat mudah ditemukan yaitu dengan menambahkannya di PATH environment variable.","title":"XAMPP Installation"},{"location":"developerdoc/installation/#cara-setting-path-php","text":"Buka Windows Start menu search (shortcut: Windows + s ), ketik env, akan muncul Edit Environment Variable for Your Account pilih PATH, pilih tombol Edit pilih NEW pilih Browse, pilih lokasi php.exe di folder instalasi XAMPP. contoh: d:\\xampp\\php . pilih simpan/OK","title":"Cara setting PATH PHP:"},{"location":"developerdoc/installation/#git-installation","text":"Download git for Windows di https://git-scm.com/downloads . Jalankan dan ikuti proses instalasi di Windows. untuk melihat php sudah dapat dijalankan di gitbash, buka gitbash dan ketik, which php php --version versi php setidaknya PHP >= 7.1.3 untuk Laravel 5.8","title":"Git Installation"},{"location":"developerdoc/installation/#rsync-installation","text":"Jangan gunakan cwRsync karena gitbash tidak menggunakan cygwin seperti yang digunakan di cwRsync. gitbash menggunakan msys seperti yang digunakan pacman. Download rsync dari repository pacman . Ekstrak dan salin rsync.exe ke folder /usr/bin/ di dalam gitbash.","title":"RSync Installation"},{"location":"developerdoc/installation/#composer-installation","text":"composer setup untuk Windows dapat didownload di https://getcomposer.org/Composer-Setup.exe . Aplikasi ini akan mengunduh composer versi terbaru dan mengatur PATH sehingga dapat dijalankan hanya dengan mengetik composer di dalam command line atau gitbash.","title":"Composer Installation"},{"location":"developerdoc/installation/#visual-studio-code-installation","text":"Sebagai editor source code disarankan menggunakan Ms.VS Code yang sudah terintegrasi dengan git download dari https://code.visualstudio.com/ . Gunakan yang user installer, agar tanpa hak akses administrator. Aplikasi ini opensource dan gratis dari Microsoft, tersedia di Windows dan Linux. Jalankan dan ikuti proses instalasi di Windows.","title":"Visual Studio Code Installation"},{"location":"developerdoc/installation/#modelio-installation","text":"Sebagai editor UML untuk use case diagram dan diagram lain yang dibutuhkan untuk proses non teknis development. Modelio dapat diunduh di https://www.modelio.org . Jalankan dan ikuti proses instalasi di Windows.","title":"Modelio Installation"},{"location":"developerdoc/installation/#pencil-installation","text":"Sebagai editor UI design untuk proses mockup tampilan aplikasi. Pencil dapat diunduh di https://pencil.evolus.vn . Jalankan dan ikuti proses instalasi di Windows.","title":"Pencil Installation"},{"location":"developerdoc/installation/#mkdocs-installation","text":"MkDocs adalah script python yang digunakan untuk membuat dokumentasi menggunakan sintak Markdown. Dokumentasi Artemis untuk developer menggunakan MkDocs agar mudah dikembangkan lebih lanjut, karena menggunakan Markdown (lebih sederhana, penulisan lebih cepat dan lebih mudah dipelajari daripada sintak Html). Karena MkDocs adalah script python, maka Anda harus menginstall python terlebih dahulu.","title":"MkDocs Installation"},{"location":"developerdoc/installation/#install-python-installation","text":"Periksa apakah python sudah terinstall dalam sistem Anda, python --version --version pip --version Kalo belum terinstall, Anda dapat mengunduh python installer dari python.org sesuai sistem operasi Anda (rekomendasi: gunakan versi 64 bit). Jika Anda menginstall di Windows, pastikan centang opsi Add python to PATH (default tidak dicentang). Python memiliki package manager bawaan yang biasanya sudah termasuk dalam instalasi python, yaitu pip. Jika Anda ingin meng-upgrade pip, Anda dapat menjalankan perintah berikut, pip install --upgrade pip Jika pip belum terinstall dalam sistem Anda, download script get-pip.py . Kemudian jalankan python get-pip.py","title":"Install Python Installation"},{"location":"developerdoc/installation/#install-mkdocs","text":"Install dengan pip, (install juga beberapa plugin MkDocs yang dibutuhkan) pip install mkdocs pip install mkdocs-material pip install mkdocs-pdf-export-plugin NB: Untuk menggunakan pdf-export plugin, Anda perlu install GTK+, jika Anda menggunakan Python 64 bit gunakan installer GTK+ 64 bit . Jika sudah terinstall, Anda dapat memeriksa versi MkDocs, mkdocs --version","title":"Install MkDocs"},{"location":"developerdoc/installation/#cara-menggunakan-mkdocs","text":"MkDocs digunakan untuk mengedit dokumentasi, maka ini hanya diperlukan saat kita bekerja git repository dari dokumentasi. Hal ini akan dijelaskan pada modul Artemis Documentation Editing .","title":"Cara Menggunakan MkDocs"},{"location":"developerdoc/installation/#setting-proxy-jika-composer-pip-git-problem-koneksi","text":"","title":"Setting Proxy jika composer/ pip / git problem koneksi"},{"location":"developerdoc/installation/#setting-proxy-server-pada-system-windows-pc-belum-join-domain-ad","text":"Setting System Proxy di Windows > Settings > Network & Internet > Proxy, dalam manual proxy, Set use proxy server: ON Address: http://proxy002.hit.local Port: 8080 Proxy Exception: localhost;127.0.0.1;10.*;mail.polytron.co.id;apps.polytron.co.id;*hit*;*hefaistos.app;artemisdev.polytron.co.id;artemis.polytron.co.id Centang pada Dont use proxy server for local (intranet) address.","title":"Setting Proxy server pada system Windows (PC belum Join domain AD)"},{"location":"developerdoc/installation/#setting-tambahan-pada-environment-variable-windows","text":"Dengan shortcut tombol Windows + s masuk ke search windows, ketik \"env\", dan pilih \"Edit Environment Variable for your Account\", Jika belum ada tambahkan variable baru NO_PROXY dengan tombol NEW . isi nilainya dengan: localhost;127.0.0.1;artemis.polytron.co.id;artemisdev.polytron.co.id Jika PC belum Join Domain AD tambahkan: 1. Jika belum ada tambahkan variable baru http_proxy dengan tombol NEW . 2. isi nilainya dengan: http://proxy002.hit.local:8080 3. Jika belum ada tambahkan variable baru https_proxy dengan tombol NEW . 4. isi nilainya dengan: http://proxy002.hit.local","title":"Setting tambahan pada environment variable Windows"},{"location":"developerdoc/laravel_basic/","text":"Laravel Basic Dokumentasi tentang Laravel secara lengakp ada di https://laravel.com System requirements PHP >= 7.1.3 BCMath PHP Extension Ctype PHP Extension JSON PHP Extension Mbstring PHP Extension OpenSSL PHP Extension PDO PHP Extension Tokenizer PHP Extension XML PHP Extension Cara Install Laravel Laravel menggunakan composer untuk mengatur dependensi library PHP yang digunakan. Install via Laravel Installer Pertama unduh installer dengan composer, $ composer global require laravel/installer Kemudian jalankan laravel installer $ laravel new projectname akan terbuat folder projectname di lokasi folder kerja Anda sekarang. Install via Composer Create Project $ composer create-project --prefer-dist laravel/laravel projectname Local Development Server Jika PHP terinstall secara lokal di PC Anda, Anda dapat menggunakan perintah artisan serve untuk menjalankan development server pada http://localhost:8000 $ php artisan serve ATAU $ ./artisan serve Struktur folder Laravel Secara default struktur folder project Laravel terdiri dari, app bootstrap config database public resources routes storage tests vendor Folder app Berisi class-class aplikasi yang kita buat, di dalamnya dapat terdiri dari model eloquent, controller, middleware, console command, provider dan lain-lain. Folder bootstrap Berisi file yang dijalankan Laravel di awal setiap eksekusi. Folder config Berisi semua konfigurasi Laravel. Folder database Berisi database migration dan database seed. Folder public Berisi folder dan file yang dapat diakses melalui protocol http/https. pastikan folder ini read-only. Folder resources Berisi file-file resource, seperti view, css asset dan javascript asset. Folder routes Berisi route yang mengatur maping URL ke controller atau proses yang dijalankan berdasarkan http request. Folder storage Berisi file-file yang disimpan saat runtime, misal untuk menampung file yang diunggah oleh pengguna. Folder tests Berisi script untuk melakukan testing dari class, controller atau route yang telah dibuat. Folder vendor Berisi file-file dependensi PHP yang dibutuhkan untuk project ini. Konfigurasi awal Folder Public Setelah meng-install Laravel, Anda harus mengatur di webserver Anda agar URL project Anda untuk menunjuk ke folder public. file index.php di folder public ini lah yang akan diakses setiap HTTP request menuju aplikasi Anda. $ chmod -R a+rx public $ chmod -R go-w public File Konfigurasi Semua file konfigurasi disimpan dalam folder config . Setiap opsi sudah terdokumentasi dalam masing-masing file. Biasanya file konfigurasi ini merujuk nilai variable-nya ke isi dari file .env , agar nilai konfigurasi dapat dipisahkan dari repository git source code. Hak akses Folder Anda perlu mengatur beberapa hak akses folder. Folder di dalam storage dan bootstrap/cache harus dapat ditulisi oleh user web server (misal user: apache2 atau www-data) atau Laravel tidak akan dapat berjalan. $ chmod -R a+rwx bootstrap/cache $ chmod -R a+rwx storage Application Key Aplikasi Laravel harus mempunyai application key yang disimpan dalam file .env , variable ini berisi random string yang umumnya sepanjang 32 karakter, yang berfungsi sebagai salt untuk semua proses enkripsi pada aplikasi Laravel. Jika Anda tidak mendefinisikan application key , maka session dan data yang terenkripsi pada aplikasi Laravel Anda tidak aman. Jika Anda meng-install Laravel dengan composer atau Laravel Installer, key ini sudah diset dengan sendirinya dengan perintah php artisan key:generate . Anda juga dapat menjalankan perintah artisan ini untuk mengganti application-key aplikasi Anda. Catatan Penting: Jika application-key diganti, maka data-data yang terenkripsi sebelumnya pada aplikasi Anda, misal session, password, dan data sensitif lainnya akan menjadi tidak terbaca lagi. maka hindari mengganti application-key pada aplikasi yang sudah go-live di server production Anda. Konfigurasi Tambahan Selain konfigurasi di atas, Laravel hampir tidak memerlukan konfigurasi lain secara bawaan, tetapi Anda dapat mengeksplorasi sendiri file-file konfigurasi di folder config , terutama config/app.php yang berisi beberapa setting misal timezone, dan locale yang mungkin butuh disesuaikan dengan aplikasi Anda. Konfigurasi Web Server Laravel menyertakan file public/.htaccess yang digunakan untuk mempercantik URL yang Laravel gunakan (tanpa ada tanda tanya untuk memisahkan URL aplikasi dengan parameter, mengarahkan semua request ke satu script pemrosesan yaitu public/index.php ), maka Laravel membutuhkan extension/module web server mod_rewrite . Pastikan untuk mengaktifkan modul mod_rewrite di web server kita, agar web server dapat menjalankan setting dalam file .htaccess . Contoh: URL request dari client browser https://project-anda.com/article/belajar-laravel-itu-asyik Contoh: URL yang dituju setelah diterjemahkan oleh module rewrite https://project-anda.com/index.php?sub=article&doc=belajar%20laravel%20itu-asyik URL di atas sekedar contoh, bukan penerjemahan sebenarnya dari URL rewrite Laravel Jika file .htaccess yang disertakan tidak berfungsi dengan baik di instalasi Apache Anda, gunakan alternatif berikut ini, Options +FollowSymLinks -Indexes RewriteEngine On RewriteCond %{HTTP:Authorization} . RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}] RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^ index.php [L] Menambahkan Library Dependensi dengan Composer Dengan Composer kita lebih mudah untuk menambahkan library PHP jika kita membutuhkannya. Composer akan mengunduh library tersebut dari website packagist beserta dependensi dari library tersebut secara otomatis. Versi library tersebut dapat ditulis untuk memastikan versi yang kita inginkan, tetapi juga dapat dikosongi agar composer mengambil versi terkini yang sesuai dengan kebutuhan sistem kita. Perintah berikut digunakan untuk menambah library baru ke project Laravel kita, library ini akan ditempatkan di folder vendor, composer require vendor-name/lirary-name version Selanjutnya kita perlu menambahkan facade alias dan mendaftarkan package service provider di config/app.php . untuk Laravel 5.8 pendaftaran facade alias dan package service provider tidak diperlukan karena sudah otomatis terdaftar dengan package auto discovery. Facade alias adalah nama alias dari suatu facade yang tujuannya untuk mempersingkat penulisan facade. Facade menyediakan interface static ke class-class yang tersedia dalam service container aplikasi. Contoh: Menambah library export/import file Excel Untuk menambahkan library untuk bekerja dengan file excel, composer require maatwebsite/excel Maatwebsite\\Excel\\ExcelServiceProvider akan terdaftar secara otomatis, tetapi Anda juga bisa mendaftarkannya sendiri dengan menambahkan ServiceProvider ke dalam config/app.php 'providers' => [ /* * Package Service Providers... */ Maatwebsite\\Excel\\ExcelServiceProvider::class, ] Excel facade juga dikenali secara otomatis, jika Anda ingin menambahkan sendiri, tambahkan facade ke dalam config/app.php 'aliases' => [ ... 'Excel' => Maatwebsite\\Excel\\Facades\\Excel::class, ] Untuk mengkonfigurasikan lebih lanjut ExcelServiceProvider , Anda dapat mem-publish file konfigurasi, Jalankan perintah $ php artisan vendor:publish --provider=\"Maatwebsite\\Excel\\ExcelServiceProvider\" Perintah ini akan membuat file konfigurasi dengan nama config/excel.php .","title":"Laravel Basic"},{"location":"developerdoc/laravel_basic/#laravel-basic","text":"Dokumentasi tentang Laravel secara lengakp ada di https://laravel.com","title":"Laravel Basic"},{"location":"developerdoc/laravel_basic/#system-requirements","text":"PHP >= 7.1.3 BCMath PHP Extension Ctype PHP Extension JSON PHP Extension Mbstring PHP Extension OpenSSL PHP Extension PDO PHP Extension Tokenizer PHP Extension XML PHP Extension","title":"System requirements"},{"location":"developerdoc/laravel_basic/#cara-install-laravel","text":"Laravel menggunakan composer untuk mengatur dependensi library PHP yang digunakan.","title":"Cara Install Laravel"},{"location":"developerdoc/laravel_basic/#install-via-laravel-installer","text":"Pertama unduh installer dengan composer, $ composer global require laravel/installer Kemudian jalankan laravel installer $ laravel new projectname akan terbuat folder projectname di lokasi folder kerja Anda sekarang.","title":"Install via Laravel Installer"},{"location":"developerdoc/laravel_basic/#install-via-composer-create-project","text":"$ composer create-project --prefer-dist laravel/laravel projectname","title":"Install via Composer Create Project"},{"location":"developerdoc/laravel_basic/#local-development-server","text":"Jika PHP terinstall secara lokal di PC Anda, Anda dapat menggunakan perintah artisan serve untuk menjalankan development server pada http://localhost:8000 $ php artisan serve ATAU $ ./artisan serve","title":"Local Development Server"},{"location":"developerdoc/laravel_basic/#struktur-folder-laravel","text":"Secara default struktur folder project Laravel terdiri dari, app bootstrap config database public resources routes storage tests vendor","title":"Struktur folder Laravel"},{"location":"developerdoc/laravel_basic/#folder-app","text":"Berisi class-class aplikasi yang kita buat, di dalamnya dapat terdiri dari model eloquent, controller, middleware, console command, provider dan lain-lain.","title":"Folder app"},{"location":"developerdoc/laravel_basic/#folder-bootstrap","text":"Berisi file yang dijalankan Laravel di awal setiap eksekusi.","title":"Folder bootstrap"},{"location":"developerdoc/laravel_basic/#folder-config","text":"Berisi semua konfigurasi Laravel.","title":"Folder config"},{"location":"developerdoc/laravel_basic/#folder-database","text":"Berisi database migration dan database seed.","title":"Folder database"},{"location":"developerdoc/laravel_basic/#folder-public","text":"Berisi folder dan file yang dapat diakses melalui protocol http/https. pastikan folder ini read-only.","title":"Folder public"},{"location":"developerdoc/laravel_basic/#folder-resources","text":"Berisi file-file resource, seperti view, css asset dan javascript asset.","title":"Folder resources"},{"location":"developerdoc/laravel_basic/#folder-routes","text":"Berisi route yang mengatur maping URL ke controller atau proses yang dijalankan berdasarkan http request.","title":"Folder routes"},{"location":"developerdoc/laravel_basic/#folder-storage","text":"Berisi file-file yang disimpan saat runtime, misal untuk menampung file yang diunggah oleh pengguna.","title":"Folder storage"},{"location":"developerdoc/laravel_basic/#folder-tests","text":"Berisi script untuk melakukan testing dari class, controller atau route yang telah dibuat.","title":"Folder tests"},{"location":"developerdoc/laravel_basic/#folder-vendor","text":"Berisi file-file dependensi PHP yang dibutuhkan untuk project ini.","title":"Folder vendor"},{"location":"developerdoc/laravel_basic/#konfigurasi-awal","text":"","title":"Konfigurasi awal"},{"location":"developerdoc/laravel_basic/#folder-public_1","text":"Setelah meng-install Laravel, Anda harus mengatur di webserver Anda agar URL project Anda untuk menunjuk ke folder public. file index.php di folder public ini lah yang akan diakses setiap HTTP request menuju aplikasi Anda. $ chmod -R a+rx public $ chmod -R go-w public","title":"Folder Public"},{"location":"developerdoc/laravel_basic/#file-konfigurasi","text":"Semua file konfigurasi disimpan dalam folder config . Setiap opsi sudah terdokumentasi dalam masing-masing file. Biasanya file konfigurasi ini merujuk nilai variable-nya ke isi dari file .env , agar nilai konfigurasi dapat dipisahkan dari repository git source code.","title":"File Konfigurasi"},{"location":"developerdoc/laravel_basic/#hak-akses-folder","text":"Anda perlu mengatur beberapa hak akses folder. Folder di dalam storage dan bootstrap/cache harus dapat ditulisi oleh user web server (misal user: apache2 atau www-data) atau Laravel tidak akan dapat berjalan. $ chmod -R a+rwx bootstrap/cache $ chmod -R a+rwx storage","title":"Hak akses Folder"},{"location":"developerdoc/laravel_basic/#application-key","text":"Aplikasi Laravel harus mempunyai application key yang disimpan dalam file .env , variable ini berisi random string yang umumnya sepanjang 32 karakter, yang berfungsi sebagai salt untuk semua proses enkripsi pada aplikasi Laravel. Jika Anda tidak mendefinisikan application key , maka session dan data yang terenkripsi pada aplikasi Laravel Anda tidak aman. Jika Anda meng-install Laravel dengan composer atau Laravel Installer, key ini sudah diset dengan sendirinya dengan perintah php artisan key:generate . Anda juga dapat menjalankan perintah artisan ini untuk mengganti application-key aplikasi Anda. Catatan Penting: Jika application-key diganti, maka data-data yang terenkripsi sebelumnya pada aplikasi Anda, misal session, password, dan data sensitif lainnya akan menjadi tidak terbaca lagi. maka hindari mengganti application-key pada aplikasi yang sudah go-live di server production Anda.","title":"Application Key"},{"location":"developerdoc/laravel_basic/#konfigurasi-tambahan","text":"Selain konfigurasi di atas, Laravel hampir tidak memerlukan konfigurasi lain secara bawaan, tetapi Anda dapat mengeksplorasi sendiri file-file konfigurasi di folder config , terutama config/app.php yang berisi beberapa setting misal timezone, dan locale yang mungkin butuh disesuaikan dengan aplikasi Anda.","title":"Konfigurasi Tambahan"},{"location":"developerdoc/laravel_basic/#konfigurasi-web-server","text":"Laravel menyertakan file public/.htaccess yang digunakan untuk mempercantik URL yang Laravel gunakan (tanpa ada tanda tanya untuk memisahkan URL aplikasi dengan parameter, mengarahkan semua request ke satu script pemrosesan yaitu public/index.php ), maka Laravel membutuhkan extension/module web server mod_rewrite . Pastikan untuk mengaktifkan modul mod_rewrite di web server kita, agar web server dapat menjalankan setting dalam file .htaccess . Contoh: URL request dari client browser https://project-anda.com/article/belajar-laravel-itu-asyik Contoh: URL yang dituju setelah diterjemahkan oleh module rewrite https://project-anda.com/index.php?sub=article&doc=belajar%20laravel%20itu-asyik URL di atas sekedar contoh, bukan penerjemahan sebenarnya dari URL rewrite Laravel Jika file .htaccess yang disertakan tidak berfungsi dengan baik di instalasi Apache Anda, gunakan alternatif berikut ini, Options +FollowSymLinks -Indexes RewriteEngine On RewriteCond %{HTTP:Authorization} . RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}] RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^ index.php [L]","title":"Konfigurasi Web Server"},{"location":"developerdoc/laravel_basic/#menambahkan-library-dependensi-dengan-composer","text":"Dengan Composer kita lebih mudah untuk menambahkan library PHP jika kita membutuhkannya. Composer akan mengunduh library tersebut dari website packagist beserta dependensi dari library tersebut secara otomatis. Versi library tersebut dapat ditulis untuk memastikan versi yang kita inginkan, tetapi juga dapat dikosongi agar composer mengambil versi terkini yang sesuai dengan kebutuhan sistem kita. Perintah berikut digunakan untuk menambah library baru ke project Laravel kita, library ini akan ditempatkan di folder vendor, composer require vendor-name/lirary-name version Selanjutnya kita perlu menambahkan facade alias dan mendaftarkan package service provider di config/app.php . untuk Laravel 5.8 pendaftaran facade alias dan package service provider tidak diperlukan karena sudah otomatis terdaftar dengan package auto discovery. Facade alias adalah nama alias dari suatu facade yang tujuannya untuk mempersingkat penulisan facade. Facade menyediakan interface static ke class-class yang tersedia dalam service container aplikasi.","title":"Menambahkan Library Dependensi dengan Composer"},{"location":"developerdoc/laravel_basic/#contoh-menambah-library-exportimport-file-excel","text":"Untuk menambahkan library untuk bekerja dengan file excel, composer require maatwebsite/excel Maatwebsite\\Excel\\ExcelServiceProvider akan terdaftar secara otomatis, tetapi Anda juga bisa mendaftarkannya sendiri dengan menambahkan ServiceProvider ke dalam config/app.php 'providers' => [ /* * Package Service Providers... */ Maatwebsite\\Excel\\ExcelServiceProvider::class, ] Excel facade juga dikenali secara otomatis, jika Anda ingin menambahkan sendiri, tambahkan facade ke dalam config/app.php 'aliases' => [ ... 'Excel' => Maatwebsite\\Excel\\Facades\\Excel::class, ] Untuk mengkonfigurasikan lebih lanjut ExcelServiceProvider , Anda dapat mem-publish file konfigurasi, Jalankan perintah $ php artisan vendor:publish --provider=\"Maatwebsite\\Excel\\ExcelServiceProvider\" Perintah ini akan membuat file konfigurasi dengan nama config/excel.php .","title":"Contoh: Menambah library export/import file Excel"},{"location":"developerdoc/laravel_blade/","text":"Laravel Blade Templating Blade is the simple, yet powerful templating engine provided with Laravel. Unlike other popular PHP templating engines, Blade does not restrict you from using plain PHP code in your views. In fact, all Blade views are compiled into plain PHP code and cached until they are modified, meaning Blade adds essentially zero overhead to your application. Blade view files use the .blade.php file extension and are typically stored in the resources/views directory. Template Inheritance Defining A Layout Two of the primary benefits of using Blade are template inheritance and sections. To get started, let's take a look at a simple example. First, we will examine a \"master\" page layout. Since most web applications maintain the same general layout across various pages, it's convenient to define this layout as a single Blade view: <!-- Stored in resources/views/layouts/app.blade.php --> <html> <head> <title>App Name - @yield('title')</title> </head> <body> @section('sidebar') This is the master sidebar. @show <div class=\"container\"> @yield('content') </div> </body> </html> As you can see, this file contains typical HTML mark-up. However, take note of the @section and @yield directives. The @section directive, as the name implies, defines a section of content, while the @yield directive is used to display the contents of a given section. Now that we have defined a layout for our application, let's define a child page that inherits the layout. Extending A Layout When defining a child view, use the Blade @extends directive to specify which layout the child view should \"inherit\". Views which extend a Blade layout may inject content into the layout's sections using @section directives. Remember, as seen in the example above, the contents of these sections will be displayed in the layout using @yield: <!-- Stored in resources/views/child.blade.php --> @extends('layouts.app') @section('title', 'Page Title') @section('sidebar') @parent <p>This is appended to the master sidebar.</p> @endsection @section('content') <p>This is my body content.</p> @endsection In this example, the sidebar section is utilizing the @parent directive to append (rather than overwriting) content to the layout's sidebar. The @parent directive will be replaced by the content of the layout when the view is rendered. Contrary to the previous example, this sidebar section ends with @endsection instead of @show. The @endsection directive will only define a section while @show will define and immediately yield the section. The @yield directive also accepts a default value as its second parameter. This value will be rendered if the section being yielded is undefined: @yield('content', View::make('view.name')) Blade views may be returned from routes using the global view helper: Route::get('blade', function () { return view('child'); }); Components & Slots Components and slots provide similar benefits to sections and layouts; however, some may find the mental model of components and slots easier to understand. First, let's imagine a reusable \"alert\" component we would like to reuse throughout our application: <!-- /resources/views/alert.blade.php --> <div class=\"alert alert-danger\"> {{ $slot }} </div> The {{ $slot }} variable will contain the content we wish to inject into the component. Now, to construct this component, we can use the @component Blade directive: @component('alert') <strong>Whoops!</strong> Something went wrong! @endcomponent To instruct Laravel to load the first view that exists from a given array of possible views for the component, you may use the componentFirst directive: @componentFirst(['custom.alert', 'alert']) <strong>Whoops!</strong> Something went wrong! @endcomponent Sometimes it is helpful to define multiple slots for a component. Let's modify our alert component to allow for the injection of a \"title\". Named slots may be displayed by \"echoing\" the variable that matches their name: <!-- /resources/views/alert.blade.php --> <div class=\"alert alert-danger\"> <div class=\"alert-title\">{{ $title }}</div> {{ $slot }} </div> Now, we can inject content into the named slot using the @slot directive. Any content not within a @slot directive will be passed to the component in the $slot variable: @component('alert') @slot('title') Forbidden @endslot You are not allowed to access this resource! @endcomponent Passing Additional Data To Components Sometimes you may need to pass additional data to a component. For this reason, you can pass an array of data as the second argument to the @component directive. All of the data will be made available to the component template as variables: @component('alert', ['foo' => 'bar']) ... @endcomponent Aliasing Components If your Blade components are stored in a sub-directory, you may wish to alias them for easier access. For example, imagine a Blade component that is stored at resources/views/components/alert.blade.php. You may use the component method to alias the component from components.alert to alert. Typically, this should be done in the boot method of your AppServiceProvider: use Illuminate\\Support\\Facades\\Blade; Blade::component('components.alert', 'alert'); Once the component has been aliased, you may render it using a directive: @alert(['type' => 'danger']) You are not allowed to access this resource! @endalert You may omit the component parameters if it has no additional slots: @alert You are not allowed to access this resource! @endalert Displaying Data You may display data passed to your Blade views by wrapping the variable in curly braces. For example, given the following route: Route::get('greeting', function () { return view('welcome', ['name' => 'Samantha']); }); You may display the contents of the name variable like so: Hello, {{ $name }}. Blade {{ }} statements are automatically sent through PHP's htmlspecialchars function to prevent XSS attacks. You are not limited to displaying the contents of the variables passed to the view. You may also echo the results of any PHP function. In fact, you can put any PHP code you wish inside of a Blade echo statement: The current UNIX timestamp is {{ time() }}. Displaying Unescaped Data By default, Blade {{ }} statements are automatically sent through PHP's htmlspecialchars function to prevent XSS attacks. If you do not want your data to be escaped, you may use the following syntax: Hello, {!! $name !!}. Be very careful when echoing content that is supplied by users of your application. Always use the escaped, double curly brace syntax to prevent XSS attacks when displaying user supplied data. Rendering JSON Sometimes you may pass an array to your view with the intention of rendering it as JSON in order to initialize a JavaScript variable. For example: <script> var app = <?php echo json_encode($array); ?>; </script> However, instead of manually calling json_encode, you may use the @json Blade directive. The @json directive accepts the same arguments as PHP's json_encode function: <script> var app = @json($array); var app = @json($array, JSON_PRETTY_PRINT); </script> You should only use the @json directive to render existing variables as JSON. The Blade templating is based on regular expressions and attempts to pass a complex expression to the directive may cause unexpected failures. The @json directive is also useful for seeding Vue components or data-* attributes: <example-component :some-prop='@json($array)'></example-component> Using @json in element attributes requires that it be surrounded by single quotes. HTML Entity Encoding By default, Blade (and the Laravel e helper) will double encode HTML entities. If you would like to disable double encoding, call the Blade::withoutDoubleEncoding method from the boot method of your AppServiceProvider: <?php namespace App\\Providers; use Illuminate\\Support\\Facades\\Blade; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Bootstrap any application services. * * @return void */ public function boot() { Blade::withoutDoubleEncoding(); } } Blade & JavaScript Frameworks Since many JavaScript frameworks also use \"curly\" braces to indicate a given expression should be displayed in the browser, you may use the @ symbol to inform the Blade rendering engine an expression should remain untouched. For example: <h1>Laravel</h1> Hello, @{{ name }}. In this example, the @ symbol will be removed by Blade; however, {{ name }} expression will remain untouched by the Blade engine, allowing it to instead be rendered by your JavaScript framework. The @verbatim Directive If you are displaying JavaScript variables in a large portion of your template, you may wrap the HTML in the @verbatim directive so that you do not have to prefix each Blade echo statement with an @ symbol: @verbatim <div class=\"container\"> Hello, {{ name }}. </div> @endverbatim Control Structures In addition to template inheritance and displaying data, Blade also provides convenient shortcuts for common PHP control structures, such as conditional statements and loops. These shortcuts provide a very clean, terse way of working with PHP control structures, while also remaining familiar to their PHP counterparts. If Statements You may construct if statements using the @if, @elseif, @else, and @endif directives. These directives function identically to their PHP counterparts: @if (count($records) === 1) I have one record! @elseif (count($records) > 1) I have multiple records! @else I don't have any records! @endif For convenience, Blade also provides an @unless directive: @unless (Auth::check()) You are not signed in. @endunless In addition to the conditional directives already discussed, the @isset and @empty directives may be used as convenient shortcuts for their respective PHP functions: @isset($records) // $records is defined and is not null... @endisset @empty($records) // $records is \"empty\"... @endempty Authentication Directives The @auth and @guest directives may be used to quickly determine if the current user is authenticated or is a guest: @auth // The user is authenticated... @endauth @guest // The user is not authenticated... @endguest If needed, you may specify the authentication guard that should be checked when using the @auth and @guest directives: @auth('admin') // The user is authenticated... @endauth @guest('admin') // The user is not authenticated... @endguest Section Directives You may check if a section has content using the @hasSection directive: @hasSection('navigation') <div class=\"pull-right\"> @yield('navigation') </div> <div class=\"clearfix\"></div> @endif Switch Statements Switch statements can be constructed using the @switch, @case, @break, @default and @endswitch directives: @switch($i) @case(1) First case... @break @case(2) Second case... @break @default Default case... @endswitch Loops In addition to conditional statements, Blade provides simple directives for working with PHP's loop structures. Again, each of these directives functions identically to their PHP counterparts: @for ($i = 0; $i < 10; $i++) The current value is {{ $i }} @endfor @foreach ($users as $user) <p>This is user {{ $user->id }}</p> @endforeach @forelse ($users as $user) <li>{{ $user->name }}</li> @empty <p>No users</p> @endforelse @while (true) <p>I'm looping forever.</p> @endwhile When looping, you may use the loop variable to gain valuable information about the loop, such as whether you are in the first or last iteration through the loop. When using loops you may also end the loop or skip the current iteration: @foreach ($users as $user) @if ($user->type == 1) @continue @endif <li>{{ $user->name }}</li> @if ($user->number == 5) @break @endif @endforeach You may also include the condition with the directive declaration in one line: @foreach ($users as $user) @continue($user->type == 1) <li>{{ $user->name }}</li> @break($user->number == 5) @endforeach The Loop Variable When looping, a $loop variable will be available inside of your loop. This variable provides access to some useful bits of information such as the current loop index and whether this is the first or last iteration through the loop: @foreach ($users as $user) @if ($loop->first) This is the first iteration. @endif @if ($loop->last) This is the last iteration. @endif <p>This is user {{ $user->id }}</p> @endforeach If you are in a nested loop, you may access the parent loop's $loop variable via the parent property: @foreach ($users as $user) @foreach ($user->posts as $post) @if ($loop->parent->first) This is first iteration of the parent loop. @endif @endforeach @endforeach The $loop variable also contains a variety of other useful properties: | Property | Description | | --- | --- | |$loop->index | The index of the current loop iteration (starts at 0). | |$loop->iteration | The current loop iteration (starts at 1). | |$loop->remaining | The iterations remaining in the loop. | |$loop->count | The total number of items in the array being iterated. | |$loop->first | Whether this is the first iteration through the loop. | |$loop->last | Whether this is the last iteration through the loop. | |$loop->even | Whether this is an even iteration through the loop. | |$loop->odd | Whether this is an odd iteration through the loop. | |$loop->depth | The nesting level of the current loop. | |$loop->parent | When in a nested loop, the parent's loop variable. | Comments Blade also allows you to define comments in your views. However, unlike HTML comments, Blade comments are not included in the HTML returned by your application: {{-- This comment will not be present in the rendered HTML --}} PHP In some situations, it's useful to embed PHP code into your views. You can use the Blade @php directive to execute a block of plain PHP within your template: @php // @endphp While Blade provides this feature, using it frequently may be a signal that you have too much logic embedded within your template. Forms CSRF Field Anytime you define an HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field: <form method=\"POST\" action=\"/profile\"> @csrf ... </form> Method Field Since HTML forms can't make PUT, PATCH, or DELETE requests, you will need to add a hidden _method field to spoof these HTTP verbs. The @method Blade directive can create this field for you: <form action=\"/foo/bar\" method=\"POST\"> @method('PUT') ... </form> Validation Errors The @error directive may be used to quickly check if validation error messages exist for a given attribute. Within an @error directive, you may echo the $message variable to display the error message: <!-- /resources/views/post/create.blade.php --> <label for=\"title\">Post Title</label> <input id=\"title\" type=\"text\" class=\"@error('title') is-invalid @enderror\"> @error('title') <div class=\"alert alert-danger\">{{ $message }}</div> @enderror Including Sub-Views Blade's @include directive allows you to include a Blade view from within another view. All variables that are available to the parent view will be made available to the included view: <div> @include('shared.errors') <form> <!-- Form Contents --> </form> </div> Even though the included view will inherit all data available in the parent view, you may also pass an array of extra data to the included view: @include('view.name', ['some' => 'data']) If you attempt to @include a view which does not exist, Laravel will throw an error. If you would like to include a view that may or may not be present, you should use the @includeIf directive: @includeIf('view.name', ['some' => 'data']) If you would like to @include a view depending on a given boolean condition, you may use the @includeWhen directive: @includeWhen($boolean, 'view.name', ['some' => 'data']) To include the first view that exists from a given array of views, you may use the includeFirst directive: @includeFirst(['custom.admin', 'admin'], ['some' => 'data']) You should avoid using the DIR and FILE constants in your Blade views, since they will refer to the location of the cached, compiled view. Aliasing Includes If your Blade includes are stored in a sub-directory, you may wish to alias them for easier access. For example, imagine a Blade include that is stored at resources/views/includes/input.blade.php with the following content: <input type=\"{{ $type ?? 'text' }}\"> You may use the include method to alias the include from includes.input to input. Typically, this should be done in the boot method of your AppServiceProvider: use Illuminate\\Support\\Facades\\Blade; Blade::include('includes.input', 'input'); Once the include has been aliased, you may render it using the alias name as the Blade directive: @input(['type' => 'email']) Rendering Views For Collections You may combine loops and includes into one line with Blade's @each directive: @each('view.name', $jobs, 'job') The first argument is the view partial to render for each element in the array or collection. The second argument is the array or collection you wish to iterate over, while the third argument is the variable name that will be assigned to the current iteration within the view. So, for example, if you are iterating over an array of jobs, typically you will want to access each job as a job variable within your view partial. The key for the current iteration will be available as the key variable within your view partial. You may also pass a fourth argument to the @each directive. This argument determines the view that will be rendered if the given array is empty. @each('view.name', $jobs, 'job', 'view.empty') Views rendered via @each do not inherit the variables from the parent view. If the child view requires these variables, you should use @foreach and @include instead. Stacks Blade allows you to push to named stacks which can be rendered somewhere else in another view or layout. This can be particularly useful for specifying any JavaScript libraries required by your child views: @push('scripts') <script src=\"/example.js\"></script> @endpush You may push to a stack as many times as needed. To render the complete stack contents, pass the name of the stack to the @stack directive: <head> <!-- Head Contents --> @stack('scripts') </head> If you would like to prepend content onto the beginning of a stack, you should use the @prepend directive: @push('scripts') This will be second... @endpush // Later... @prepend('scripts') This will be first... @endprepend Service Injection The @inject directive may be used to retrieve a service from the Laravel service container. The first argument passed to @inject is the name of the variable the service will be placed into, while the second argument is the class or interface name of the service you wish to resolve: @inject('metrics', 'App\\Services\\MetricsService') <div> Monthly Revenue: {{ $metrics->monthlyRevenue() }}. </div> Extending Blade Blade allows you to define your own custom directives using the directive method. When the Blade compiler encounters the custom directive, it will call the provided callback with the expression that the directive contains. The following example creates a @datetime($var) directive which formats a given $var, which should be an instance of DateTime: <?php namespace App\\Providers; use Illuminate\\Support\\Facades\\Blade; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Register bindings in the container. * * @return void */ public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { Blade::directive('datetime', function ($expression) { return \"<?php echo ($expression)->format('m/d/Y H:i'); ?>\"; }); } } As you can see, we will chain the format method onto whatever expression is passed into the directive. So, in this example, the final PHP generated by this directive will be: <?php echo ($var)->format('m/d/Y H:i'); ?> After updating the logic of a Blade directive, you will need to delete all of the cached Blade views. The cached Blade views may be removed using the view:clear Artisan command. Custom If Statements Programming a custom directive is sometimes more complex than necessary when defining simple, custom conditional statements. For that reason, Blade provides a Blade::if method which allows you to quickly define custom conditional directives using Closures. For example, let's define a custom conditional that checks the current application environment. We may do this in the boot method of our AppServiceProvider: use Illuminate\\Support\\Facades\\Blade; /** * Bootstrap any application services. * * @return void */ public function boot() { Blade::if('env', function ($environment) { return app()->environment($environment); }); } Once the custom conditional has been defined, we can easily use it on our templates: @env('local') // The application is in the local environment... @elseenv('testing') // The application is in the testing environment... @else // The application is not in the local or testing environment... @endenv Localization Introduction Laravel's localization features provide a convenient way to retrieve strings in various languages, allowing you to easily support multiple languages within your application. Language strings are stored in files within the resources/lang directory. Within this directory there should be a subdirectory for each language supported by the application: /resources /lang /en messages.php /es messages.php All language files return an array of keyed strings. For example: <?php return [ 'welcome' => 'Welcome to our application' ]; Configuring The Locale The default language for your application is stored in the config/app.php configuration file. You may modify this value to suit the needs of your application. You may also change the active language at runtime using the setLocale method on the App facade: Route::get('welcome/{locale}', function ($locale) { App::setLocale($locale); // }); You may configure a \"fallback language\", which will be used when the active language does not contain a given translation string. Like the default language, the fallback language is also configured in the config/app.php configuration file: 'fallback_locale' => 'en', Determining The Current Locale You may use the getLocale and isLocale methods on the App facade to determine the current locale or check if the locale is a given value: $locale = App::getLocale(); if (App::isLocale('en')) { // } Defining Translation Strings Using Short Keys Typically, translation strings are stored in files within the resources/lang directory. Within this directory there should be a subdirectory for each language supported by the application: /resources /lang /en messages.php /es messages.php All language files return an array of keyed strings. For example: <?php // resources/lang/en/messages.php return [ 'welcome' => 'Welcome to our application' ]; Using Translation Strings As Keys For applications with heavy translation requirements, defining every string with a \"short key\" can become quickly confusing when referencing them in your views. For this reason, Laravel also provides support for defining translation strings using the \"default\" translation of the string as the key. Translation files that use translation strings as keys are stored as JSON files in the resources/lang directory. For example, if your application has a Spanish translation, you should create a resources/lang/es.json file: { \"I love programming.\": \"Me encanta programar.\" } Retrieving Translation Strings You may retrieve lines from language files using the helper function. The method accepts the file and key of the translation string as its first argument. For example, let's retrieve the welcome translation string from the resources/lang/messages.php language file: echo __('messages.welcome'); echo __('I love programming.'); If you are using the Blade templating engine, you may use the {{ }} syntax to echo the translation string or use the @lang directive: {{ __('messages.welcome') }} @lang('messages.welcome') If the specified translation string does not exist, the function will return the translation string key. So, using the example above, the function would return messages.welcome if the translation string does not exist. The @lang directive does not escape any output. You are fully responsible for escaping your own output when using this directive. Replacing Parameters In Translation Strings If you wish, you may define placeholders in your translation strings. All placeholders are prefixed with a :. For example, you may define a welcome message with a placeholder name: 'welcome' => 'Welcome, :name', To replace the placeholders when retrieving a translation string, pass an array of replacements as the second argument to the __ function: echo __('messages.welcome', ['name' => 'dayle']); If your placeholder contains all capital letters, or only has its first letter capitalized, the translated value will be capitalized accordingly: 'welcome' => 'Welcome, :NAME', // Welcome, DAYLE 'goodbye' => 'Goodbye, :Name', // Goodbye, Dayle Pluralization Pluralization is a complex problem, as different languages have a variety of complex rules for pluralization. By using a \"pipe\" character, you may distinguish singular and plural forms of a string: 'apples' => 'There is one apple|There are many apples', You may even create more complex pluralization rules which specify translation strings for multiple number ranges: 'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many', After defining a translation string that has pluralization options, you may use the trans_choice function to retrieve the line for a given \"count\". In this example, since the count is greater than one, the plural form of the translation string is returned: echo trans_choice('messages.apples', 10); You may also define placeholder attributes in pluralization strings. These placeholders may be replaced by passing an array as the third argument to the trans_choice function: 'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago', echo trans_choice('time.minutes_ago', 5, ['value' => 5]); If you would like to display the integer value that was passed to the trans_choice function, you may use the :count placeholder: 'apples' => '{0} There are none|{1} There is one|[2,*] There are :count', Overriding Package Language Files Some packages may ship with their own language files. Instead of changing the package's core files to tweak these lines, you may override them by placing files in the resources/lang/vendor/{package}/{locale} directory. So, for example, if you need to override the English translation strings in messages.php for a package named skyrim/hearthfire, you should place a language file at: resources/lang/vendor/hearthfire/en/messages.php. Within this file, you should only define the translation strings you wish to override. Any translation strings you don't override will still be loaded from the package's original language files. Javascript and CSS Scaffolding While Laravel does not dictate which JavaScript or CSS pre-processors you use, it does provide a basic starting point using Bootstrap and Vue that will be helpful for many applications. By default, Laravel uses NPM to install both of these frontend packages. CSS Laravel Mix provides a clean, expressive API over compiling SASS or Less, which are extensions of plain CSS that add variables, mixins, and other powerful features that make working with CSS much more enjoyable. In this document, we will briefly discuss CSS compilation in general; however, you should consult the full Laravel Mix documentation for more information on compiling SASS or Less. JavaScript Laravel does not require you to use a specific JavaScript framework or library to build your applications. In fact, you don't have to use JavaScript at all. However, Laravel does include some basic scaffolding to make it easier to get started writing modern JavaScript using the Vue library. Vue provides an expressive API for building robust JavaScript applications using components. As with CSS, we may use Laravel Mix to easily compile JavaScript components into a single, browser-ready JavaScript file. Removing The Frontend Scaffolding If you would like to remove the frontend scaffolding from your application, you may use the preset Artisan command. This command, when combined with the none option, will remove the Bootstrap and Vue scaffolding from your application, leaving only a blank SASS file and a few common JavaScript utility libraries: php artisan preset none Writing CSS Laravel's package.json file includes the bootstrap package to help you get started prototyping your application's frontend using Bootstrap. However, feel free to add or remove packages from the package.json file as needed for your own application. You are not required to use the Bootstrap framework to build your Laravel application - it is provided as a good starting point for those who choose to use it. Before compiling your CSS, install your project's frontend dependencies using the Node package manager (NPM): npm install Once the dependencies have been installed using npm install, you can compile your SASS files to plain CSS using Laravel Mix. The npm run dev command will process the instructions in your webpack.mix.js file. Typically, your compiled CSS will be placed in the public/css directory: npm run dev The default webpack.mix.js included with Laravel will compile the resources/sass/app.scss SASS file. This app.scss file imports a file of SASS variables and loads Bootstrap, which provides a good starting point for most applications. Feel free to customize the app.scss file however you wish or even use an entirely different pre-processor by configuring Laravel Mix. Writing JavaScript All of the JavaScript dependencies required by your application can be found in the package.json file in the project's root directory. This file is similar to a composer.json file except it specifies JavaScript dependencies instead of PHP dependencies. You can install these dependencies using the Node package manager (NPM): npm install By default, the Laravel package.json file includes a few packages such as vue and axios to help you get started building your JavaScript application. Feel free to add or remove from the package.json file as needed for your own application. Once the packages are installed, you can use the npm run dev command to compile your assets. Webpack is a module bundler for modern JavaScript applications. When you run the npm run dev command, Webpack will execute the instructions in your webpack.mix.js file: npm run dev By default, the Laravel webpack.mix.js file compiles your SASS and the resources/js/app.js file. Within the app.js file you may register your Vue components or, if you prefer a different framework, configure your own JavaScript application. Your compiled JavaScript will typically be placed in the public/js directory. The app.js file will load the resources/js/bootstrap.js file which bootstraps and configures Vue, Axios, jQuery, and all other JavaScript dependencies. If you have additional JavaScript dependencies to configure, you may do so in this file. Writing Vue Components By default, fresh Laravel applications contain an ExampleComponent.vue Vue component located in the resources/js/components directory. The ExampleComponent.vue file is an example of a single file Vue component which defines its JavaScript and HTML template in the same file. Single file components provide a very convenient approach to building JavaScript driven applications. The example component is registered in your app.js file: Vue.component( 'example-component', require('./components/ExampleComponent.vue') ); To use the component in your application, you may drop it into one of your HTML templates. For example, after running the make:auth Artisan command to scaffold your application's authentication and registration screens, you could drop the component into the home.blade.php Blade template: @extends('layouts.app') @section('content') <example-component></example-component> @endsection Remember, you should run the npm run dev command each time you change a Vue component. Or, you may run the npm run watch command to monitor and automatically recompile your components each time they are modified. If you are interested in learning more about writing Vue components, you should read the Vue documentation, which provides a thorough, easy-to-read overview of the entire Vue framework. Using React If you prefer to use React to build your JavaScript application, Laravel makes it a cinch to swap the Vue scaffolding with React scaffolding. On any fresh Laravel application, you may use the preset command with the react option: php artisan preset react This single command will remove the Vue scaffolding and replace it with React scaffolding, including an example component. Compiling assets (Laravel Mix) Introduction Laravel Mix provides a fluent API for defining Webpack build steps for your Laravel application using several common CSS and JavaScript pre-processors. Through simple method chaining, you can fluently define your asset pipeline. For example: mix.js('resources/js/app.js', 'public/js') .sass('resources/sass/app.scss', 'public/css'); If you've ever been confused and overwhelmed about getting started with Webpack and asset compilation, you will love Laravel Mix. However, you are not required to use it while developing your application; you are free to use any asset pipeline tool you wish, or even none at all. Installation & Setup Installing Node Before triggering Mix, you must first ensure that Node.js and NPM are installed on your machine. node -v npm -v By default, Laravel Homestead includes everything you need; however, if you aren't using Vagrant, then you can easily install the latest version of Node and NPM using simple graphical installers from their download page. Laravel Mix The only remaining step is to install Laravel Mix. Within a fresh installation of Laravel, you'll find a package.json file in the root of your directory structure. The default package.json file includes everything you need to get started. Think of this like your composer.json file, except it defines Node dependencies instead of PHP. You may install the dependencies it references by running: npm install Running Mix Mix is a configuration layer on top of Webpack, so to run your Mix tasks you only need to execute one of the NPM scripts that is included with the default Laravel package.json file: // Run all Mix tasks... npm run dev // Run all Mix tasks and minify output... npm run production Watching Assets For Changes The npm run watch command will continue running in your terminal and watch all relevant files for changes. Webpack will then automatically recompile your assets when it detects a change: npm run watch You may find that in certain environments Webpack isn't updating when your files change. If this is the case on your system, consider using the watch-poll command: npm run watch-poll Working With Stylesheets The webpack.mix.js file is your entry point for all asset compilation. Think of it as a light configuration wrapper around Webpack. Mix tasks can be chained together to define exactly how your assets should be compiled. Less The less method may be used to compile Less into CSS. Let's compile our primary app.less file to public/css/app.css. mix.less('resources/less/app.less', 'public/css'); Multiple calls to the less method may be used to compile multiple files: mix.less('resources/less/app.less', 'public/css') .less('resources/less/admin.less', 'public/css'); If you wish to customize the file name of the compiled CSS, you may pass a full file path as the second argument to the less method: mix.less('resources/less/app.less', 'public/stylesheets/styles.css'); If you need to override the underlying Less plug-in options, you may pass an object as the third argument to mix.less(): mix.less('resources/less/app.less', 'public/css', { strictMath: true }); Sass The sass method allows you to compile Sass into CSS. You may use the method like so: mix.sass('resources/sass/app.scss', 'public/css'); Again, like the less method, you may compile multiple Sass files into their own respective CSS files and even customize the output directory of the resulting CSS: mix.sass('resources/sass/app.sass', 'public/css') .sass('resources/sass/admin.sass', 'public/css/admin'); Additional Node-Sass plug-in options may be provided as the third argument: mix.sass('resources/sass/app.sass', 'public/css', { precision: 5 }); Stylus Similar to Less and Sass, the stylus method allows you to compile Stylus into CSS: mix.stylus('resources/stylus/app.styl', 'public/css'); You may also install additional Stylus plug-ins, such as Rupture. First, install the plug-in in question through NPM (npm install rupture) and then require it in your call to mix.stylus(): mix.stylus('resources/stylus/app.styl', 'public/css', { use: [ require('rupture')() ] }); PostCSS PostCSS, a powerful tool for transforming your CSS, is included with Laravel Mix out of the box. By default, Mix leverages the popular Autoprefixer plug-in to automatically apply all necessary CSS3 vendor prefixes. However, you're free to add any additional plug-ins that are appropriate for your application. First, install the desired plug-in through NPM and then reference it in your webpack.mix.js file: mix.sass('resources/sass/app.scss', 'public/css') .options({ postCss: [ require('postcss-css-variables')() ] }); Plain CSS If you would just like to concatenate some plain CSS stylesheets into a single file, you may use the styles method. mix.styles([ 'public/css/vendor/normalize.css', 'public/css/vendor/videojs.css' ], 'public/css/all.css'); URL Processing Because Laravel Mix is built on top of Webpack, it's important to understand a few Webpack concepts. For CSS compilation, Webpack will rewrite and optimize any url() calls within your stylesheets. While this might initially sound strange, it's an incredibly powerful piece of functionality. Imagine that we want to compile Sass that includes a relative URL to an image: .example { background: url('../images/example.png'); } Absolute paths for any given url() will be excluded from URL-rewriting. For example, url('/images/thing.png') or url('http://example.com/images/thing.png') won't be modified. By default, Laravel Mix and Webpack will find example.png, copy it to your public/images folder, and then rewrite the url() within your generated stylesheet. As such, your compiled CSS will be: .example { background: url(/images/example.png?d41d8cd98f00b204e9800998ecf8427e); } As useful as this feature may be, it's possible that your existing folder structure is already configured in a way you like. If this is the case, you may disable url() rewriting like so: mix.sass('resources/app/app.scss', 'public/css') .options({ processCssUrls: false }); With this addition to your webpack.mix.js file, Mix will no longer match any url() or copy assets to your public directory. In other words, the compiled CSS will look just like how you originally typed it: .example { background: url(\"../images/thing.png\"); } Source Maps Though disabled by default, source maps may be activated by calling the mix.sourceMaps() method in your webpack.mix.js file. Though it comes with a compile/performance cost, this will provide extra debugging information to your browser's developer tools when using compiled assets. mix.js('resources/js/app.js', 'public/js') .sourceMaps(); Working With JavaScript Mix provides several features to help you work with your JavaScript files, such as compiling ECMAScript 2015, module bundling, minification, and concatenating plain JavaScript files. Even better, this all works seamlessly, without requiring an ounce of custom configuration: mix.js('resources/js/app.js', 'public/js'); With this single line of code, you may now take advantage of: * ES2015 syntax. * Modules * Compilation of .vue files. * Minification for production environments. Vendor Extraction One potential downside to bundling all application-specific JavaScript with your vendor libraries is that it makes long-term caching more difficult. For example, a single update to your application code will force the browser to re-download all of your vendor libraries even if they haven't changed. If you intend to make frequent updates to your application's JavaScript, you should consider extracting all of your vendor libraries into their own file. This way, a change to your application code will not affect the caching of your large vendor.js file. Mix's extract method makes this a breeze: mix.js('resources/js/app.js', 'public/js') .extract(['vue']) The extract method accepts an array of all libraries or modules that you wish to extract into a vendor.js file. Using the above snippet as an example, Mix will generate the following files: * public/js/manifest.js: The Webpack manifest runtime * public/js/vendor.js: Your vendor libraries * public/js/app.js: Your application code To avoid JavaScript errors, be sure to load these files in the proper order: <script src=\"/js/manifest.js\"></script> <script src=\"/js/vendor.js\"></script> <script src=\"/js/app.js\"></script> React Mix can automatically install the Babel plug-ins necessary for React support. To get started, replace your mix.js() call with mix.react(): mix.react('resources/js/app.jsx', 'public/js'); Behind the scenes, Mix will download and include the appropriate babel-preset-react Babel plug-in. Vanilla JS Similar to combining stylesheets with mix.styles(), you may also combine and minify any number of JavaScript files with the scripts() method: mix.scripts([ 'public/js/admin.js', 'public/js/dashboard.js' ], 'public/js/all.js'); This option is particularly useful for legacy projects where you don't require Webpack compilation for your JavaScript. A slight variation of mix.scripts() is mix.babel(). Its method signature is identical to scripts; however, the concatenated file will receive Babel compilation, which translates any ES2015 code to vanilla JavaScript that all browsers will understand. Custom Webpack Configuration Behind the scenes, Laravel Mix references a pre-configured webpack.config.js file to get you up and running as quickly as possible. Occasionally, you may need to manually modify this file. You might have a special loader or plug-in that needs to be referenced, or maybe you prefer to use Stylus instead of Sass. In such instances, you have two choices: Merging Custom Configuration Mix provides a useful webpackConfig method that allows you to merge any short Webpack configuration overrides. This is a particularly appealing choice, as it doesn't require you to copy and maintain your own copy of the webpack.config.js file. The webpackConfig method accepts an object, which should contain any Webpack-specific configuration that you wish to apply. mix.webpackConfig({ resolve: { modules: [ path.resolve(__dirname, 'vendor/laravel/spark/resources/assets/js') ] } }); Custom Configuration Files If you would like to completely customize your Webpack configuration, copy the node_modules/laravel-mix/setup/webpack.config.js file to your project's root directory. Next, point all of the --config references in your package.json file to the newly copied configuration file. If you choose to take this approach to customization, any future upstream updates to Mix's webpack.config.js must be manually merged into your customized file. Copying Files & Directories The copy method may be used to copy files and directories to new locations. This can be useful when a particular asset within your node_modules directory needs to be relocated to your public folder. mix.copy('node_modules/foo/bar.css', 'public/css/bar.css'); When copying a directory, the copy method will flatten the directory's structure. To maintain the directory's original structure, you should use the copyDirectory method instead: mix.copyDirectory('resources/img', 'public/img'); Versioning / Cache Busting Many developers suffix their compiled assets with a timestamp or unique token to force browsers to load the fresh assets instead of serving stale copies of the code. Mix can handle this for you using the version method. The version method will automatically append a unique hash to the filenames of all compiled files, allowing for more convenient cache busting: mix.js('resources/js/app.js', 'public/js') .version(); After generating the versioned file, you won't know the exact file name. So, you should use Laravel's global mix function within your views to load the appropriately hashed asset. The mix function will automatically determine the current name of the hashed file: <script src=\"{{ mix('/js/app.js') }}\"></script> Because versioned files are usually unnecessary in development, you may instruct the versioning process to only run during npm run production: mix.js('resources/js/app.js', 'public/js'); if (mix.inProduction()) { mix.version(); } Browsersync Reloading BrowserSync can automatically monitor your files for changes, and inject your changes into the browser without requiring a manual refresh. You may enable support by calling the mix.browserSync() method: mix.browserSync('my-domain.test'); // Or... // https://browsersync.io/docs/options mix.browserSync({ proxy: 'my-domain.test' }); You may pass either a string (proxy) or object (BrowserSync settings) to this method. Next, start Webpack's dev server using the npm run watch command. Now, when you modify a script or PHP file, watch as the browser instantly refreshes the page to reflect your changes. Environment Variables You may inject environment variables into Mix by prefixing a key in your .env file with MIX_: MIX_SENTRY_DSN_PUBLIC=http://example.com After the variable has been defined in your .env file, you may access via the process.env object. If the value changes while you are running a watch task, you will need to restart the task: process.env.MIX_SENTRY_DSN_PUBLIC Notifications When available, Mix will automatically display OS notifications for each bundle. This will give you instant feedback, as to whether the compilation was successful or not. However, there may be instances when you'd prefer to disable these notifications. One such example might be triggering Mix on your production server. Notifications may be deactivated, via the disableNotifications method. mix.disableNotifications();","title":"Laravel Blade Templating"},{"location":"developerdoc/laravel_blade/#laravel-blade-templating","text":"Blade is the simple, yet powerful templating engine provided with Laravel. Unlike other popular PHP templating engines, Blade does not restrict you from using plain PHP code in your views. In fact, all Blade views are compiled into plain PHP code and cached until they are modified, meaning Blade adds essentially zero overhead to your application. Blade view files use the .blade.php file extension and are typically stored in the resources/views directory.","title":"Laravel Blade Templating"},{"location":"developerdoc/laravel_blade/#template-inheritance","text":"","title":"Template Inheritance"},{"location":"developerdoc/laravel_blade/#defining-a-layout","text":"Two of the primary benefits of using Blade are template inheritance and sections. To get started, let's take a look at a simple example. First, we will examine a \"master\" page layout. Since most web applications maintain the same general layout across various pages, it's convenient to define this layout as a single Blade view: <!-- Stored in resources/views/layouts/app.blade.php --> <html> <head> <title>App Name - @yield('title')</title> </head> <body> @section('sidebar') This is the master sidebar. @show <div class=\"container\"> @yield('content') </div> </body> </html> As you can see, this file contains typical HTML mark-up. However, take note of the @section and @yield directives. The @section directive, as the name implies, defines a section of content, while the @yield directive is used to display the contents of a given section. Now that we have defined a layout for our application, let's define a child page that inherits the layout.","title":"Defining A Layout"},{"location":"developerdoc/laravel_blade/#extending-a-layout","text":"When defining a child view, use the Blade @extends directive to specify which layout the child view should \"inherit\". Views which extend a Blade layout may inject content into the layout's sections using @section directives. Remember, as seen in the example above, the contents of these sections will be displayed in the layout using @yield: <!-- Stored in resources/views/child.blade.php --> @extends('layouts.app') @section('title', 'Page Title') @section('sidebar') @parent <p>This is appended to the master sidebar.</p> @endsection @section('content') <p>This is my body content.</p> @endsection In this example, the sidebar section is utilizing the @parent directive to append (rather than overwriting) content to the layout's sidebar. The @parent directive will be replaced by the content of the layout when the view is rendered. Contrary to the previous example, this sidebar section ends with @endsection instead of @show. The @endsection directive will only define a section while @show will define and immediately yield the section. The @yield directive also accepts a default value as its second parameter. This value will be rendered if the section being yielded is undefined: @yield('content', View::make('view.name')) Blade views may be returned from routes using the global view helper: Route::get('blade', function () { return view('child'); });","title":"Extending A Layout"},{"location":"developerdoc/laravel_blade/#components-slots","text":"Components and slots provide similar benefits to sections and layouts; however, some may find the mental model of components and slots easier to understand. First, let's imagine a reusable \"alert\" component we would like to reuse throughout our application: <!-- /resources/views/alert.blade.php --> <div class=\"alert alert-danger\"> {{ $slot }} </div> The {{ $slot }} variable will contain the content we wish to inject into the component. Now, to construct this component, we can use the @component Blade directive: @component('alert') <strong>Whoops!</strong> Something went wrong! @endcomponent To instruct Laravel to load the first view that exists from a given array of possible views for the component, you may use the componentFirst directive: @componentFirst(['custom.alert', 'alert']) <strong>Whoops!</strong> Something went wrong! @endcomponent Sometimes it is helpful to define multiple slots for a component. Let's modify our alert component to allow for the injection of a \"title\". Named slots may be displayed by \"echoing\" the variable that matches their name: <!-- /resources/views/alert.blade.php --> <div class=\"alert alert-danger\"> <div class=\"alert-title\">{{ $title }}</div> {{ $slot }} </div> Now, we can inject content into the named slot using the @slot directive. Any content not within a @slot directive will be passed to the component in the $slot variable: @component('alert') @slot('title') Forbidden @endslot You are not allowed to access this resource! @endcomponent","title":"Components &amp; Slots"},{"location":"developerdoc/laravel_blade/#passing-additional-data-to-components","text":"Sometimes you may need to pass additional data to a component. For this reason, you can pass an array of data as the second argument to the @component directive. All of the data will be made available to the component template as variables: @component('alert', ['foo' => 'bar']) ... @endcomponent","title":"Passing Additional Data To Components"},{"location":"developerdoc/laravel_blade/#aliasing-components","text":"If your Blade components are stored in a sub-directory, you may wish to alias them for easier access. For example, imagine a Blade component that is stored at resources/views/components/alert.blade.php. You may use the component method to alias the component from components.alert to alert. Typically, this should be done in the boot method of your AppServiceProvider: use Illuminate\\Support\\Facades\\Blade; Blade::component('components.alert', 'alert'); Once the component has been aliased, you may render it using a directive: @alert(['type' => 'danger']) You are not allowed to access this resource! @endalert You may omit the component parameters if it has no additional slots: @alert You are not allowed to access this resource! @endalert","title":"Aliasing Components"},{"location":"developerdoc/laravel_blade/#displaying-data","text":"You may display data passed to your Blade views by wrapping the variable in curly braces. For example, given the following route: Route::get('greeting', function () { return view('welcome', ['name' => 'Samantha']); }); You may display the contents of the name variable like so: Hello, {{ $name }}. Blade {{ }} statements are automatically sent through PHP's htmlspecialchars function to prevent XSS attacks. You are not limited to displaying the contents of the variables passed to the view. You may also echo the results of any PHP function. In fact, you can put any PHP code you wish inside of a Blade echo statement: The current UNIX timestamp is {{ time() }}.","title":"Displaying Data"},{"location":"developerdoc/laravel_blade/#displaying-unescaped-data","text":"By default, Blade {{ }} statements are automatically sent through PHP's htmlspecialchars function to prevent XSS attacks. If you do not want your data to be escaped, you may use the following syntax: Hello, {!! $name !!}. Be very careful when echoing content that is supplied by users of your application. Always use the escaped, double curly brace syntax to prevent XSS attacks when displaying user supplied data.","title":"Displaying Unescaped Data"},{"location":"developerdoc/laravel_blade/#rendering-json","text":"Sometimes you may pass an array to your view with the intention of rendering it as JSON in order to initialize a JavaScript variable. For example: <script> var app = <?php echo json_encode($array); ?>; </script> However, instead of manually calling json_encode, you may use the @json Blade directive. The @json directive accepts the same arguments as PHP's json_encode function: <script> var app = @json($array); var app = @json($array, JSON_PRETTY_PRINT); </script> You should only use the @json directive to render existing variables as JSON. The Blade templating is based on regular expressions and attempts to pass a complex expression to the directive may cause unexpected failures. The @json directive is also useful for seeding Vue components or data-* attributes: <example-component :some-prop='@json($array)'></example-component> Using @json in element attributes requires that it be surrounded by single quotes.","title":"Rendering JSON"},{"location":"developerdoc/laravel_blade/#html-entity-encoding","text":"By default, Blade (and the Laravel e helper) will double encode HTML entities. If you would like to disable double encoding, call the Blade::withoutDoubleEncoding method from the boot method of your AppServiceProvider: <?php namespace App\\Providers; use Illuminate\\Support\\Facades\\Blade; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Bootstrap any application services. * * @return void */ public function boot() { Blade::withoutDoubleEncoding(); } }","title":"HTML Entity Encoding"},{"location":"developerdoc/laravel_blade/#blade-javascript-frameworks","text":"Since many JavaScript frameworks also use \"curly\" braces to indicate a given expression should be displayed in the browser, you may use the @ symbol to inform the Blade rendering engine an expression should remain untouched. For example: <h1>Laravel</h1> Hello, @{{ name }}. In this example, the @ symbol will be removed by Blade; however, {{ name }} expression will remain untouched by the Blade engine, allowing it to instead be rendered by your JavaScript framework.","title":"Blade &amp; JavaScript Frameworks"},{"location":"developerdoc/laravel_blade/#the-verbatim-directive","text":"If you are displaying JavaScript variables in a large portion of your template, you may wrap the HTML in the @verbatim directive so that you do not have to prefix each Blade echo statement with an @ symbol: @verbatim <div class=\"container\"> Hello, {{ name }}. </div> @endverbatim","title":"The @verbatim Directive"},{"location":"developerdoc/laravel_blade/#control-structures","text":"In addition to template inheritance and displaying data, Blade also provides convenient shortcuts for common PHP control structures, such as conditional statements and loops. These shortcuts provide a very clean, terse way of working with PHP control structures, while also remaining familiar to their PHP counterparts.","title":"Control Structures"},{"location":"developerdoc/laravel_blade/#if-statements","text":"You may construct if statements using the @if, @elseif, @else, and @endif directives. These directives function identically to their PHP counterparts: @if (count($records) === 1) I have one record! @elseif (count($records) > 1) I have multiple records! @else I don't have any records! @endif For convenience, Blade also provides an @unless directive: @unless (Auth::check()) You are not signed in. @endunless In addition to the conditional directives already discussed, the @isset and @empty directives may be used as convenient shortcuts for their respective PHP functions: @isset($records) // $records is defined and is not null... @endisset @empty($records) // $records is \"empty\"... @endempty","title":"If Statements"},{"location":"developerdoc/laravel_blade/#authentication-directives","text":"The @auth and @guest directives may be used to quickly determine if the current user is authenticated or is a guest: @auth // The user is authenticated... @endauth @guest // The user is not authenticated... @endguest If needed, you may specify the authentication guard that should be checked when using the @auth and @guest directives: @auth('admin') // The user is authenticated... @endauth @guest('admin') // The user is not authenticated... @endguest","title":"Authentication Directives"},{"location":"developerdoc/laravel_blade/#section-directives","text":"You may check if a section has content using the @hasSection directive: @hasSection('navigation') <div class=\"pull-right\"> @yield('navigation') </div> <div class=\"clearfix\"></div> @endif","title":"Section Directives"},{"location":"developerdoc/laravel_blade/#switch-statements","text":"Switch statements can be constructed using the @switch, @case, @break, @default and @endswitch directives: @switch($i) @case(1) First case... @break @case(2) Second case... @break @default Default case... @endswitch","title":"Switch Statements"},{"location":"developerdoc/laravel_blade/#loops","text":"In addition to conditional statements, Blade provides simple directives for working with PHP's loop structures. Again, each of these directives functions identically to their PHP counterparts: @for ($i = 0; $i < 10; $i++) The current value is {{ $i }} @endfor @foreach ($users as $user) <p>This is user {{ $user->id }}</p> @endforeach @forelse ($users as $user) <li>{{ $user->name }}</li> @empty <p>No users</p> @endforelse @while (true) <p>I'm looping forever.</p> @endwhile When looping, you may use the loop variable to gain valuable information about the loop, such as whether you are in the first or last iteration through the loop. When using loops you may also end the loop or skip the current iteration: @foreach ($users as $user) @if ($user->type == 1) @continue @endif <li>{{ $user->name }}</li> @if ($user->number == 5) @break @endif @endforeach You may also include the condition with the directive declaration in one line: @foreach ($users as $user) @continue($user->type == 1) <li>{{ $user->name }}</li> @break($user->number == 5) @endforeach","title":"Loops"},{"location":"developerdoc/laravel_blade/#the-loop-variable","text":"When looping, a $loop variable will be available inside of your loop. This variable provides access to some useful bits of information such as the current loop index and whether this is the first or last iteration through the loop: @foreach ($users as $user) @if ($loop->first) This is the first iteration. @endif @if ($loop->last) This is the last iteration. @endif <p>This is user {{ $user->id }}</p> @endforeach If you are in a nested loop, you may access the parent loop's $loop variable via the parent property: @foreach ($users as $user) @foreach ($user->posts as $post) @if ($loop->parent->first) This is first iteration of the parent loop. @endif @endforeach @endforeach The $loop variable also contains a variety of other useful properties: | Property | Description | | --- | --- | |$loop->index | The index of the current loop iteration (starts at 0). | |$loop->iteration | The current loop iteration (starts at 1). | |$loop->remaining | The iterations remaining in the loop. | |$loop->count | The total number of items in the array being iterated. | |$loop->first | Whether this is the first iteration through the loop. | |$loop->last | Whether this is the last iteration through the loop. | |$loop->even | Whether this is an even iteration through the loop. | |$loop->odd | Whether this is an odd iteration through the loop. | |$loop->depth | The nesting level of the current loop. | |$loop->parent | When in a nested loop, the parent's loop variable. |","title":"The Loop Variable"},{"location":"developerdoc/laravel_blade/#comments","text":"Blade also allows you to define comments in your views. However, unlike HTML comments, Blade comments are not included in the HTML returned by your application: {{-- This comment will not be present in the rendered HTML --}}","title":"Comments"},{"location":"developerdoc/laravel_blade/#php","text":"In some situations, it's useful to embed PHP code into your views. You can use the Blade @php directive to execute a block of plain PHP within your template: @php // @endphp While Blade provides this feature, using it frequently may be a signal that you have too much logic embedded within your template.","title":"PHP"},{"location":"developerdoc/laravel_blade/#forms","text":"","title":"Forms"},{"location":"developerdoc/laravel_blade/#csrf-field","text":"Anytime you define an HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field: <form method=\"POST\" action=\"/profile\"> @csrf ... </form>","title":"CSRF Field"},{"location":"developerdoc/laravel_blade/#method-field","text":"Since HTML forms can't make PUT, PATCH, or DELETE requests, you will need to add a hidden _method field to spoof these HTTP verbs. The @method Blade directive can create this field for you: <form action=\"/foo/bar\" method=\"POST\"> @method('PUT') ... </form>","title":"Method Field"},{"location":"developerdoc/laravel_blade/#validation-errors","text":"The @error directive may be used to quickly check if validation error messages exist for a given attribute. Within an @error directive, you may echo the $message variable to display the error message: <!-- /resources/views/post/create.blade.php --> <label for=\"title\">Post Title</label> <input id=\"title\" type=\"text\" class=\"@error('title') is-invalid @enderror\"> @error('title') <div class=\"alert alert-danger\">{{ $message }}</div> @enderror","title":"Validation Errors"},{"location":"developerdoc/laravel_blade/#including-sub-views","text":"Blade's @include directive allows you to include a Blade view from within another view. All variables that are available to the parent view will be made available to the included view: <div> @include('shared.errors') <form> <!-- Form Contents --> </form> </div> Even though the included view will inherit all data available in the parent view, you may also pass an array of extra data to the included view: @include('view.name', ['some' => 'data']) If you attempt to @include a view which does not exist, Laravel will throw an error. If you would like to include a view that may or may not be present, you should use the @includeIf directive: @includeIf('view.name', ['some' => 'data']) If you would like to @include a view depending on a given boolean condition, you may use the @includeWhen directive: @includeWhen($boolean, 'view.name', ['some' => 'data']) To include the first view that exists from a given array of views, you may use the includeFirst directive: @includeFirst(['custom.admin', 'admin'], ['some' => 'data']) You should avoid using the DIR and FILE constants in your Blade views, since they will refer to the location of the cached, compiled view.","title":"Including Sub-Views"},{"location":"developerdoc/laravel_blade/#aliasing-includes","text":"If your Blade includes are stored in a sub-directory, you may wish to alias them for easier access. For example, imagine a Blade include that is stored at resources/views/includes/input.blade.php with the following content: <input type=\"{{ $type ?? 'text' }}\"> You may use the include method to alias the include from includes.input to input. Typically, this should be done in the boot method of your AppServiceProvider: use Illuminate\\Support\\Facades\\Blade; Blade::include('includes.input', 'input'); Once the include has been aliased, you may render it using the alias name as the Blade directive: @input(['type' => 'email'])","title":"Aliasing Includes"},{"location":"developerdoc/laravel_blade/#rendering-views-for-collections","text":"You may combine loops and includes into one line with Blade's @each directive: @each('view.name', $jobs, 'job') The first argument is the view partial to render for each element in the array or collection. The second argument is the array or collection you wish to iterate over, while the third argument is the variable name that will be assigned to the current iteration within the view. So, for example, if you are iterating over an array of jobs, typically you will want to access each job as a job variable within your view partial. The key for the current iteration will be available as the key variable within your view partial. You may also pass a fourth argument to the @each directive. This argument determines the view that will be rendered if the given array is empty. @each('view.name', $jobs, 'job', 'view.empty') Views rendered via @each do not inherit the variables from the parent view. If the child view requires these variables, you should use @foreach and @include instead.","title":"Rendering Views For Collections"},{"location":"developerdoc/laravel_blade/#stacks","text":"Blade allows you to push to named stacks which can be rendered somewhere else in another view or layout. This can be particularly useful for specifying any JavaScript libraries required by your child views: @push('scripts') <script src=\"/example.js\"></script> @endpush You may push to a stack as many times as needed. To render the complete stack contents, pass the name of the stack to the @stack directive: <head> <!-- Head Contents --> @stack('scripts') </head> If you would like to prepend content onto the beginning of a stack, you should use the @prepend directive: @push('scripts') This will be second... @endpush // Later... @prepend('scripts') This will be first... @endprepend","title":"Stacks"},{"location":"developerdoc/laravel_blade/#service-injection","text":"The @inject directive may be used to retrieve a service from the Laravel service container. The first argument passed to @inject is the name of the variable the service will be placed into, while the second argument is the class or interface name of the service you wish to resolve: @inject('metrics', 'App\\Services\\MetricsService') <div> Monthly Revenue: {{ $metrics->monthlyRevenue() }}. </div>","title":"Service Injection"},{"location":"developerdoc/laravel_blade/#extending-blade","text":"Blade allows you to define your own custom directives using the directive method. When the Blade compiler encounters the custom directive, it will call the provided callback with the expression that the directive contains. The following example creates a @datetime($var) directive which formats a given $var, which should be an instance of DateTime: <?php namespace App\\Providers; use Illuminate\\Support\\Facades\\Blade; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Register bindings in the container. * * @return void */ public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { Blade::directive('datetime', function ($expression) { return \"<?php echo ($expression)->format('m/d/Y H:i'); ?>\"; }); } } As you can see, we will chain the format method onto whatever expression is passed into the directive. So, in this example, the final PHP generated by this directive will be: <?php echo ($var)->format('m/d/Y H:i'); ?> After updating the logic of a Blade directive, you will need to delete all of the cached Blade views. The cached Blade views may be removed using the view:clear Artisan command.","title":"Extending Blade"},{"location":"developerdoc/laravel_blade/#custom-if-statements","text":"Programming a custom directive is sometimes more complex than necessary when defining simple, custom conditional statements. For that reason, Blade provides a Blade::if method which allows you to quickly define custom conditional directives using Closures. For example, let's define a custom conditional that checks the current application environment. We may do this in the boot method of our AppServiceProvider: use Illuminate\\Support\\Facades\\Blade; /** * Bootstrap any application services. * * @return void */ public function boot() { Blade::if('env', function ($environment) { return app()->environment($environment); }); } Once the custom conditional has been defined, we can easily use it on our templates: @env('local') // The application is in the local environment... @elseenv('testing') // The application is in the testing environment... @else // The application is not in the local or testing environment... @endenv","title":"Custom If Statements"},{"location":"developerdoc/laravel_blade/#localization","text":"","title":"Localization"},{"location":"developerdoc/laravel_blade/#introduction","text":"Laravel's localization features provide a convenient way to retrieve strings in various languages, allowing you to easily support multiple languages within your application. Language strings are stored in files within the resources/lang directory. Within this directory there should be a subdirectory for each language supported by the application: /resources /lang /en messages.php /es messages.php All language files return an array of keyed strings. For example: <?php return [ 'welcome' => 'Welcome to our application' ];","title":"Introduction"},{"location":"developerdoc/laravel_blade/#configuring-the-locale","text":"The default language for your application is stored in the config/app.php configuration file. You may modify this value to suit the needs of your application. You may also change the active language at runtime using the setLocale method on the App facade: Route::get('welcome/{locale}', function ($locale) { App::setLocale($locale); // }); You may configure a \"fallback language\", which will be used when the active language does not contain a given translation string. Like the default language, the fallback language is also configured in the config/app.php configuration file: 'fallback_locale' => 'en',","title":"Configuring The Locale"},{"location":"developerdoc/laravel_blade/#determining-the-current-locale","text":"You may use the getLocale and isLocale methods on the App facade to determine the current locale or check if the locale is a given value: $locale = App::getLocale(); if (App::isLocale('en')) { // }","title":"Determining The Current Locale"},{"location":"developerdoc/laravel_blade/#defining-translation-strings","text":"","title":"Defining Translation Strings"},{"location":"developerdoc/laravel_blade/#using-short-keys","text":"Typically, translation strings are stored in files within the resources/lang directory. Within this directory there should be a subdirectory for each language supported by the application: /resources /lang /en messages.php /es messages.php All language files return an array of keyed strings. For example: <?php // resources/lang/en/messages.php return [ 'welcome' => 'Welcome to our application' ];","title":"Using Short Keys"},{"location":"developerdoc/laravel_blade/#using-translation-strings-as-keys","text":"For applications with heavy translation requirements, defining every string with a \"short key\" can become quickly confusing when referencing them in your views. For this reason, Laravel also provides support for defining translation strings using the \"default\" translation of the string as the key. Translation files that use translation strings as keys are stored as JSON files in the resources/lang directory. For example, if your application has a Spanish translation, you should create a resources/lang/es.json file: { \"I love programming.\": \"Me encanta programar.\" }","title":"Using Translation Strings As Keys"},{"location":"developerdoc/laravel_blade/#retrieving-translation-strings","text":"You may retrieve lines from language files using the helper function. The method accepts the file and key of the translation string as its first argument. For example, let's retrieve the welcome translation string from the resources/lang/messages.php language file: echo __('messages.welcome'); echo __('I love programming.'); If you are using the Blade templating engine, you may use the {{ }} syntax to echo the translation string or use the @lang directive: {{ __('messages.welcome') }} @lang('messages.welcome') If the specified translation string does not exist, the function will return the translation string key. So, using the example above, the function would return messages.welcome if the translation string does not exist. The @lang directive does not escape any output. You are fully responsible for escaping your own output when using this directive.","title":"Retrieving Translation Strings"},{"location":"developerdoc/laravel_blade/#replacing-parameters-in-translation-strings","text":"If you wish, you may define placeholders in your translation strings. All placeholders are prefixed with a :. For example, you may define a welcome message with a placeholder name: 'welcome' => 'Welcome, :name', To replace the placeholders when retrieving a translation string, pass an array of replacements as the second argument to the __ function: echo __('messages.welcome', ['name' => 'dayle']); If your placeholder contains all capital letters, or only has its first letter capitalized, the translated value will be capitalized accordingly: 'welcome' => 'Welcome, :NAME', // Welcome, DAYLE 'goodbye' => 'Goodbye, :Name', // Goodbye, Dayle","title":"Replacing Parameters In Translation Strings"},{"location":"developerdoc/laravel_blade/#pluralization","text":"Pluralization is a complex problem, as different languages have a variety of complex rules for pluralization. By using a \"pipe\" character, you may distinguish singular and plural forms of a string: 'apples' => 'There is one apple|There are many apples', You may even create more complex pluralization rules which specify translation strings for multiple number ranges: 'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many', After defining a translation string that has pluralization options, you may use the trans_choice function to retrieve the line for a given \"count\". In this example, since the count is greater than one, the plural form of the translation string is returned: echo trans_choice('messages.apples', 10); You may also define placeholder attributes in pluralization strings. These placeholders may be replaced by passing an array as the third argument to the trans_choice function: 'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago', echo trans_choice('time.minutes_ago', 5, ['value' => 5]); If you would like to display the integer value that was passed to the trans_choice function, you may use the :count placeholder: 'apples' => '{0} There are none|{1} There is one|[2,*] There are :count',","title":"Pluralization"},{"location":"developerdoc/laravel_blade/#overriding-package-language-files","text":"Some packages may ship with their own language files. Instead of changing the package's core files to tweak these lines, you may override them by placing files in the resources/lang/vendor/{package}/{locale} directory. So, for example, if you need to override the English translation strings in messages.php for a package named skyrim/hearthfire, you should place a language file at: resources/lang/vendor/hearthfire/en/messages.php. Within this file, you should only define the translation strings you wish to override. Any translation strings you don't override will still be loaded from the package's original language files.","title":"Overriding Package Language Files"},{"location":"developerdoc/laravel_blade/#javascript-and-css-scaffolding","text":"While Laravel does not dictate which JavaScript or CSS pre-processors you use, it does provide a basic starting point using Bootstrap and Vue that will be helpful for many applications. By default, Laravel uses NPM to install both of these frontend packages.","title":"Javascript and CSS Scaffolding"},{"location":"developerdoc/laravel_blade/#css","text":"Laravel Mix provides a clean, expressive API over compiling SASS or Less, which are extensions of plain CSS that add variables, mixins, and other powerful features that make working with CSS much more enjoyable. In this document, we will briefly discuss CSS compilation in general; however, you should consult the full Laravel Mix documentation for more information on compiling SASS or Less.","title":"CSS"},{"location":"developerdoc/laravel_blade/#javascript","text":"Laravel does not require you to use a specific JavaScript framework or library to build your applications. In fact, you don't have to use JavaScript at all. However, Laravel does include some basic scaffolding to make it easier to get started writing modern JavaScript using the Vue library. Vue provides an expressive API for building robust JavaScript applications using components. As with CSS, we may use Laravel Mix to easily compile JavaScript components into a single, browser-ready JavaScript file.","title":"JavaScript"},{"location":"developerdoc/laravel_blade/#removing-the-frontend-scaffolding","text":"If you would like to remove the frontend scaffolding from your application, you may use the preset Artisan command. This command, when combined with the none option, will remove the Bootstrap and Vue scaffolding from your application, leaving only a blank SASS file and a few common JavaScript utility libraries: php artisan preset none","title":"Removing The Frontend Scaffolding"},{"location":"developerdoc/laravel_blade/#writing-css","text":"Laravel's package.json file includes the bootstrap package to help you get started prototyping your application's frontend using Bootstrap. However, feel free to add or remove packages from the package.json file as needed for your own application. You are not required to use the Bootstrap framework to build your Laravel application - it is provided as a good starting point for those who choose to use it. Before compiling your CSS, install your project's frontend dependencies using the Node package manager (NPM): npm install Once the dependencies have been installed using npm install, you can compile your SASS files to plain CSS using Laravel Mix. The npm run dev command will process the instructions in your webpack.mix.js file. Typically, your compiled CSS will be placed in the public/css directory: npm run dev The default webpack.mix.js included with Laravel will compile the resources/sass/app.scss SASS file. This app.scss file imports a file of SASS variables and loads Bootstrap, which provides a good starting point for most applications. Feel free to customize the app.scss file however you wish or even use an entirely different pre-processor by configuring Laravel Mix.","title":"Writing CSS"},{"location":"developerdoc/laravel_blade/#writing-javascript","text":"All of the JavaScript dependencies required by your application can be found in the package.json file in the project's root directory. This file is similar to a composer.json file except it specifies JavaScript dependencies instead of PHP dependencies. You can install these dependencies using the Node package manager (NPM): npm install By default, the Laravel package.json file includes a few packages such as vue and axios to help you get started building your JavaScript application. Feel free to add or remove from the package.json file as needed for your own application. Once the packages are installed, you can use the npm run dev command to compile your assets. Webpack is a module bundler for modern JavaScript applications. When you run the npm run dev command, Webpack will execute the instructions in your webpack.mix.js file: npm run dev By default, the Laravel webpack.mix.js file compiles your SASS and the resources/js/app.js file. Within the app.js file you may register your Vue components or, if you prefer a different framework, configure your own JavaScript application. Your compiled JavaScript will typically be placed in the public/js directory. The app.js file will load the resources/js/bootstrap.js file which bootstraps and configures Vue, Axios, jQuery, and all other JavaScript dependencies. If you have additional JavaScript dependencies to configure, you may do so in this file.","title":"Writing JavaScript"},{"location":"developerdoc/laravel_blade/#writing-vue-components","text":"By default, fresh Laravel applications contain an ExampleComponent.vue Vue component located in the resources/js/components directory. The ExampleComponent.vue file is an example of a single file Vue component which defines its JavaScript and HTML template in the same file. Single file components provide a very convenient approach to building JavaScript driven applications. The example component is registered in your app.js file: Vue.component( 'example-component', require('./components/ExampleComponent.vue') ); To use the component in your application, you may drop it into one of your HTML templates. For example, after running the make:auth Artisan command to scaffold your application's authentication and registration screens, you could drop the component into the home.blade.php Blade template: @extends('layouts.app') @section('content') <example-component></example-component> @endsection Remember, you should run the npm run dev command each time you change a Vue component. Or, you may run the npm run watch command to monitor and automatically recompile your components each time they are modified. If you are interested in learning more about writing Vue components, you should read the Vue documentation, which provides a thorough, easy-to-read overview of the entire Vue framework.","title":"Writing Vue Components"},{"location":"developerdoc/laravel_blade/#using-react","text":"If you prefer to use React to build your JavaScript application, Laravel makes it a cinch to swap the Vue scaffolding with React scaffolding. On any fresh Laravel application, you may use the preset command with the react option: php artisan preset react This single command will remove the Vue scaffolding and replace it with React scaffolding, including an example component.","title":"Using React"},{"location":"developerdoc/laravel_blade/#compiling-assets-laravel-mix","text":"Introduction Laravel Mix provides a fluent API for defining Webpack build steps for your Laravel application using several common CSS and JavaScript pre-processors. Through simple method chaining, you can fluently define your asset pipeline. For example: mix.js('resources/js/app.js', 'public/js') .sass('resources/sass/app.scss', 'public/css'); If you've ever been confused and overwhelmed about getting started with Webpack and asset compilation, you will love Laravel Mix. However, you are not required to use it while developing your application; you are free to use any asset pipeline tool you wish, or even none at all.","title":"Compiling assets (Laravel Mix)"},{"location":"developerdoc/laravel_blade/#installation-setup","text":"","title":"Installation &amp; Setup"},{"location":"developerdoc/laravel_blade/#installing-node","text":"Before triggering Mix, you must first ensure that Node.js and NPM are installed on your machine. node -v npm -v By default, Laravel Homestead includes everything you need; however, if you aren't using Vagrant, then you can easily install the latest version of Node and NPM using simple graphical installers from their download page.","title":"Installing Node"},{"location":"developerdoc/laravel_blade/#laravel-mix","text":"The only remaining step is to install Laravel Mix. Within a fresh installation of Laravel, you'll find a package.json file in the root of your directory structure. The default package.json file includes everything you need to get started. Think of this like your composer.json file, except it defines Node dependencies instead of PHP. You may install the dependencies it references by running: npm install","title":"Laravel Mix"},{"location":"developerdoc/laravel_blade/#running-mix","text":"Mix is a configuration layer on top of Webpack, so to run your Mix tasks you only need to execute one of the NPM scripts that is included with the default Laravel package.json file: // Run all Mix tasks... npm run dev // Run all Mix tasks and minify output... npm run production","title":"Running Mix"},{"location":"developerdoc/laravel_blade/#watching-assets-for-changes","text":"The npm run watch command will continue running in your terminal and watch all relevant files for changes. Webpack will then automatically recompile your assets when it detects a change: npm run watch You may find that in certain environments Webpack isn't updating when your files change. If this is the case on your system, consider using the watch-poll command: npm run watch-poll","title":"Watching Assets For Changes"},{"location":"developerdoc/laravel_blade/#working-with-stylesheets","text":"The webpack.mix.js file is your entry point for all asset compilation. Think of it as a light configuration wrapper around Webpack. Mix tasks can be chained together to define exactly how your assets should be compiled.","title":"Working With Stylesheets"},{"location":"developerdoc/laravel_blade/#less","text":"The less method may be used to compile Less into CSS. Let's compile our primary app.less file to public/css/app.css. mix.less('resources/less/app.less', 'public/css'); Multiple calls to the less method may be used to compile multiple files: mix.less('resources/less/app.less', 'public/css') .less('resources/less/admin.less', 'public/css'); If you wish to customize the file name of the compiled CSS, you may pass a full file path as the second argument to the less method: mix.less('resources/less/app.less', 'public/stylesheets/styles.css'); If you need to override the underlying Less plug-in options, you may pass an object as the third argument to mix.less(): mix.less('resources/less/app.less', 'public/css', { strictMath: true });","title":"Less"},{"location":"developerdoc/laravel_blade/#sass","text":"The sass method allows you to compile Sass into CSS. You may use the method like so: mix.sass('resources/sass/app.scss', 'public/css'); Again, like the less method, you may compile multiple Sass files into their own respective CSS files and even customize the output directory of the resulting CSS: mix.sass('resources/sass/app.sass', 'public/css') .sass('resources/sass/admin.sass', 'public/css/admin'); Additional Node-Sass plug-in options may be provided as the third argument: mix.sass('resources/sass/app.sass', 'public/css', { precision: 5 });","title":"Sass"},{"location":"developerdoc/laravel_blade/#stylus","text":"Similar to Less and Sass, the stylus method allows you to compile Stylus into CSS: mix.stylus('resources/stylus/app.styl', 'public/css'); You may also install additional Stylus plug-ins, such as Rupture. First, install the plug-in in question through NPM (npm install rupture) and then require it in your call to mix.stylus(): mix.stylus('resources/stylus/app.styl', 'public/css', { use: [ require('rupture')() ] });","title":"Stylus"},{"location":"developerdoc/laravel_blade/#postcss","text":"PostCSS, a powerful tool for transforming your CSS, is included with Laravel Mix out of the box. By default, Mix leverages the popular Autoprefixer plug-in to automatically apply all necessary CSS3 vendor prefixes. However, you're free to add any additional plug-ins that are appropriate for your application. First, install the desired plug-in through NPM and then reference it in your webpack.mix.js file: mix.sass('resources/sass/app.scss', 'public/css') .options({ postCss: [ require('postcss-css-variables')() ] });","title":"PostCSS"},{"location":"developerdoc/laravel_blade/#plain-css","text":"If you would just like to concatenate some plain CSS stylesheets into a single file, you may use the styles method. mix.styles([ 'public/css/vendor/normalize.css', 'public/css/vendor/videojs.css' ], 'public/css/all.css');","title":"Plain CSS"},{"location":"developerdoc/laravel_blade/#url-processing","text":"Because Laravel Mix is built on top of Webpack, it's important to understand a few Webpack concepts. For CSS compilation, Webpack will rewrite and optimize any url() calls within your stylesheets. While this might initially sound strange, it's an incredibly powerful piece of functionality. Imagine that we want to compile Sass that includes a relative URL to an image: .example { background: url('../images/example.png'); } Absolute paths for any given url() will be excluded from URL-rewriting. For example, url('/images/thing.png') or url('http://example.com/images/thing.png') won't be modified. By default, Laravel Mix and Webpack will find example.png, copy it to your public/images folder, and then rewrite the url() within your generated stylesheet. As such, your compiled CSS will be: .example { background: url(/images/example.png?d41d8cd98f00b204e9800998ecf8427e); } As useful as this feature may be, it's possible that your existing folder structure is already configured in a way you like. If this is the case, you may disable url() rewriting like so: mix.sass('resources/app/app.scss', 'public/css') .options({ processCssUrls: false }); With this addition to your webpack.mix.js file, Mix will no longer match any url() or copy assets to your public directory. In other words, the compiled CSS will look just like how you originally typed it: .example { background: url(\"../images/thing.png\"); }","title":"URL Processing"},{"location":"developerdoc/laravel_blade/#source-maps","text":"Though disabled by default, source maps may be activated by calling the mix.sourceMaps() method in your webpack.mix.js file. Though it comes with a compile/performance cost, this will provide extra debugging information to your browser's developer tools when using compiled assets. mix.js('resources/js/app.js', 'public/js') .sourceMaps();","title":"Source Maps"},{"location":"developerdoc/laravel_blade/#working-with-javascript","text":"Mix provides several features to help you work with your JavaScript files, such as compiling ECMAScript 2015, module bundling, minification, and concatenating plain JavaScript files. Even better, this all works seamlessly, without requiring an ounce of custom configuration: mix.js('resources/js/app.js', 'public/js'); With this single line of code, you may now take advantage of: * ES2015 syntax. * Modules * Compilation of .vue files. * Minification for production environments.","title":"Working With JavaScript"},{"location":"developerdoc/laravel_blade/#vendor-extraction","text":"One potential downside to bundling all application-specific JavaScript with your vendor libraries is that it makes long-term caching more difficult. For example, a single update to your application code will force the browser to re-download all of your vendor libraries even if they haven't changed. If you intend to make frequent updates to your application's JavaScript, you should consider extracting all of your vendor libraries into their own file. This way, a change to your application code will not affect the caching of your large vendor.js file. Mix's extract method makes this a breeze: mix.js('resources/js/app.js', 'public/js') .extract(['vue']) The extract method accepts an array of all libraries or modules that you wish to extract into a vendor.js file. Using the above snippet as an example, Mix will generate the following files: * public/js/manifest.js: The Webpack manifest runtime * public/js/vendor.js: Your vendor libraries * public/js/app.js: Your application code To avoid JavaScript errors, be sure to load these files in the proper order: <script src=\"/js/manifest.js\"></script> <script src=\"/js/vendor.js\"></script> <script src=\"/js/app.js\"></script>","title":"Vendor Extraction"},{"location":"developerdoc/laravel_blade/#react","text":"Mix can automatically install the Babel plug-ins necessary for React support. To get started, replace your mix.js() call with mix.react(): mix.react('resources/js/app.jsx', 'public/js'); Behind the scenes, Mix will download and include the appropriate babel-preset-react Babel plug-in.","title":"React"},{"location":"developerdoc/laravel_blade/#vanilla-js","text":"Similar to combining stylesheets with mix.styles(), you may also combine and minify any number of JavaScript files with the scripts() method: mix.scripts([ 'public/js/admin.js', 'public/js/dashboard.js' ], 'public/js/all.js'); This option is particularly useful for legacy projects where you don't require Webpack compilation for your JavaScript. A slight variation of mix.scripts() is mix.babel(). Its method signature is identical to scripts; however, the concatenated file will receive Babel compilation, which translates any ES2015 code to vanilla JavaScript that all browsers will understand.","title":"Vanilla JS"},{"location":"developerdoc/laravel_blade/#custom-webpack-configuration","text":"Behind the scenes, Laravel Mix references a pre-configured webpack.config.js file to get you up and running as quickly as possible. Occasionally, you may need to manually modify this file. You might have a special loader or plug-in that needs to be referenced, or maybe you prefer to use Stylus instead of Sass. In such instances, you have two choices: Merging Custom Configuration Mix provides a useful webpackConfig method that allows you to merge any short Webpack configuration overrides. This is a particularly appealing choice, as it doesn't require you to copy and maintain your own copy of the webpack.config.js file. The webpackConfig method accepts an object, which should contain any Webpack-specific configuration that you wish to apply. mix.webpackConfig({ resolve: { modules: [ path.resolve(__dirname, 'vendor/laravel/spark/resources/assets/js') ] } });","title":"Custom Webpack Configuration"},{"location":"developerdoc/laravel_blade/#custom-configuration-files","text":"If you would like to completely customize your Webpack configuration, copy the node_modules/laravel-mix/setup/webpack.config.js file to your project's root directory. Next, point all of the --config references in your package.json file to the newly copied configuration file. If you choose to take this approach to customization, any future upstream updates to Mix's webpack.config.js must be manually merged into your customized file.","title":"Custom Configuration Files"},{"location":"developerdoc/laravel_blade/#copying-files-directories","text":"The copy method may be used to copy files and directories to new locations. This can be useful when a particular asset within your node_modules directory needs to be relocated to your public folder. mix.copy('node_modules/foo/bar.css', 'public/css/bar.css'); When copying a directory, the copy method will flatten the directory's structure. To maintain the directory's original structure, you should use the copyDirectory method instead: mix.copyDirectory('resources/img', 'public/img');","title":"Copying Files &amp; Directories"},{"location":"developerdoc/laravel_blade/#versioning-cache-busting","text":"Many developers suffix their compiled assets with a timestamp or unique token to force browsers to load the fresh assets instead of serving stale copies of the code. Mix can handle this for you using the version method. The version method will automatically append a unique hash to the filenames of all compiled files, allowing for more convenient cache busting: mix.js('resources/js/app.js', 'public/js') .version(); After generating the versioned file, you won't know the exact file name. So, you should use Laravel's global mix function within your views to load the appropriately hashed asset. The mix function will automatically determine the current name of the hashed file: <script src=\"{{ mix('/js/app.js') }}\"></script> Because versioned files are usually unnecessary in development, you may instruct the versioning process to only run during npm run production: mix.js('resources/js/app.js', 'public/js'); if (mix.inProduction()) { mix.version(); }","title":"Versioning / Cache Busting"},{"location":"developerdoc/laravel_blade/#browsersync-reloading","text":"BrowserSync can automatically monitor your files for changes, and inject your changes into the browser without requiring a manual refresh. You may enable support by calling the mix.browserSync() method: mix.browserSync('my-domain.test'); // Or... // https://browsersync.io/docs/options mix.browserSync({ proxy: 'my-domain.test' }); You may pass either a string (proxy) or object (BrowserSync settings) to this method. Next, start Webpack's dev server using the npm run watch command. Now, when you modify a script or PHP file, watch as the browser instantly refreshes the page to reflect your changes.","title":"Browsersync Reloading"},{"location":"developerdoc/laravel_blade/#environment-variables","text":"You may inject environment variables into Mix by prefixing a key in your .env file with MIX_: MIX_SENTRY_DSN_PUBLIC=http://example.com After the variable has been defined in your .env file, you may access via the process.env object. If the value changes while you are running a watch task, you will need to restart the task: process.env.MIX_SENTRY_DSN_PUBLIC","title":"Environment Variables"},{"location":"developerdoc/laravel_blade/#notifications","text":"When available, Mix will automatically display OS notifications for each bundle. This will give you instant feedback, as to whether the compilation was successful or not. However, there may be instances when you'd prefer to disable these notifications. One such example might be triggering Mix on your production server. Notifications may be deactivated, via the disableNotifications method. mix.disableNotifications();","title":"Notifications"},{"location":"developerdoc/laravel_class_testing/","text":"Testing Introduction Laravel is built with testing in mind. In fact, support for testing with PHPUnit is included out of the box and a phpunit.xml file is already set up for your application. The framework also ships with convenient helper methods that allow you to expressively test your applications. By default, your application's tests directory contains two directories: Feature and Unit. Unit tests are tests that focus on a very small, isolated portion of your code. In fact, most unit tests probably focus on a single method. Feature tests may test a larger portion of your code, including how several objects interact with each other or even a full HTTP request to a JSON endpoint. An ExampleTest.php file is provided in both the Feature and Unit test directories. After installing a new Laravel application, run phpunit on the command line to run your tests. Environment When running tests via phpunit, Laravel will automatically set the configuration environment to testing because of the environment variables defined in the phpunit.xml file. Laravel also automatically configures the session and cache to the array driver while testing, meaning no session or cache data will be persisted while testing. You are free to define other testing environment configuration values as necessary. The testing environment variables may be configured in the phpunit.xml file, but make sure to clear your configuration cache using the config:clear Artisan command before running your tests! In addition, you may create a .env.testing file in the root of your project. This file will override the .env file when running PHPUnit tests or executing Artisan commands with the --env=testing option. Creating & Running Tests To create a new test case, use the make:test Artisan command: // Create a test in the Feature directory... php artisan make:test UserTest // Create a test in the Unit directory... php artisan make:test UserTest --unit Once the test has been generated, you may define test methods as you normally would using PHPUnit. To run your tests, execute the phpunit command from your terminal: namespace Tests\\Unit; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; class ExampleTest extends TestCase { /* * A basic test example. * * @return void / public function testBasicTest() { $this->assertTrue(true); } } If you define your own setUp / tearDown methods within a test class, be sure to call the respective parent::setUp() / parent::tearDown() methods on the parent class. HTTP Testing Introduction Laravel provides a very fluent API for making HTTP requests to your application and examining the output. For example, take a look at the test defined below: namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; class ExampleTest extends TestCase { /* * A basic test example. * * @return void / public function testBasicTest() { $response = $this->get('/'); $response->assertStatus(200); } } The get method makes a GET request into the application, while the assertStatus method asserts that the returned response should have the given HTTP status code. In addition to this simple assertion, Laravel also contains a variety of assertions for inspecting the response headers, content, JSON structure, and more. Customizing Request Headers You may use the withHeaders method to customize the request's headers before it is sent to the application. This allows you to add any custom headers you would like to the request: class ExampleTest extends TestCase { /* * A basic functional test example. * * @return void / public function testBasicExample() { $response = $this->withHeaders([ 'X-Header' => 'Value', ])->json('POST', '/user', ['name' => 'Sally']); $response ->assertStatus(201) ->assertJson([ 'created' => true, ]); } } The CSRF middleware is automatically disabled when running tests. Debugging Responses After making a test request to your application, the dump and dumpHeaders methods may be used to examine and debug the response contents: namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; class ExampleTest extends TestCase { /* * A basic test example. * * @return void / public function testBasicTest() { $response = $this->get('/'); $response->dumpHeaders(); $response->dump(); } } Session / Authentication Laravel provides several helpers for working with the session during HTTP testing. First, you may set the session data to a given array using the withSession method. This is useful for loading the session with data before issuing a request to your application: class ExampleTest extends TestCase { public function testApplication() { $response = $this->withSession(['foo' => 'bar']) ->get('/'); } } One common use of the session is for maintaining state for the authenticated user. The actingAs helper method provides a simple way to authenticate a given user as the current user. For example, we may use a model factory to generate and authenticate a user: use App\\User; class ExampleTest extends TestCase { public function testApplication() { $user = factory(User::class)->create(); $response = $this->actingAs($user) ->withSession(['foo' => 'bar']) ->get('/'); } } You may also specify which guard should be used to authenticate the given user by passing the guard name as the second argument to the actingAs method: $this->actingAs($user, 'api') Testing JSON APIs Laravel also provides several helpers for testing JSON APIs and their responses. For example, the json, get, post, put, patch, and delete methods may be used to issue requests with various HTTP verbs. You may also easily pass data and headers to these methods. To get started, let's write a test to make a POST request to /user and assert that the expected data was returned: class ExampleTest extends TestCase { /* * A basic functional test example. * * @return void / public function testBasicExample() { $response = $this->json('POST', '/user', ['name' => 'Sally']); $response ->assertStatus(201) ->assertJson([ 'created' => true, ]); } } The assertJson method converts the response to an array and utilizes PHPUnit::assertArraySubset to verify that the given array exists within the JSON response returned by the application. So, if there are other properties in the JSON response, this test will still pass as long as the given fragment is present. Verifying An Exact JSON Match If you would like to verify that the given array is an exact match for the JSON returned by the application, you should use the assertExactJson method: class ExampleTest extends TestCase { /* * A basic functional test example. * * @return void / public function testBasicExample() { $response = $this->json('POST', '/user', ['name' => 'Sally']); $response ->assertStatus(201) ->assertExactJson([ 'created' => true, ]); } } Testing File Uploads The Illuminate\\Http\\UploadedFile class provides a fake method which may be used to generate dummy files or images for testing. This, combined with the Storage facade's fake method greatly simplifies the testing of file uploads. For example, you may combine these two features to easily test an avatar upload form: namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Http\\UploadedFile; use Illuminate\\Support\\Facades\\Storage; use Illuminate\\Foundation\\Testing\\RefreshDatabase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; class ExampleTest extends TestCase { public function testAvatarUpload() { Storage::fake('avatars'); $file = UploadedFile::fake()->image('avatar.jpg'); $response = $this->json('POST', '/avatar', [ 'avatar' => $file, ]); // Assert the file was stored... Storage::disk('avatars')->assertExists($file->hashName()); // Assert a file does not exist... Storage::disk('avatars')->assertMissing('missing.jpg'); } } Fake File Customization When creating files using the fake method, you may specify the width, height, and size of the image in order to better test your validation rules: UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100); In addition to creating images, you may create files of any other type using the create method: UploadedFile::fake()->create('document.pdf', $sizeInKilobytes); Available Assertions Response Assertions Laravel provides a variety of custom assertion methods for your PHPUnit tests. These assertions may be accessed on the response that is returned from the json, get, post, put, and delete test methods: assertCookie assertCookieExpired assertCookieNotExpired assertCookieMissing assertDontSee assertDontSeeText assertExactJson assertForbidden assertHeader assertHeaderMissing assertJson assertJsonCount assertJsonFragment assertJsonMissing assertJsonMissingExact assertJsonMissingValidationErrors assertJsonStructure assertJsonValidationErrors assertLocation assertNotFound assertOk assertPlainCookie assertRedirect assertSee assertSeeInOrder assertSeeText assertSeeTextInOrder assertSessionHas assertSessionHasAll assertSessionHasErrors assertSessionHasErrorsIn assertSessionHasNoErrors assertSessionDoesntHaveErrors assertSessionMissing assertStatus assertSuccessful assertUnauthorized assertViewHas assertViewHasAll assertViewIs assertViewMissing assertCookie Assert that the response contains the given cookie: $response->assertCookie($cookieName, $value = null); assertCookieExpired Assert that the response contains the given cookie and it is expired: $response->assertCookieExpired($cookieName); assertCookieNotExpired Assert that the response contains the given cookie and it is not expired: $response->assertCookieNotExpired($cookieName); assertCookieMissing Assert that the response does not contains the given cookie: $response->assertCookieMissing($cookieName); assertDontSee Assert that the given string is not contained within the response: $response->assertDontSee($value); assertDontSeeText Assert that the given string is not contained within the response text: $response->assertDontSeeText($value); assertExactJson Assert that the response contains an exact match of the given JSON data: $response->assertExactJson(array $data); assertForbidden Assert that the response has a forbidden status code: $response->assertForbidden(); assertHeader Assert that the given header is present on the response: $response->assertHeader($headerName, $value = null); assertHeaderMissing Assert that the given header is not present on the response: $response->assertHeaderMissing($headerName); assertJson Assert that the response contains the given JSON data: $response->assertJson(array $data); assertJsonCount Assert that the response JSON has an array with the expected number of items at the given key: $response->assertJsonCount($count, $key = null); assertJsonFragment Assert that the response contains the given JSON fragment: $response->assertJsonFragment(array $data); assertJsonMissing Assert that the response does not contain the given JSON fragment: $response->assertJsonMissing(array $data); assertJsonMissingExact Assert that the response does not contain the exact JSON fragment: $response->assertJsonMissingExact(array $data); assertJsonMissingValidationErrors Assert that the response has no JSON validation errors for the given keys: $response->assertJsonMissingValidationErrors($keys); assertJsonStructure Assert that the response has a given JSON structure: $response->assertJsonStructure(array $structure); assertJsonValidationErrors Assert that the response has the given JSON validation errors: $response->assertJsonValidationErrors(array $data); assertLocation Assert that the response has the given URI value in the Location header: $response->assertLocation($uri); assertNotFound Assert that the response has a not found status code: $response->assertNotFound(); assertOk Assert that the response has a 200 status code: $response->assertOk(); assertPlainCookie Assert that the response contains the given cookie (unencrypted): $response->assertPlainCookie($cookieName, $value = null); assertRedirect Assert that the response is a redirect to a given URI: $response->assertRedirect($uri); assertSee Assert that the given string is contained within the response: $response->assertSee($value); assertSeeInOrder Assert that the given strings are contained in order within the response: $response->assertSeeInOrder(array $values); assertSeeText Assert that the given string is contained within the response text: $response->assertSeeText($value); assertSeeTextInOrder Assert that the given strings are contained in order within the response text: $response->assertSeeTextInOrder(array $values); assertSessionHas Assert that the session contains the given piece of data: $response->assertSessionHas($key, $value = null); assertSessionHasAll Assert that the session has a given list of values: $response->assertSessionHasAll(array $data); assertSessionHasErrors Assert that the session contains an error for the given field: $response->assertSessionHasErrors(array $keys, $format = null, $errorBag = 'default'); assertSessionHasErrorsIn Assert that the session has the given errors: $response->assertSessionHasErrorsIn($errorBag, $keys = [], $format = null); assertSessionHasNoErrors Assert that the session has no errors: $response->assertSessionHasNoErrors(); assertSessionDoesntHaveErrors Assert that the session has no errors for the given keys: $response->assertSessionDoesntHaveErrors($keys = [], $format = null, $errorBag = 'default'); assertSessionMissing Assert that the session does not contain the given key: $response->assertSessionMissing($key); assertStatus Assert that the response has a given code: $response->assertStatus($code); assertSuccessful Assert that the response has a successful (200) status code: $response->assertSuccessful(); assertUnauthorized Assert that the response has an unauthorized (401) status code: $response->assertUnauthorized(); assertViewHas Assert that the response view was given a piece of data: $response->assertViewHas($key, $value = null); assertViewHasAll Assert that the response view has a given list of data: $response->assertViewHasAll(array $data); assertViewIs Assert that the given view was returned by the route: $response->assertViewIs($value); assertViewMissing Assert that the response view is missing a piece of bound data: $response->assertViewMissing($key); Authentication Assertions Laravel also provides a variety of authentication related assertions for your PHPUnit tests: Method Description $this->assertAuthenticated($guard = null); Assert that the user is authenticated. $this->assertGuest($guard = null); Assert that the user is not authenticated. $this->assertAuthenticatedAs($user, $guard = null); Assert that the given user is authenticated. $this->assertCredentials(array $credentials, $guard = null); Assert that the given credentials are valid. $this->assertInvalidCredentials(array $credentials, $guard = null); Assert that the given credentials are invalid. Console Test Introduction In addition to simplifying HTTP testing, Laravel provides a simple API for testing console applications that ask for user input. Expecting Input / Output Laravel allows you to easily \"mock\" user input for your console commands using the expectsQuestion method. In addition, you may specify the exit code and text that you expect to be output by the console command using the assertExitCode and expectsOutput methods. For example, consider the following console command: Artisan::command('question', function () { $name = $this->ask('What is your name?'); $language = $this->choice('Which language do you program in?', [ 'PHP', 'Ruby', 'Python', ]); $this->line('Your name is '.$name.' and you program in '.$language.'.'); }); You may test this command with the following test which utilizes the expectsQuestion, expectsOutput, and assertExitCode methods: /* * Test a console command. * * @return void / public function test_console_command() { $this->artisan('question') ->expectsQuestion('What is your name?', 'Taylor Otwell') ->expectsQuestion('Which language do you program in?', 'PHP') ->expectsOutput('Your name is Taylor Otwell and you program in PHP.') ->assertExitCode(0); } Database Testing Introduction Laravel provides a variety of helpful tools to make it easier to test your database driven applications. First, you may use the assertDatabaseHas helper to assert that data exists in the database matching a given set of criteria. For example, if you would like to verify that there is a record in the users table with the email value of sally@example.com, you can do the following: public function testDatabase() { // Make call to application... $this->assertDatabaseHas('users', [ 'email' => 'sally@example.com' ]); } You can also use the assertDatabaseMissing helper to assert that data does not exist in the database. The assertDatabaseHas method and other helpers like it are for convenience. You are free to use any of PHPUnit's built-in assertion methods to supplement your tests. Generating Factories To create a factory, use the make:factory Artisan command: php artisan make:factory PostFactory The new factory will be placed in your database/factories directory. The --model option may be used to indicate the name of the model created by the factory. This option will pre-fill the generated factory file with the given model: php artisan make:factory PostFactory --model=Post Resetting The Database After Each Test It is often useful to reset your database after each test so that data from a previous test does not interfere with subsequent tests. The RefreshDatabase trait takes the most optimal approach to migrating your test database depending on if you are using an in-memory database or a traditional database. Use the trait on your test class and everything will be handled for you: namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; class ExampleTest extends TestCase { use RefreshDatabase; /** * A basic functional test example. * * @return void */ public function testBasicExample() { $response = $this->get('/'); // ... } } Writing Factories When testing, you may need to insert a few records into your database before executing your test. Instead of manually specifying the value of each column when you create this test data, Laravel allows you to define a default set of attributes for each of your Eloquent models using model factories. To get started, take a look at the database/factories/UserFactory.php file in your application. Out of the box, this file contains one factory definition: use Illuminate\\Support\\Str; use Faker\\Generator as Faker; $factory->define(App\\User::class, function (Faker $faker) { return [ 'name' => $faker->name, 'email' => $faker->unique()->safeEmail, 'email_verified_at' => now(), 'password' => '$2y$10$TKh8H1.PfQx37YgCzwiKb.KjNyWgaHb9cbcoQgdIVFlYg7B77UdFm', // secret 'remember_token' => Str::random(10), ]; }); Within the Closure, which serves as the factory definition, you may return the default test values of all attributes on the model. The Closure will receive an instance of the Faker PHP library, which allows you to conveniently generate various kinds of random data for testing. You may also create additional factory files for each model for better organization. For example, you could create UserFactory.php and CommentFactory.php files within your database/factories directory. All of the files within the factories directory will automatically be loaded by Laravel. You can set the Faker locale by adding a faker_locale option to your config/app.php configuration file. Factory States States allow you to define discrete modifications that can be applied to your model factories in any combination. For example, your User model might have a delinquent state that modifies one of its default attribute values. You may define your state transformations using the state method. For simple states, you may pass an array of attribute modifications: $factory->state(App\\User::class, 'delinquent', [ 'account_status' => 'delinquent', ]); If your state requires calculation or a $faker instance, you may use a Closure to calculate the state's attribute modifications: $factory->state(App\\User::class, 'address', function ($faker) { return [ 'address' => $faker->address, ]; }); Factory Callbacks Factory callbacks are registered using the afterMaking and afterCreating methods, and allow you to perform additional tasks after making or creating a model. For example, you may use callbacks to relate additional models to the created model: $factory->afterMaking(App\\User::class, function ($user, $faker) { // ... }); $factory->afterCreating(App\\User::class, function ($user, $faker) { $user->accounts()->save(factory(App\\Account::class)->make()); }); You may also define callbacks for factory states: $factory->afterMakingState(App\\User::class, 'delinquent', function ($user, $faker) { // ... }); $factory->afterCreatingState(App\\User::class, 'delinquent', function ($user, $faker) { // ... }); Using Factories Creating Models Once you have defined your factories, you may use the global factory function in your tests or seed files to generate model instances. So, let's take a look at a few examples of creating models. First, we'll use the make method to create models but not save them to the database: public function testDatabase() { $user = factory(App\\User::class)->make(); // Use model in tests... } You may also create a Collection of many models or create models of a given type: // Create three App\\User instances... $users = factory(App\\User::class, 3)->make(); Applying States You may also apply any of your states to the models. If you would like to apply multiple state transformations to the models, you should specify the name of each state you would like to apply: $users = factory(App\\User::class, 5)->states('delinquent')->make(); $users = factory(App\\User::class, 5)->states('premium', 'delinquent')->make(); Overriding Attributes If you would like to override some of the default values of your models, you may pass an array of values to the make method. Only the specified values will be replaced while the rest of the values remain set to their default values as specified by the factory: $user = factory(App\\User::class)->make([ 'name' => 'Abigail', ]); Persisting Models The create method not only creates the model instances but also saves them to the database using Eloquent's save method: public function testDatabase() { // Create a single App\\User instance... $user = factory(App\\User::class)->create(); // Create three App\\User instances... $users = factory(App\\User::class, 3)->create(); // Use model in tests... } You may override attributes on the model by passing an array to the create method: $user = factory(App\\User::class)->create([ 'name' => 'Abigail', ]); Relationships In this example, we'll attach a relation to some created models. When using the create method to create multiple models, an Eloquent collection instance is returned, allowing you to use any of the convenient functions provided by the collection, such as each: $users = factory(App\\User::class, 3) ->create() ->each(function ($user) { $user->posts()->save(factory(App\\Post::class)->make()); }); Relations & Attribute Closures You may also attach relationships to models using Closure attributes in your factory definitions. For example, if you would like to create a new User instance when creating a Post, you may do the following: $factory->define(App\\Post::class, function ($faker) { return [ 'title' => $faker->title, 'content' => $faker->paragraph, 'user_id' => function () { return factory(App\\User::class)->create()->id; } ]; }); These Closures also receive the evaluated attribute array of the factory that defines them: $factory->define(App\\Post::class, function ($faker) { return [ 'title' => $faker->title, 'content' => $faker->paragraph, 'user_id' => function () { return factory(App\\User::class)->create()->id; }, 'user_type' => function (array $post) { return App\\User::find($post['user_id'])->type; } ]; }); Available Assertions Laravel provides several database assertions for your PHPUnit tests: Method Description $this->assertDatabaseHas($table, array $data); Assert that a table in the database contains the given data. $this->assertDatabaseMissing($table, array $data); Assert that a table in the database does not contain the given data. $this->assertSoftDeleted($table, array $data); Assert that the given record has been soft deleted.","title":"Laravel Class Testing"},{"location":"developerdoc/laravel_class_testing/#testing","text":"Introduction Laravel is built with testing in mind. In fact, support for testing with PHPUnit is included out of the box and a phpunit.xml file is already set up for your application. The framework also ships with convenient helper methods that allow you to expressively test your applications. By default, your application's tests directory contains two directories: Feature and Unit. Unit tests are tests that focus on a very small, isolated portion of your code. In fact, most unit tests probably focus on a single method. Feature tests may test a larger portion of your code, including how several objects interact with each other or even a full HTTP request to a JSON endpoint. An ExampleTest.php file is provided in both the Feature and Unit test directories. After installing a new Laravel application, run phpunit on the command line to run your tests. Environment When running tests via phpunit, Laravel will automatically set the configuration environment to testing because of the environment variables defined in the phpunit.xml file. Laravel also automatically configures the session and cache to the array driver while testing, meaning no session or cache data will be persisted while testing. You are free to define other testing environment configuration values as necessary. The testing environment variables may be configured in the phpunit.xml file, but make sure to clear your configuration cache using the config:clear Artisan command before running your tests! In addition, you may create a .env.testing file in the root of your project. This file will override the .env file when running PHPUnit tests or executing Artisan commands with the --env=testing option. Creating & Running Tests To create a new test case, use the make:test Artisan command: // Create a test in the Feature directory... php artisan make:test UserTest // Create a test in the Unit directory... php artisan make:test UserTest --unit Once the test has been generated, you may define test methods as you normally would using PHPUnit. To run your tests, execute the phpunit command from your terminal: namespace Tests\\Unit; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; class ExampleTest extends TestCase { /* * A basic test example. * * @return void / public function testBasicTest() { $this->assertTrue(true); } } If you define your own setUp / tearDown methods within a test class, be sure to call the respective parent::setUp() / parent::tearDown() methods on the parent class.","title":"Testing"},{"location":"developerdoc/laravel_class_testing/#http-testing","text":"Introduction Laravel provides a very fluent API for making HTTP requests to your application and examining the output. For example, take a look at the test defined below: namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; class ExampleTest extends TestCase { /* * A basic test example. * * @return void / public function testBasicTest() { $response = $this->get('/'); $response->assertStatus(200); } } The get method makes a GET request into the application, while the assertStatus method asserts that the returned response should have the given HTTP status code. In addition to this simple assertion, Laravel also contains a variety of assertions for inspecting the response headers, content, JSON structure, and more. Customizing Request Headers You may use the withHeaders method to customize the request's headers before it is sent to the application. This allows you to add any custom headers you would like to the request: class ExampleTest extends TestCase { /* * A basic functional test example. * * @return void / public function testBasicExample() { $response = $this->withHeaders([ 'X-Header' => 'Value', ])->json('POST', '/user', ['name' => 'Sally']); $response ->assertStatus(201) ->assertJson([ 'created' => true, ]); } } The CSRF middleware is automatically disabled when running tests. Debugging Responses After making a test request to your application, the dump and dumpHeaders methods may be used to examine and debug the response contents: namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; class ExampleTest extends TestCase { /* * A basic test example. * * @return void / public function testBasicTest() { $response = $this->get('/'); $response->dumpHeaders(); $response->dump(); } } Session / Authentication Laravel provides several helpers for working with the session during HTTP testing. First, you may set the session data to a given array using the withSession method. This is useful for loading the session with data before issuing a request to your application: class ExampleTest extends TestCase { public function testApplication() { $response = $this->withSession(['foo' => 'bar']) ->get('/'); } } One common use of the session is for maintaining state for the authenticated user. The actingAs helper method provides a simple way to authenticate a given user as the current user. For example, we may use a model factory to generate and authenticate a user: use App\\User; class ExampleTest extends TestCase { public function testApplication() { $user = factory(User::class)->create(); $response = $this->actingAs($user) ->withSession(['foo' => 'bar']) ->get('/'); } } You may also specify which guard should be used to authenticate the given user by passing the guard name as the second argument to the actingAs method: $this->actingAs($user, 'api') Testing JSON APIs Laravel also provides several helpers for testing JSON APIs and their responses. For example, the json, get, post, put, patch, and delete methods may be used to issue requests with various HTTP verbs. You may also easily pass data and headers to these methods. To get started, let's write a test to make a POST request to /user and assert that the expected data was returned: class ExampleTest extends TestCase { /* * A basic functional test example. * * @return void / public function testBasicExample() { $response = $this->json('POST', '/user', ['name' => 'Sally']); $response ->assertStatus(201) ->assertJson([ 'created' => true, ]); } } The assertJson method converts the response to an array and utilizes PHPUnit::assertArraySubset to verify that the given array exists within the JSON response returned by the application. So, if there are other properties in the JSON response, this test will still pass as long as the given fragment is present. Verifying An Exact JSON Match If you would like to verify that the given array is an exact match for the JSON returned by the application, you should use the assertExactJson method: class ExampleTest extends TestCase { /* * A basic functional test example. * * @return void / public function testBasicExample() { $response = $this->json('POST', '/user', ['name' => 'Sally']); $response ->assertStatus(201) ->assertExactJson([ 'created' => true, ]); } } Testing File Uploads The Illuminate\\Http\\UploadedFile class provides a fake method which may be used to generate dummy files or images for testing. This, combined with the Storage facade's fake method greatly simplifies the testing of file uploads. For example, you may combine these two features to easily test an avatar upload form: namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Http\\UploadedFile; use Illuminate\\Support\\Facades\\Storage; use Illuminate\\Foundation\\Testing\\RefreshDatabase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; class ExampleTest extends TestCase { public function testAvatarUpload() { Storage::fake('avatars'); $file = UploadedFile::fake()->image('avatar.jpg'); $response = $this->json('POST', '/avatar', [ 'avatar' => $file, ]); // Assert the file was stored... Storage::disk('avatars')->assertExists($file->hashName()); // Assert a file does not exist... Storage::disk('avatars')->assertMissing('missing.jpg'); } } Fake File Customization When creating files using the fake method, you may specify the width, height, and size of the image in order to better test your validation rules: UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100); In addition to creating images, you may create files of any other type using the create method: UploadedFile::fake()->create('document.pdf', $sizeInKilobytes); Available Assertions Response Assertions Laravel provides a variety of custom assertion methods for your PHPUnit tests. These assertions may be accessed on the response that is returned from the json, get, post, put, and delete test methods: assertCookie assertCookieExpired assertCookieNotExpired assertCookieMissing assertDontSee assertDontSeeText assertExactJson assertForbidden assertHeader assertHeaderMissing assertJson assertJsonCount assertJsonFragment assertJsonMissing assertJsonMissingExact assertJsonMissingValidationErrors assertJsonStructure assertJsonValidationErrors assertLocation assertNotFound assertOk assertPlainCookie assertRedirect assertSee assertSeeInOrder assertSeeText assertSeeTextInOrder assertSessionHas assertSessionHasAll assertSessionHasErrors assertSessionHasErrorsIn assertSessionHasNoErrors assertSessionDoesntHaveErrors assertSessionMissing assertStatus assertSuccessful assertUnauthorized assertViewHas assertViewHasAll assertViewIs assertViewMissing assertCookie Assert that the response contains the given cookie: $response->assertCookie($cookieName, $value = null); assertCookieExpired Assert that the response contains the given cookie and it is expired: $response->assertCookieExpired($cookieName); assertCookieNotExpired Assert that the response contains the given cookie and it is not expired: $response->assertCookieNotExpired($cookieName); assertCookieMissing Assert that the response does not contains the given cookie: $response->assertCookieMissing($cookieName); assertDontSee Assert that the given string is not contained within the response: $response->assertDontSee($value); assertDontSeeText Assert that the given string is not contained within the response text: $response->assertDontSeeText($value); assertExactJson Assert that the response contains an exact match of the given JSON data: $response->assertExactJson(array $data); assertForbidden Assert that the response has a forbidden status code: $response->assertForbidden(); assertHeader Assert that the given header is present on the response: $response->assertHeader($headerName, $value = null); assertHeaderMissing Assert that the given header is not present on the response: $response->assertHeaderMissing($headerName); assertJson Assert that the response contains the given JSON data: $response->assertJson(array $data); assertJsonCount Assert that the response JSON has an array with the expected number of items at the given key: $response->assertJsonCount($count, $key = null); assertJsonFragment Assert that the response contains the given JSON fragment: $response->assertJsonFragment(array $data); assertJsonMissing Assert that the response does not contain the given JSON fragment: $response->assertJsonMissing(array $data); assertJsonMissingExact Assert that the response does not contain the exact JSON fragment: $response->assertJsonMissingExact(array $data); assertJsonMissingValidationErrors Assert that the response has no JSON validation errors for the given keys: $response->assertJsonMissingValidationErrors($keys); assertJsonStructure Assert that the response has a given JSON structure: $response->assertJsonStructure(array $structure); assertJsonValidationErrors Assert that the response has the given JSON validation errors: $response->assertJsonValidationErrors(array $data); assertLocation Assert that the response has the given URI value in the Location header: $response->assertLocation($uri); assertNotFound Assert that the response has a not found status code: $response->assertNotFound(); assertOk Assert that the response has a 200 status code: $response->assertOk(); assertPlainCookie Assert that the response contains the given cookie (unencrypted): $response->assertPlainCookie($cookieName, $value = null); assertRedirect Assert that the response is a redirect to a given URI: $response->assertRedirect($uri); assertSee Assert that the given string is contained within the response: $response->assertSee($value); assertSeeInOrder Assert that the given strings are contained in order within the response: $response->assertSeeInOrder(array $values); assertSeeText Assert that the given string is contained within the response text: $response->assertSeeText($value); assertSeeTextInOrder Assert that the given strings are contained in order within the response text: $response->assertSeeTextInOrder(array $values); assertSessionHas Assert that the session contains the given piece of data: $response->assertSessionHas($key, $value = null); assertSessionHasAll Assert that the session has a given list of values: $response->assertSessionHasAll(array $data); assertSessionHasErrors Assert that the session contains an error for the given field: $response->assertSessionHasErrors(array $keys, $format = null, $errorBag = 'default'); assertSessionHasErrorsIn Assert that the session has the given errors: $response->assertSessionHasErrorsIn($errorBag, $keys = [], $format = null); assertSessionHasNoErrors Assert that the session has no errors: $response->assertSessionHasNoErrors(); assertSessionDoesntHaveErrors Assert that the session has no errors for the given keys: $response->assertSessionDoesntHaveErrors($keys = [], $format = null, $errorBag = 'default'); assertSessionMissing Assert that the session does not contain the given key: $response->assertSessionMissing($key); assertStatus Assert that the response has a given code: $response->assertStatus($code); assertSuccessful Assert that the response has a successful (200) status code: $response->assertSuccessful(); assertUnauthorized Assert that the response has an unauthorized (401) status code: $response->assertUnauthorized(); assertViewHas Assert that the response view was given a piece of data: $response->assertViewHas($key, $value = null); assertViewHasAll Assert that the response view has a given list of data: $response->assertViewHasAll(array $data); assertViewIs Assert that the given view was returned by the route: $response->assertViewIs($value); assertViewMissing Assert that the response view is missing a piece of bound data: $response->assertViewMissing($key); Authentication Assertions Laravel also provides a variety of authentication related assertions for your PHPUnit tests: Method Description $this->assertAuthenticated($guard = null); Assert that the user is authenticated. $this->assertGuest($guard = null); Assert that the user is not authenticated. $this->assertAuthenticatedAs($user, $guard = null); Assert that the given user is authenticated. $this->assertCredentials(array $credentials, $guard = null); Assert that the given credentials are valid. $this->assertInvalidCredentials(array $credentials, $guard = null); Assert that the given credentials are invalid.","title":"HTTP Testing"},{"location":"developerdoc/laravel_class_testing/#console-test","text":"Introduction In addition to simplifying HTTP testing, Laravel provides a simple API for testing console applications that ask for user input. Expecting Input / Output Laravel allows you to easily \"mock\" user input for your console commands using the expectsQuestion method. In addition, you may specify the exit code and text that you expect to be output by the console command using the assertExitCode and expectsOutput methods. For example, consider the following console command: Artisan::command('question', function () { $name = $this->ask('What is your name?'); $language = $this->choice('Which language do you program in?', [ 'PHP', 'Ruby', 'Python', ]); $this->line('Your name is '.$name.' and you program in '.$language.'.'); }); You may test this command with the following test which utilizes the expectsQuestion, expectsOutput, and assertExitCode methods: /* * Test a console command. * * @return void / public function test_console_command() { $this->artisan('question') ->expectsQuestion('What is your name?', 'Taylor Otwell') ->expectsQuestion('Which language do you program in?', 'PHP') ->expectsOutput('Your name is Taylor Otwell and you program in PHP.') ->assertExitCode(0); }","title":"Console Test"},{"location":"developerdoc/laravel_class_testing/#database-testing","text":"Introduction Laravel provides a variety of helpful tools to make it easier to test your database driven applications. First, you may use the assertDatabaseHas helper to assert that data exists in the database matching a given set of criteria. For example, if you would like to verify that there is a record in the users table with the email value of sally@example.com, you can do the following: public function testDatabase() { // Make call to application... $this->assertDatabaseHas('users', [ 'email' => 'sally@example.com' ]); } You can also use the assertDatabaseMissing helper to assert that data does not exist in the database. The assertDatabaseHas method and other helpers like it are for convenience. You are free to use any of PHPUnit's built-in assertion methods to supplement your tests. Generating Factories To create a factory, use the make:factory Artisan command: php artisan make:factory PostFactory The new factory will be placed in your database/factories directory. The --model option may be used to indicate the name of the model created by the factory. This option will pre-fill the generated factory file with the given model: php artisan make:factory PostFactory --model=Post Resetting The Database After Each Test It is often useful to reset your database after each test so that data from a previous test does not interfere with subsequent tests. The RefreshDatabase trait takes the most optimal approach to migrating your test database depending on if you are using an in-memory database or a traditional database. Use the trait on your test class and everything will be handled for you: namespace Tests\\Feature; use Tests\\TestCase; use Illuminate\\Foundation\\Testing\\RefreshDatabase; use Illuminate\\Foundation\\Testing\\WithoutMiddleware; class ExampleTest extends TestCase { use RefreshDatabase; /** * A basic functional test example. * * @return void */ public function testBasicExample() { $response = $this->get('/'); // ... } } Writing Factories When testing, you may need to insert a few records into your database before executing your test. Instead of manually specifying the value of each column when you create this test data, Laravel allows you to define a default set of attributes for each of your Eloquent models using model factories. To get started, take a look at the database/factories/UserFactory.php file in your application. Out of the box, this file contains one factory definition: use Illuminate\\Support\\Str; use Faker\\Generator as Faker; $factory->define(App\\User::class, function (Faker $faker) { return [ 'name' => $faker->name, 'email' => $faker->unique()->safeEmail, 'email_verified_at' => now(), 'password' => '$2y$10$TKh8H1.PfQx37YgCzwiKb.KjNyWgaHb9cbcoQgdIVFlYg7B77UdFm', // secret 'remember_token' => Str::random(10), ]; }); Within the Closure, which serves as the factory definition, you may return the default test values of all attributes on the model. The Closure will receive an instance of the Faker PHP library, which allows you to conveniently generate various kinds of random data for testing. You may also create additional factory files for each model for better organization. For example, you could create UserFactory.php and CommentFactory.php files within your database/factories directory. All of the files within the factories directory will automatically be loaded by Laravel. You can set the Faker locale by adding a faker_locale option to your config/app.php configuration file. Factory States States allow you to define discrete modifications that can be applied to your model factories in any combination. For example, your User model might have a delinquent state that modifies one of its default attribute values. You may define your state transformations using the state method. For simple states, you may pass an array of attribute modifications: $factory->state(App\\User::class, 'delinquent', [ 'account_status' => 'delinquent', ]); If your state requires calculation or a $faker instance, you may use a Closure to calculate the state's attribute modifications: $factory->state(App\\User::class, 'address', function ($faker) { return [ 'address' => $faker->address, ]; }); Factory Callbacks Factory callbacks are registered using the afterMaking and afterCreating methods, and allow you to perform additional tasks after making or creating a model. For example, you may use callbacks to relate additional models to the created model: $factory->afterMaking(App\\User::class, function ($user, $faker) { // ... }); $factory->afterCreating(App\\User::class, function ($user, $faker) { $user->accounts()->save(factory(App\\Account::class)->make()); }); You may also define callbacks for factory states: $factory->afterMakingState(App\\User::class, 'delinquent', function ($user, $faker) { // ... }); $factory->afterCreatingState(App\\User::class, 'delinquent', function ($user, $faker) { // ... }); Using Factories Creating Models Once you have defined your factories, you may use the global factory function in your tests or seed files to generate model instances. So, let's take a look at a few examples of creating models. First, we'll use the make method to create models but not save them to the database: public function testDatabase() { $user = factory(App\\User::class)->make(); // Use model in tests... } You may also create a Collection of many models or create models of a given type: // Create three App\\User instances... $users = factory(App\\User::class, 3)->make(); Applying States You may also apply any of your states to the models. If you would like to apply multiple state transformations to the models, you should specify the name of each state you would like to apply: $users = factory(App\\User::class, 5)->states('delinquent')->make(); $users = factory(App\\User::class, 5)->states('premium', 'delinquent')->make(); Overriding Attributes If you would like to override some of the default values of your models, you may pass an array of values to the make method. Only the specified values will be replaced while the rest of the values remain set to their default values as specified by the factory: $user = factory(App\\User::class)->make([ 'name' => 'Abigail', ]); Persisting Models The create method not only creates the model instances but also saves them to the database using Eloquent's save method: public function testDatabase() { // Create a single App\\User instance... $user = factory(App\\User::class)->create(); // Create three App\\User instances... $users = factory(App\\User::class, 3)->create(); // Use model in tests... } You may override attributes on the model by passing an array to the create method: $user = factory(App\\User::class)->create([ 'name' => 'Abigail', ]); Relationships In this example, we'll attach a relation to some created models. When using the create method to create multiple models, an Eloquent collection instance is returned, allowing you to use any of the convenient functions provided by the collection, such as each: $users = factory(App\\User::class, 3) ->create() ->each(function ($user) { $user->posts()->save(factory(App\\Post::class)->make()); }); Relations & Attribute Closures You may also attach relationships to models using Closure attributes in your factory definitions. For example, if you would like to create a new User instance when creating a Post, you may do the following: $factory->define(App\\Post::class, function ($faker) { return [ 'title' => $faker->title, 'content' => $faker->paragraph, 'user_id' => function () { return factory(App\\User::class)->create()->id; } ]; }); These Closures also receive the evaluated attribute array of the factory that defines them: $factory->define(App\\Post::class, function ($faker) { return [ 'title' => $faker->title, 'content' => $faker->paragraph, 'user_id' => function () { return factory(App\\User::class)->create()->id; }, 'user_type' => function (array $post) { return App\\User::find($post['user_id'])->type; } ]; }); Available Assertions Laravel provides several database assertions for your PHPUnit tests: Method Description $this->assertDatabaseHas($table, array $data); Assert that a table in the database contains the given data. $this->assertDatabaseMissing($table, array $data); Assert that a table in the database does not contain the given data. $this->assertSoftDeleted($table, array $data); Assert that the given record has been soft deleted.","title":"Database Testing"},{"location":"developerdoc/laravel_db_migration/","text":"Introduction Migrations are like version control for your database, allowing your team to easily modify and share the application's database schema. Migrations are typically paired with Laravel's schema builder to easily build your application's database schema. If you have ever had to tell a teammate to manually add a column to their local database schema, you've faced the problem that database migrations solve. The Laravel Schema facade provides database agnostic support for creating and manipulating tables across all of Laravel's supported database systems. Generating Migrations To create a migration, use the make:migration Artisan command: php artisan make:migration create_users_table The new migration will be placed in your database/migrations directory. Each migration file name contains a timestamp which allows Laravel to determine the order of the migrations. The --table and --create options may also be used to indicate the name of the table and whether the migration will be creating a new table. These options pre-fill the generated migration stub file with the specified table: php artisan make:migration create_users_table --create=users php artisan make:migration add_votes_to_users_table --table=users If you would like to specify a custom output path for the generated migration, you may use the --path option when executing the make:migration command. The given path should be relative to your application's base path. Migration Structure A migration class contains two methods: up and down. The up method is used to add new tables, columns, or indexes to your database, while the down method should reverse the operations performed by the up method. Within both of these methods you may use the Laravel schema builder to expressively create and modify tables. To learn about all of the methods available on the Schema builder, check out its documentation. For example, this migration example creates a flights table: use Illuminate\\Support\\Facades\\Schema; use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class CreateFlightsTable extends Migration { /* * Run the migrations. * * @return void / public function up() { Schema::create('flights', function (Blueprint $table) { $table->bigIncrements('id'); $table->string('name'); $table->string('airline'); $table->timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::drop('flights'); } } Running Migrations To run all of your outstanding migrations, execute the migrate Artisan command: php artisan migrate If you are using the Homestead virtual machine, you should run this command from within your virtual machine. Forcing Migrations To Run In Production Some migration operations are destructive, which means they may cause you to lose data. In order to protect you from running these commands against your production database, you will be prompted for confirmation before the commands are executed. To force the commands to run without a prompt, use the --force flag: php artisan migrate --force Rolling Back Migrations To rollback the latest migration operation, you may use the rollback command. This command rolls back the last \"batch\" of migrations, which may include multiple migration files: php artisan migrate:rollback You may rollback a limited number of migrations by providing the step option to the rollback command. For example, the following command will rollback the last five migrations: php artisan migrate:rollback --step=5 The migrate:reset command will roll back all of your application's migrations: php artisan migrate:reset Rollback & Migrate In Single Command The migrate:refresh command will roll back all of your migrations and then execute the migrate command. This command effectively re-creates your entire database: php artisan migrate:refresh // Refresh the database and run all database seeds... php artisan migrate:refresh --seed You may rollback & re-migrate a limited number of migrations by providing the step option to the refresh command. For example, the following command will rollback & re-migrate the last five migrations: php artisan migrate:refresh --step=5 Drop All Tables & Migrate The migrate:fresh command will drop all tables from the database and then execute the migrate command: php artisan migrate:fresh php artisan migrate:fresh --seed Tables Creating Tables To create a new database table, use the create method on the Schema facade. The create method accepts two arguments. The first is the name of the table, while the second is a Closure which receives a Blueprint object that may be used to define the new table: Schema::create('users', function (Blueprint $table) { $table->bigIncrements('id'); }); When creating the table, you may use any of the schema builder's column methods to define the table's columns. Checking For Table / Column Existence You may easily check for the existence of a table or column using the hasTable and hasColumn methods: if (Schema::hasTable('users')) { // } if (Schema::hasColumn('users', 'email')) { // } Database Connection & Table Options If you want to perform a schema operation on a database connection that is not your default connection, use the connection method: Schema::connection('foo')->create('users', function (Blueprint $table) { $table->bigIncrements('id'); }); You may use the following commands on the schema builder to define the table's options: Command Description $table->engine = 'InnoDB'; Specify the table storage engine (MySQL). $table->charset = 'utf8'; Specify a default character set for the table (MySQL). $table->collation = 'utf8_unicode_ci'; Specify a default collation for the table (MySQL). $table->temporary(); Create a temporary table (except SQL Server). Renaming / Dropping Tables To rename an existing database table, use the rename method: Schema::rename($from, $to); To drop an existing table, you may use the drop or dropIfExists methods: Schema::drop('users'); Schema::dropIfExists('users'); Renaming Tables With Foreign Keys Before renaming a table, you should verify that any foreign key constraints on the table have an explicit name in your migration files instead of letting Laravel assign a convention based name. Otherwise, the foreign key constraint name will refer to the old table name. Columns Creating Columns The table method on the Schema facade may be used to update existing tables. Like the create method, the table method accepts two arguments: the name of the table and a Closure that receives a Blueprint instance you may use to add columns to the table: Schema::table('users', function (Blueprint $table) { $table->string('email'); }); Available Column Types The schema builder contains a variety of column types that you may specify when building your tables: Command Description $table->bigIncrements('id'); Auto-incrementing UNSIGNED BIGINT (primary key) equivalent column. $table->bigInteger('votes'); BIGINT equivalent column. $table->binary('data'); BLOB equivalent column. $table->boolean('confirmed'); BOOLEAN equivalent column. $table->char('name', 100); CHAR equivalent column with an optional length. $table->date('created_at'); DATE equivalent column. $table->dateTime('created_at'); DATETIME equivalent column. $table->dateTimeTz('created_at'); DATETIME (with timezone) equivalent column. $table->decimal('amount', 8, 2); DECIMAL equivalent column with a precision (total digits) and scale (decimal digits). $table->double('amount', 8, 2); DOUBLE equivalent column with a precision (total digits) and scale (decimal digits). $table->enum('level', ['easy', 'hard']); ENUM equivalent column. $table->float('amount', 8, 2); FLOAT equivalent column with a precision (total digits) and scale (decimal digits). $table->geometry('positions'); GEOMETRY equivalent column. $table->geometryCollection('positions'); GEOMETRYCOLLECTION equivalent column. $table->increments('id'); Auto-incrementing UNSIGNED INTEGER (primary key) equivalent column. $table->integer('votes'); INTEGER equivalent column. $table->ipAddress('visitor'); IP address equivalent column. $table->json('options'); JSON equivalent column. $table->jsonb('options'); JSONB equivalent column. $table->lineString('positions'); LINESTRING equivalent column. $table->longText('description'); LONGTEXT equivalent column. $table->macAddress('device'); MAC address equivalent column. $table->mediumIncrements('id'); Auto-incrementing UNSIGNED MEDIUMINT (primary key) equivalent column. $table->mediumInteger('votes'); MEDIUMINT equivalent column. $table->mediumText('description'); MEDIUMTEXT equivalent column. $table->morphs('taggable'); Adds taggable_id UNSIGNED BIGINT and taggable_type VARCHAR equivalent columns. $table->multiLineString('positions'); MULTILINESTRING equivalent column. $table->multiPoint('positions'); MULTIPOINT equivalent column. $table->multiPolygon('positions'); MULTIPOLYGON equivalent column. $table->nullableMorphs('taggable'); Adds nullable versions of morphs() columns. $table->nullableTimestamps(); Alias of timestamps() method. $table->point('position'); POINT equivalent column. $table->polygon('positions'); POLYGON equivalent column. $table->rememberToken(); Adds a nullable remember_token VARCHAR(100) equivalent column. $table->set('flavors', ['strawberry', 'vanilla']); SET equivalent column. $table->smallIncrements('id'); Auto-incrementing UNSIGNED SMALLINT (primary key) equivalent column. $table->smallInteger('votes'); SMALLINT equivalent column. $table->softDeletes(); Adds a nullable deleted_at TIMESTAMP equivalent column for soft deletes. $table->softDeletesTz(); Adds a nullable deleted_at TIMESTAMP (with timezone) equivalent column for soft deletes. $table->string('name', 100); VARCHAR equivalent column with a optional length. $table->text('description'); TEXT equivalent column. $table->time('sunrise'); TIME equivalent column. $table->timeTz('sunrise'); TIME (with timezone) equivalent column. $table->timestamp('added_on'); TIMESTAMP equivalent column. $table->timestampTz('added_on'); TIMESTAMP (with timezone) equivalent column. $table->timestamps(); Adds nullable created_at and updated_at TIMESTAMP equivalent columns. $table->timestampsTz(); Adds nullable created_at and updated_at TIMESTAMP (with timezone) equivalent columns. $table->tinyIncrements('id'); Auto-incrementing UNSIGNED TINYINT (primary key) equivalent column. $table->tinyInteger('votes'); TINYINT equivalent column. $table->unsignedBigInteger('votes'); UNSIGNED BIGINT equivalent column. $table->unsignedDecimal('amount', 8, 2); UNSIGNED DECIMAL equivalent column with a precision (total digits) and scale (decimal digits). $table->unsignedInteger('votes'); UNSIGNED INTEGER equivalent column. $table->unsignedMediumInteger('votes'); UNSIGNED MEDIUMINT equivalent column. $table->unsignedSmallInteger('votes'); UNSIGNED SMALLINT equivalent column. $table->unsignedTinyInteger('votes'); UNSIGNED TINYINT equivalent column. $table->uuid('id'); UUID equivalent column. $table->year('birth_year'); YEAR equivalent column. Column Modifiers In addition to the column types listed above, there are several column \"modifiers\" you may use while adding a column to a database table. For example, to make the column \"nullable\", you may use the nullable method: Schema::table('users', function (Blueprint $table) { $table->string('email')->nullable(); }); Below is a list of all the available column modifiers. This list does not include the index modifiers: Modifier Description ->after('column') Place the column \"after\" another column (MySQL) ->autoIncrement() Set INTEGER columns as auto-increment (primary key) ->charset('utf8') Specify a character set for the column (MySQL) ->collation('utf8_unicode_ci') Specify a collation for the column (MySQL/SQL Server) ->comment('my comment') Add a comment to a column (MySQL/PostgreSQL) ->default($value) Specify a \"default\" value for the column ->first() Place the column \"first\" in the table (MySQL) ->nullable($value = true) Allows (by default) NULL values to be inserted into the column ->storedAs($expression) Create a stored generated column (MySQL) ->unsigned() Set INTEGER columns as UNSIGNED (MySQL) ->useCurrent() Set TIMESTAMP columns to use CURRENT_TIMESTAMP as default value ->virtualAs($expression) Create a virtual generated column (MySQL) ->generatedAs($expression) Create an identity column with specified sequence options (PostgreSQL) ->always() Defines the precedence of sequence values over input for an identity column (PostgreSQL) Modifying Columns Prerequisites Before modifying a column, be sure to add the doctrine/dbal dependency to your composer.json file. The Doctrine DBAL library is used to determine the current state of the column and create the SQL queries needed to make the specified adjustments to the column: composer require doctrine/dbal Updating Column Attributes The change method allows you to modify some existing column types to a new type or modify the column's attributes. For example, you may wish to increase the size of a string column. To see the change method in action, let's increase the size of the name column from 25 to 50: Schema::table('users', function (Blueprint $table) { $table->string('name', 50)->change(); }); We could also modify a column to be nullable: Schema::table('users', function (Blueprint $table) { $table->string('name', 50)->nullable()->change(); }); Only the following column types can be \"changed\": bigInteger, binary, boolean, date, dateTime, dateTimeTz, decimal, integer, json, longText, mediumText, smallInteger, string, text, time, unsignedBigInteger, unsignedInteger and unsignedSmallInteger. Renaming Columns To rename a column, you may use the renameColumn method on the Schema builder. Before renaming a column, be sure to add the doctrine/dbal dependency to your composer.json file: Schema::table('users', function (Blueprint $table) { $table->renameColumn('from', 'to'); }); Renaming any column in a table that also has a column of type enum is not currently supported. Dropping Columns To drop a column, use the dropColumn method on the Schema builder. Before dropping columns from a SQLite database, you will need to add the doctrine/dbal dependency to your composer.json file and run the composer update command in your terminal to install the library: Schema::table('users', function (Blueprint $table) { $table->dropColumn('votes'); }); You may drop multiple columns from a table by passing an array of column names to the dropColumn method: Schema::table('users', function (Blueprint $table) { $table->dropColumn(['votes', 'avatar', 'location']); }); Dropping or modifying multiple columns within a single migration while using a SQLite database is not supported. Available Command Aliases Command Description $table->dropMorphs('morphable'); Drop the morphable_id and morphable_type columns. $table->dropRememberToken(); Drop the remember_token column. $table->dropSoftDeletes(); Drop the deleted_at column. $table->dropSoftDeletesTz(); Alias of dropSoftDeletes() method. $table->dropTimestamps(); Drop the created_at and updated_at columns. $table->dropTimestampsTz(); Alias of dropTimestamps() method. Indexes Creating Indexes The schema builder supports several types of indexes. First, let's look at an example that specifies a column's values should be unique. To create the index, we can chain the unique method onto the column definition: $table->string('email')->unique(); Alternatively, you may create the index after defining the column. For example: $table->unique('email'); You may even pass an array of columns to an index method to create a compound (or composite) index: $table->index(['account_id', 'created_at']); Laravel will automatically generate a reasonable index name, but you may pass a second argument to the method to specify the name yourself: $table->unique('email', 'unique_email'); Available Index Types Each index method accepts an optional second argument to specify the name of the index. If omitted, the name will be derived from the names of the table and column(s). Command Description $table->primary('id'); Adds a primary key. $table->primary(['id', 'parent_id']); Adds composite keys. $table->unique('email'); Adds a unique index. $table->index('state'); Adds a plain index. $table->spatialIndex('location'); Adds a spatial index. (except SQLite) Index Lengths & MySQL / MariaDB Laravel uses the utf8mb4 character set by default, which includes support for storing \"emojis\" in the database. If you are running a version of MySQL older than the 5.7.7 release or MariaDB older than the 10.2.2 release, you may need to manually configure the default string length generated by migrations in order for MySQL to create indexes for them. You may configure this by calling the Schema::defaultStringLength method within your AppServiceProvider: use Illuminate\\Support\\Facades\\Schema; /* * Bootstrap any application services. * * @return void / public function boot() { Schema::defaultStringLength(191); } Alternatively, you may enable the innodb_large_prefix option for your database. Refer to your database's documentation for instructions on how to properly enable this option. Renaming Indexes To rename an index, you may use the renameIndex method. This method accepts the current index name as its first argument and the desired name as its second argument: $table->renameIndex('from', 'to') Dropping Indexes To drop an index, you must specify the index's name. By default, Laravel automatically assigns a reasonable name to the indexes. Concatenate the table name, the name of the indexed column, and the index type. Here are some examples: Command Description $table->dropPrimary('users_id_primary'); Drop a primary key from the \"users\" table. $table->dropUnique('users_email_unique'); Drop a unique index from the \"users\" table. $table->dropIndex('geo_state_index'); Drop a basic index from the \"geo\" table. $table->dropSpatialIndex('geo_location_spatialindex'); Drop a spatial index from the \"geo\" table (except SQLite). If you pass an array of columns into a method that drops indexes, the conventional index name will be generated based on the table name, columns and key type: Schema::table('geo', function (Blueprint $table) { $table->dropIndex(['state']); // Drops index 'geo_state_index' }); Foreign Key Constraints Laravel also provides support for creating foreign key constraints, which are used to force referential integrity at the database level. For example, let's define a user_id column on the posts table that references the id column on a users table: Schema::table('posts', function (Blueprint $table) { $table->unsignedBigInteger('user_id'); $table->foreign('user_id')->references('id')->on('users'); }); You may also specify the desired action for the \"on delete\" and \"on update\" properties of the constraint: $table->foreign('user_id') ->references('id')->on('users') ->onDelete('cascade'); To drop a foreign key, you may use the dropForeign method. Foreign key constraints use the same naming convention as indexes. So, we will concatenate the table name and the columns in the constraint then suffix the name with \"_foreign\": $table->dropForeign('posts_user_id_foreign'); Or, you may pass an array value which will automatically use the conventional constraint name when dropping: $table->dropForeign(['user_id']); You may enable or disable foreign key constraints within your migrations by using the following methods: Schema::enableForeignKeyConstraints(); Schema::disableForeignKeyConstraints(); SQLite disables foreign key constraints by default. When using SQLite, make sure to enable foreign key support in your database configuration before attempting to create them in your migrations. Database Seeding Introduction Laravel includes a simple method of seeding your database with test data using seed classes. All seed classes are stored in the database/seeds directory. Seed classes may have any name you wish, but probably should follow some sensible convention, such as UsersTableSeeder, etc. By default, a DatabaseSeeder class is defined for you. From this class, you may use the call method to run other seed classes, allowing you to control the seeding order. Writing Seeders To generate a seeder, execute the make:seeder Artisan command. All seeders generated by the framework will be placed in the database/seeds directory: php artisan make:seeder UsersTableSeeder A seeder class only contains one method by default: run. This method is called when the db:seed Artisan command is executed. Within the run method, you may insert data into your database however you wish. You may use the query builder to manually insert data or you may use Eloquent model factories. Mass assignment protection is automatically disabled during database seeding. As an example, let's modify the default DatabaseSeeder class and add a database insert statement to the run method: use Illuminate\\Support\\Str; use Illuminate\\Database\\Seeder; use Illuminate\\Support\\Facades\\DB; class DatabaseSeeder extends Seeder { /* * Run the database seeds. * * @return void / public function run() { DB::table('users')->insert([ 'name' => Str::random(10), 'email' => Str::random(10).'@gmail.com', 'password' => bcrypt('secret'), ]); } } You may type-hint any dependencies you need within the run method's signature. They will automatically be resolved via the Laravel service container. Using Model Factories Of course, manually specifying the attributes for each model seed is cumbersome. Instead, you can use model factories to conveniently generate large amounts of database records. First, review the model factory documentation to learn how to define your factories. Once you have defined your factories, you may use the factory helper function to insert records into your database. For example, let's create 50 users and attach a relationship to each user: /* * Run the database seeds. * * @return void / public function run() { factory(App\\User::class, 50)->create()->each(function ($user) { $user->posts()->save(factory(App\\Post::class)->make()); }); } Calling Additional Seeders Within the DatabaseSeeder class, you may use the call method to execute additional seed classes. Using the call method allows you to break up your database seeding into multiple files so that no single seeder class becomes overwhelmingly large. Pass the name of the seeder class you wish to run: /* * Run the database seeds. * * @return void / public function run() { $this->call([ UsersTableSeeder::class, PostsTableSeeder::class, CommentsTableSeeder::class, ]); } Running Seeders Once you have written your seeder, you may need to regenerate Composer's autoloader using the dump-autoload command: composer dump-autoload Now you may use the db:seed Artisan command to seed your database. By default, the db:seed command runs the DatabaseSeeder class, which may be used to call other seed classes. However, you may use the --class option to specify a specific seeder class to run individually: php artisan db:seed php artisan db:seed --class=UsersTableSeeder You may also seed your database using the migrate:refresh command, which will also rollback and re-run all of your migrations. This command is useful for completely re-building your database: php artisan migrate:refresh --seed Forcing Seeders To Run In Production Some seeding operations may cause you to alter or lose data. In order to protect you from running seeding commands against your production database, you will be prompted for confirmation before the seeders are executed. To force the seeders to run without a prompt, use the --force flag: php artisan db:seed --force","title":"Laravel Database Migration"},{"location":"developerdoc/laravel_db_migration/#database-seeding","text":"Introduction Laravel includes a simple method of seeding your database with test data using seed classes. All seed classes are stored in the database/seeds directory. Seed classes may have any name you wish, but probably should follow some sensible convention, such as UsersTableSeeder, etc. By default, a DatabaseSeeder class is defined for you. From this class, you may use the call method to run other seed classes, allowing you to control the seeding order. Writing Seeders To generate a seeder, execute the make:seeder Artisan command. All seeders generated by the framework will be placed in the database/seeds directory: php artisan make:seeder UsersTableSeeder A seeder class only contains one method by default: run. This method is called when the db:seed Artisan command is executed. Within the run method, you may insert data into your database however you wish. You may use the query builder to manually insert data or you may use Eloquent model factories. Mass assignment protection is automatically disabled during database seeding. As an example, let's modify the default DatabaseSeeder class and add a database insert statement to the run method: use Illuminate\\Support\\Str; use Illuminate\\Database\\Seeder; use Illuminate\\Support\\Facades\\DB; class DatabaseSeeder extends Seeder { /* * Run the database seeds. * * @return void / public function run() { DB::table('users')->insert([ 'name' => Str::random(10), 'email' => Str::random(10).'@gmail.com', 'password' => bcrypt('secret'), ]); } } You may type-hint any dependencies you need within the run method's signature. They will automatically be resolved via the Laravel service container. Using Model Factories Of course, manually specifying the attributes for each model seed is cumbersome. Instead, you can use model factories to conveniently generate large amounts of database records. First, review the model factory documentation to learn how to define your factories. Once you have defined your factories, you may use the factory helper function to insert records into your database. For example, let's create 50 users and attach a relationship to each user: /* * Run the database seeds. * * @return void / public function run() { factory(App\\User::class, 50)->create()->each(function ($user) { $user->posts()->save(factory(App\\Post::class)->make()); }); } Calling Additional Seeders Within the DatabaseSeeder class, you may use the call method to execute additional seed classes. Using the call method allows you to break up your database seeding into multiple files so that no single seeder class becomes overwhelmingly large. Pass the name of the seeder class you wish to run: /* * Run the database seeds. * * @return void / public function run() { $this->call([ UsersTableSeeder::class, PostsTableSeeder::class, CommentsTableSeeder::class, ]); } Running Seeders Once you have written your seeder, you may need to regenerate Composer's autoloader using the dump-autoload command: composer dump-autoload Now you may use the db:seed Artisan command to seed your database. By default, the db:seed command runs the DatabaseSeeder class, which may be used to call other seed classes. However, you may use the --class option to specify a specific seeder class to run individually: php artisan db:seed php artisan db:seed --class=UsersTableSeeder You may also seed your database using the migrate:refresh command, which will also rollback and re-run all of your migrations. This command is useful for completely re-building your database: php artisan migrate:refresh --seed Forcing Seeders To Run In Production Some seeding operations may cause you to alter or lose data. In order to protect you from running seeding commands against your production database, you will be prompted for confirmation before the seeders are executed. To force the seeders to run without a prompt, use the --force flag: php artisan db:seed --force","title":"Database Seeding"},{"location":"developerdoc/laravel_db_query/","text":"Database Query Using Multiple Database Connections When using multiple connections, you may access each connection via the connection method on the DB facade. The name passed to the connection method should correspond to one of the connections listed in your config/database.php configuration file: $users = DB::connection('foo')->select(...); You may also access the raw, underlying PDO instance using the getPdo method on a connection instance: $pdo = DB::connection()->getPdo(); Running Raw SQL Queries Once you have configured your database connection, you may run queries using the DB facade. The DB facade provides methods for each type of query: select, update, insert, delete, and statement. Running A Select Query To run a basic query, you may use the select method on the DB facade: <?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Facades\\DB; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show a list of all of the application's users. * * @return Response */ public function index() { $users = DB::select('select * from users where active = ?', [1]); return view('user.index', ['users' => $users]); } } The first argument passed to the select method is the raw SQL query, while the second argument is any parameter bindings that need to be bound to the query. Typically, these are the values of the where clause constraints. Parameter binding provides protection against SQL injection. The select method will always return an array of results. Each result within the array will be a PHP stdClass object, allowing you to access the values of the results: foreach ($users as $user) { echo $user->name; } Using Named Bindings Instead of using ? to represent your parameter bindings, you may execute a query using named bindings: $results = DB::select('select * from users where id = :id', ['id' => 1]); Running An Insert Statement To execute an insert statement, you may use the insert method on the DB facade. Like select, this method takes the raw SQL query as its first argument and bindings as its second argument: DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']); Running An Update Statement The update method should be used to update existing records in the database. The number of rows affected by the statement will be returned: $affected = DB::update('update users set votes = 100 where name = ?', ['John']); Running A Delete Statement The delete method should be used to delete records from the database. Like update, the number of rows affected will be returned: $deleted = DB::delete('delete from users'); Running A General Statement Some database statements do not return any value. For these types of operations, you may use the statement method on the DB facade: DB::statement('drop table users'); Listening For Query Events If you would like to receive each SQL query executed by your application, you may use the listen method. This method is useful for logging queries or debugging. You may register your query listener in a service provider: <?php namespace App\\Providers; use Illuminate\\Support\\Facades\\DB; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Register any application services. * * @return void */ public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { DB::listen(function ($query) { // $query->sql // $query->bindings // $query->time }); } } Database Transactions You may use the transaction method on the DB facade to run a set of operations within a database transaction. If an exception is thrown within the transaction Closure, the transaction will automatically be rolled back. If the Closure executes successfully, the transaction will automatically be committed. You don't need to worry about manually rolling back or committing while using the transaction method: DB::transaction(function () { DB::table('users')->update(['votes' => 1]); DB::table('posts')->delete(); }); Handling Deadlocks The transaction method accepts an optional second argument which defines the number of times a transaction should be reattempted when a deadlock occurs. Once these attempts have been exhausted, an exception will be thrown: DB::transaction(function () { DB::table('users')->update(['votes' => 1]); DB::table('posts')->delete(); }, 5); Manually Using Transactions If you would like to begin a transaction manually and have complete control over rollbacks and commits, you may use the beginTransaction method on the DB facade: DB::beginTransaction(); You can rollback the transaction via the rollBack method: DB::rollBack(); Lastly, you can commit a transaction via the commit method: DB::commit(); The DB facade's transaction methods control the transactions for both the query builder and Eloquent ORM. Retrieving Results Retrieving All Rows From A Table You may use the table method on the DB facade to begin a query. The table method returns a fluent query builder instance for the given table, allowing you to chain more constraints onto the query and then finally get the results using the get method: <?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Facades\\DB; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show a list of all of the application's users. * * @return Response */ public function index() { $users = DB::table('users')->get(); return view('user.index', ['users' => $users]); } } The get method returns an Illuminate\\Support\\Collection containing the results where each result is an instance of the PHP stdClass object. You may access each column's value by accessing the column as a property of the object: foreach ($users as $user) { echo $user->name; } Retrieving A Single Row / Column From A Table If you just need to retrieve a single row from the database table, you may use the first method. This method will return a single stdClass object: $user = DB::table('users')->where('name', 'John')->first(); echo $user->name; If you don't even need an entire row, you may extract a single value from a record using the value method. This method will return the value of the column directly: $email = DB::table('users')->where('name', 'John')->value('email'); To retrieve a single row by its id column value, use the find method: $user = DB::table('users')->find(3); Retrieving A List Of Column Values If you would like to retrieve a Collection containing the values of a single column, you may use the pluck method. In this example, we'll retrieve a Collection of role titles: $titles = DB::table('roles')->pluck('title'); foreach ($titles as $title) { echo $title; } You may also specify a custom key column for the returned Collection: $roles = DB::table('roles')->pluck('title', 'name'); foreach ($roles as $name => $title) { echo $title; } Chunking Results If you need to work with thousands of database records, consider using the chunk method. This method retrieves a small chunk of the results at a time and feeds each chunk into a Closure for processing. This method is very useful for writing Artisan commands that process thousands of records. For example, let's work with the entire users table in chunks of 100 records at a time: DB::table('users')->orderBy('id')->chunk(100, function ($users) { foreach ($users as $user) { // } }); You may stop further chunks from being processed by returning false from the Closure: DB::table('users')->orderBy('id')->chunk(100, function ($users) { // Process the records... return false; }); If you are updating database records while chunking results, your chunk results could change in unexpected ways. So, when updating records while chunking, it is always best to use the chunkById method instead. This method will automatically paginate the results based on the record's primary key: DB::table('users')->where('active', false) ->chunkById(100, function ($users) { foreach ($users as $user) { DB::table('users') ->where('id', $user->id) ->update(['active' => true]); } }); When updating or deleting records inside the chunk callback, any changes to the primary key or foreign keys could affect the chunk query. This could potentially result in records not being included in the chunked results. Aggregates The query builder also provides a variety of aggregate methods such as count, max, min, avg, and sum. You may call any of these methods after constructing your query: $users = DB::table('users')->count(); $price = DB::table('orders')->max('price'); You may combine these methods with other clauses: $price = DB::table('orders') ->where('finalized', 1) ->avg('price'); Determining If Records Exist Instead of using the count method to determine if any records exist that match your query's constraints, you may use the exists and doesntExist methods: return DB::table('orders')->where('finalized', 1)->exists(); return DB::table('orders')->where('finalized', 1)->doesntExist(); Selects Specifying A Select Clause You may not always want to select all columns from a database table. Using the select method, you can specify a custom select clause for the query: $users = DB::table('users')->select('name', 'email as user_email')->get(); The distinct method allows you to force the query to return distinct results: $users = DB::table('users')->distinct()->get(); If you already have a query builder instance and you wish to add a column to its existing select clause, you may use the addSelect method: $query = DB::table('users')->select('name'); $users = $query->addSelect('age')->get(); Raw Expressions Sometimes you may need to use a raw expression in a query. To create a raw expression, you may use the DB::raw method: $users = DB::table('users') ->select(DB::raw('count(*) as user_count, status')) ->where('status', '<>', 1) ->groupBy('status') ->get(); Raw statements will be injected into the query as strings, so you should be extremely careful to not create SQL injection vulnerabilities. Raw Methods Instead of using DB::raw, you may also use the following methods to insert a raw expression into various parts of your query. selectRaw The selectRaw method can be used in place of select(DB::raw(...)). This method accepts an optional array of bindings as its second argument: $orders = DB::table('orders') ->selectRaw('price * ? as price_with_tax', [1.0825]) ->get(); whereRaw / orWhereRaw The whereRaw and orWhereRaw methods can be used to inject a raw where clause into your query. These methods accept an optional array of bindings as their second argument: $orders = DB::table('orders') ->whereRaw('price > IF(state = \"TX\", ?, 100)', [200]) ->get(); havingRaw / orHavingRaw The havingRaw and orHavingRaw methods may be used to set a raw string as the value of the having clause. These methods accept an optional array of bindings as their second argument: $orders = DB::table('orders') ->select('department', DB::raw('SUM(price) as total_sales')) ->groupBy('department') ->havingRaw('SUM(price) > ?', [2500]) ->get(); orderByRaw The orderByRaw method may be used to set a raw string as the value of the order by clause: $orders = DB::table('orders') ->orderByRaw('updated_at - created_at DESC') ->get(); Joins Inner Join Clause The query builder may also be used to write join statements. To perform a basic \"inner join\", you may use the join method on a query builder instance. The first argument passed to the join method is the name of the table you need to join to, while the remaining arguments specify the column constraints for the join. You can even join to multiple tables in a single query: $users = DB::table('users') ->join('contacts', 'users.id', '=', 'contacts.user_id') ->join('orders', 'users.id', '=', 'orders.user_id') ->select('users.*', 'contacts.phone', 'orders.price') ->get(); Left Join / Right Join Clause If you would like to perform a \"left join\" or \"right join\" instead of an \"inner join\", use the leftJoin or rightJoin methods. These methods have the same signature as the join method: $users = DB::table('users') ->leftJoin('posts', 'users.id', '=', 'posts.user_id') ->get(); $users = DB::table('users') ->rightJoin('posts', 'users.id', '=', 'posts.user_id') ->get(); Cross Join Clause To perform a \"cross join\" use the crossJoin method with the name of the table you wish to cross join to. Cross joins generate a cartesian product between the first table and the joined table: $users = DB::table('sizes') ->crossJoin('colours') ->get(); Advanced Join Clauses You may also specify more advanced join clauses. To get started, pass a Closure as the second argument into the join method. The Closure will receive a JoinClause object which allows you to specify constraints on the join clause: DB::table('users') ->join('contacts', function ($join) { $join->on('users.id', '=', 'contacts.user_id')->orOn(...); }) ->get(); If you would like to use a \"where\" style clause on your joins, you may use the where and orWhere methods on a join. Instead of comparing two columns, these methods will compare the column against a value: DB::table('users') ->join('contacts', function ($join) { $join->on('users.id', '=', 'contacts.user_id') ->where('contacts.user_id', '>', 5); }) ->get(); Sub-Query Joins You may use the joinSub, leftJoinSub, and rightJoinSub methods to join a query to a sub-query. Each of these methods receive three arguments: the sub-query, its table alias, and a Closure that defines the related columns: $latestPosts = DB::table('posts') ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at')) ->where('is_published', true) ->groupBy('user_id'); $users = DB::table('users') ->joinSub($latestPosts, 'latest_posts', function ($join) { $join->on('users.id', '=', 'latest_posts.user_id'); })->get(); Unions The query builder also provides a quick way to \"union\" two queries together. For example, you may create an initial query and use the union method to union it with a second query: $first = DB::table('users') ->whereNull('first_name'); $users = DB::table('users') ->whereNull('last_name') ->union($first) ->get(); The unionAll method is also available and has the same method signature as union. Where Clauses Simple Where Clauses You may use the where method on a query builder instance to add where clauses to the query. The most basic call to where requires three arguments. The first argument is the name of the column. The second argument is an operator, which can be any of the database's supported operators. Finally, the third argument is the value to evaluate against the column. For example, here is a query that verifies the value of the \"votes\" column is equal to 100: $users = DB::table('users')->where('votes', '=', 100)->get(); For convenience, if you want to verify that a column is equal to a given value, you may pass the value directly as the second argument to the where method: $users = DB::table('users')->where('votes', 100)->get(); You may use a variety of other operators when writing a where clause: $users = DB::table('users') ->where('votes', '>=', 100) ->get(); $users = DB::table('users') ->where('votes', '<>', 100) ->get(); $users = DB::table('users') ->where('name', 'like', 'T%') ->get(); You may also pass an array of conditions to the where function: $users = DB::table('users')->where([ ['status', '=', '1'], ['subscribed', '<>', '1'], ])->get(); Or Statements You may chain where constraints together as well as add or clauses to the query. The orWhere method accepts the same arguments as the where method: $users = DB::table('users') ->where('votes', '>', 100) ->orWhere('name', 'John') ->get(); Additional Where Clauses whereBetween / orWhereBetween The whereBetween method verifies that a column's value is between two values: $users = DB::table('users') ->whereBetween('votes', [1, 100])->get(); whereNotBetween / orWhereNotBetween The whereNotBetween method verifies that a column's value lies outside of two values: $users = DB::table('users') ->whereNotBetween('votes', [1, 100]) ->get(); whereIn / whereNotIn / orWhereIn / orWhereNotIn The whereIn method verifies that a given column's value is contained within the given array: $users = DB::table('users') ->whereIn('id', [1, 2, 3]) ->get(); The whereNotIn method verifies that the given column's value is not contained in the given array: $users = DB::table('users') ->whereNotIn('id', [1, 2, 3]) ->get(); whereNull / whereNotNull / orWhereNull / orWhereNotNull The whereNull method verifies that the value of the given column is NULL: $users = DB::table('users') ->whereNull('updated_at') ->get(); The whereNotNull method verifies that the column's value is not NULL: $users = DB::table('users') ->whereNotNull('updated_at') ->get(); whereDate / whereMonth / whereDay / whereYear / whereTime The whereDate method may be used to compare a column's value against a date: $users = DB::table('users') ->whereDate('created_at', '2016-12-31') ->get(); The whereMonth method may be used to compare a column's value against a specific month of a year: $users = DB::table('users') ->whereMonth('created_at', '12') ->get(); The whereDay method may be used to compare a column's value against a specific day of a month: $users = DB::table('users') ->whereDay('created_at', '31') ->get(); The whereYear method may be used to compare a column's value against a specific year: $users = DB::table('users') ->whereYear('created_at', '2016') ->get(); The whereTime method may be used to compare a column's value against a specific time: $users = DB::table('users') ->whereTime('created_at', '=', '11:20:45') ->get(); whereColumn / orWhereColumn The whereColumn method may be used to verify that two columns are equal: $users = DB::table('users') ->whereColumn('first_name', 'last_name') ->get(); You may also pass a comparison operator to the method: $users = DB::table('users') ->whereColumn('updated_at', '>', 'created_at') ->get(); The whereColumn method can also be passed an array of multiple conditions. These conditions will be joined using the and operator: $users = DB::table('users') ->whereColumn([ ['first_name', '=', 'last_name'], ['updated_at', '>', 'created_at'] ])->get(); Parameter Grouping Sometimes you may need to create more advanced where clauses such as \"where exists\" clauses or nested parameter groupings. The Laravel query builder can handle these as well. To get started, let's look at an example of grouping constraints within parenthesis: DB::table('users') ->where('name', '=', 'John') ->where(function ($query) { $query->where('votes', '>', 100) ->orWhere('title', '=', 'Admin'); }) ->get(); As you can see, passing a Closure into the where method instructs the query builder to begin a constraint group. The Closure will receive a query builder instance which you can use to set the constraints that should be contained within the parenthesis group. The example above will produce the following SQL: select * from users where name = 'John' and (votes > 100 or title = 'Admin') You should always group orWhere calls in order to avoid unexpected behavior when global scopes are applied. Where Exists Clauses The whereExists method allows you to write where exists SQL clauses. The whereExists method accepts a Closure argument, which will receive a query builder instance allowing you to define the query that should be placed inside of the \"exists\" clause: DB::table('users') ->whereExists(function ($query) { $query->select(DB::raw(1)) ->from('orders') ->whereRaw('orders.user_id = users.id'); }) ->get(); The query above will produce the following SQL: select * from users where exists ( select 1 from orders where orders.user_id = users.id ) JSON Where Clauses Laravel also supports querying JSON column types on databases that provide support for JSON column types. Currently, this includes MySQL 5.7, PostgreSQL, SQL Server 2016, and SQLite 3.9.0 (with the JSON1 extension). To query a JSON column, use the -> operator: $users = DB::table('users') ->where('options->language', 'en') ->get(); $users = DB::table('users') ->where('preferences->dining->meal', 'salad') ->get(); You may use whereJsonContains to query JSON arrays (not supported on SQLite): $users = DB::table('users') ->whereJsonContains('options->languages', 'en') ->get(); MySQL and PostgreSQL support whereJsonContains with multiple values: $users = DB::table('users') ->whereJsonContains('options->languages', ['en', 'de']) ->get(); You may use whereJsonLength to query JSON arrays by their length: $users = DB::table('users') ->whereJsonLength('options->languages', 0) ->get(); $users = DB::table('users') ->whereJsonLength('options->languages', '>', 1) ->get(); Ordering, Grouping, Limit, & Offset orderBy The orderBy method allows you to sort the result of the query by a given column. The first argument to the orderBy method should be the column you wish to sort by, while the second argument controls the direction of the sort and may be either asc or desc: $users = DB::table('users') ->orderBy('name', 'desc') ->get(); latest / oldest The latest and oldest methods allow you to easily order results by date. By default, result will be ordered by the created_at column. Or, you may pass the column name that you wish to sort by: $user = DB::table('users') ->latest() ->first(); inRandomOrder The inRandomOrder method may be used to sort the query results randomly. For example, you may use this method to fetch a random user: $randomUser = DB::table('users') ->inRandomOrder() ->first(); groupBy / having The groupBy and having methods may be used to group the query results. The having method's signature is similar to that of the where method: $users = DB::table('users') ->groupBy('account_id') ->having('account_id', '>', 100) ->get(); You may pass multiple arguments to the groupBy method to group by multiple columns: $users = DB::table('users') ->groupBy('first_name', 'status') ->having('account_id', '>', 100) ->get(); For more advanced having statements, see the havingRaw method. skip / take To limit the number of results returned from the query, or to skip a given number of results in the query, you may use the skip and take methods: $users = DB::table('users')->skip(10)->take(5)->get(); Alternatively, you may use the limit and offset methods: $users = DB::table('users') ->offset(10) ->limit(5) ->get(); Conditional Clauses Sometimes you may want clauses to apply to a query only when something else is true. For instance you may only want to apply a where statement if a given input value is present on the incoming request. You may accomplish this using the when method: $role = $request->input('role'); $users = DB::table('users') ->when($role, function ($query, $role) { return $query->where('role_id', $role); }) ->get(); The when method only executes the given Closure when the first parameter is true. If the first parameter is false, the Closure will not be executed. You may pass another Closure as the third parameter to the when method. This Closure will execute if the first parameter evaluates as false. To illustrate how this feature may be used, we will use it to configure the default sorting of a query: $sortBy = null; $users = DB::table('users') ->when($sortBy, function ($query, $sortBy) { return $query->orderBy($sortBy); }, function ($query) { return $query->orderBy('name'); }) ->get(); Inserts The query builder also provides an insert method for inserting records into the database table. The insert method accepts an array of column names and values: DB::table('users')->insert( ['email' => 'john@example.com', 'votes' => 0] ); You may even insert several records into the table with a single call to insert by passing an array of arrays. Each array represents a row to be inserted into the table: DB::table('users')->insert([ ['email' => 'taylor@example.com', 'votes' => 0], ['email' => 'dayle@example.com', 'votes' => 0] ]); Auto-Incrementing IDs If the table has an auto-incrementing id, use the insertGetId method to insert a record and then retrieve the ID: $id = DB::table('users')->insertGetId( ['email' => 'john@example.com', 'votes' => 0] ); When using PostgreSQL the insertGetId method expects the auto-incrementing column to be named id. If you would like to retrieve the ID from a different \"sequence\", you may pass the column name as the second parameter to the insertGetId method. Updates In addition to inserting records into the database, the query builder can also update existing records using the update method. The update method, like the insert method, accepts an array of column and value pairs containing the columns to be updated. You may constrain the update query using where clauses: DB::table('users') ->where('id', 1) ->update(['votes' => 1]); Update Or Insert Sometimes you may want to update an existing record in the database or create it if no matching record exists. In this scenario, the updateOrInsert method may be used. The updateOrInsert method accepts two arguments: an array of conditions by which to find the record, and an array of column and value pairs containing the columns to be updated. The updateOrInsert method will first attempt to locate a matching database record using the first argument's column and value pairs. If the record exists, it will be updated with the values in the second argument. If the record can not be found, a new record will be inserted with the merged attributes of both arguments: DB::table('users') ->updateOrInsert( ['email' => 'john@example.com', 'name' => 'John'], ['votes' => '2'] ); Updating JSON Columns When updating a JSON column, you should use -> syntax to access the appropriate key in the JSON object. This operation is supported on MySQL 5.7+ and PostgreSQL 9.5+: DB::table('users') ->where('id', 1) ->update(['options->enabled' => true]); Increment & Decrement The query builder also provides convenient methods for incrementing or decrementing the value of a given column. This is a shortcut, providing a more expressive and terse interface compared to manually writing the update statement. Both of these methods accept at least one argument: the column to modify. A second argument may optionally be passed to control the amount by which the column should be incremented or decremented: DB::table('users')->increment('votes'); DB::table('users')->increment('votes', 5); DB::table('users')->decrement('votes'); DB::table('users')->decrement('votes', 5); You may also specify additional columns to update during the operation: DB::table('users')->increment('votes', 1, ['name' => 'John']); Deletes The query builder may also be used to delete records from the table via the delete method. You may constrain delete statements by adding where clauses before calling the delete method: DB::table('users')->delete(); DB::table('users')->where('votes', '>', 100)->delete(); If you wish to truncate the entire table, which will remove all rows and reset the auto-incrementing ID to zero, you may use the truncate method: DB::table('users')->truncate(); Pessimistic Locking The query builder also includes a few functions to help you do \"pessimistic locking\" on your select statements. To run the statement with a \"shared lock\", you may use the sharedLock method on a query. A shared lock prevents the selected rows from being modified until your transaction commits: DB::table('users')->where('votes', '>', 100)->sharedLock()->get(); Alternatively, you may use the lockForUpdate method. A \"for update\" lock prevents the rows from being modified or from being selected with another shared lock: DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get(); Debugging You may use the dd or dump methods while building a query to dump the query bindings and SQL. The dd method will display the debug information and then stop executing the request. The dump method will display the debug information but allow the request to keep executing: DB::table('users')->where('votes', '>', 100)->dd(); DB::table('users')->where('votes', '>', 100)->dump(); Pagination Paginating Query Builder Results There are several ways to paginate items. The simplest is by using the paginate method on the query builder or an Eloquent query. The paginate method automatically takes care of setting the proper limit and offset based on the current page being viewed by the user. By default, the current page is detected by the value of the page query string argument on the HTTP request. This value is automatically detected by Laravel, and is also automatically inserted into links generated by the paginator. In this example, the only argument passed to the paginate method is the number of items you would like displayed \"per page\". In this case, let's specify that we would like to display 15 items per page: <?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Facades\\DB; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show all of the users for the application. * * @return Response */ public function index() { $users = DB::table('users')->paginate(15); return view('user.index', ['users' => $users]); } } Currently, pagination operations that use a groupBy statement cannot be executed efficiently by Laravel. If you need to use a groupBy with a paginated result set, it is recommended that you query the database and create a paginator manually. Simple Pagination If you only need to display simple \"Next\" and \"Previous\" links in your pagination view, you may use the simplePaginate method to perform a more efficient query. This is very useful for large datasets when you do not need to display a link for each page number when rendering your view: $users = DB::table('users')->simplePaginate(15); Paginating Eloquent Results You may also paginate Eloquent queries. In this example, we will paginate the User model with 15 items per page. As you can see, the syntax is nearly identical to paginating query builder results: $users = App\\User::paginate(15); You may call paginate after setting other constraints on the query, such as where clauses: $users = User::where('votes', '>', 100)->paginate(15); You may also use the simplePaginate method when paginating Eloquent models: $users = User::where('votes', '>', 100)->simplePaginate(15); Manually Creating A Paginator Sometimes you may wish to create a pagination instance manually, passing it an array of items. You may do so by creating either an Illuminate\\Pagination\\Paginator or Illuminate\\Pagination\\LengthAwarePaginator instance, depending on your needs. The Paginator class does not need to know the total number of items in the result set; however, because of this, the class does not have methods for retrieving the index of the last page. The LengthAwarePaginator accepts almost the same arguments as the Paginator; however, it does require a count of the total number of items in the result set. In other words, the Paginator corresponds to the simplePaginate method on the query builder and Eloquent, while the LengthAwarePaginator corresponds to the paginate method. When manually creating a paginator instance, you should manually \"slice\" the array of results you pass to the paginator. If you're unsure how to do this, check out the array_slice PHP function. Displaying Pagination Results When calling the paginate method, you will receive an instance of Illuminate\\Pagination\\LengthAwarePaginator . When calling the simplePaginate method, you will receive an instance of Illuminate\\Pagination\\Paginator . These objects provide several methods that describe the result set. In addition to these helpers methods, the paginator instances are iterators and may be looped as an array. So, once you have retrieved the results, you may display the results and render the page links using Blade: <div class=\"container\"> @foreach ($users as $user) {{ $user->name }} @endforeach </div> {{ $users->links() }} The links method will render the links to the rest of the pages in the result set. Each of these links will already contain the proper page query string variable. Remember, the HTML generated by the links method is compatible with the Bootstrap CSS framework. Customizing The Paginator URI The withPath method allows you to customize the URI used by the paginator when generating links. For example, if you want the paginator to generate links like http://example.com/custom/url?page=N, you should pass custom/url to the withPath method: Route::get('users', function () { $users = App\\User::paginate(15); $users->withPath('custom/url'); // }); Appending To Pagination Links You may append to the query string of pagination links using the appends method. For example, to append sort=votes to each pagination link, you should make the following call to appends: {{ $users->appends(['sort' => 'votes'])->links() }} If you wish to append a \"hash fragment\" to the paginator's URLs, you may use the fragment method. For example, to append #foo to the end of each pagination link, make the following call to the fragment method: {{ $users->fragment('foo')->links() }} Adjusting The Pagination Link Window You may control how many additional links are displayed on each side of the paginator's URL \"window\". By default, three links are displayed on each side of the primary paginator links. However, you may control this number using the onEachSide method: {{ $users->onEachSide(5)->links() }} Converting Results To JSON The Laravel paginator result classes implement the Illuminate\\Contracts\\Support\\Jsonable Interface contract and expose the toJson method, so it's very easy to convert your pagination results to JSON. You may also convert a paginator instance to JSON by returning it from a route or controller action: Route::get('users', function () { return App\\User::paginate(); }); The JSON from the paginator will include meta information such as total, current_page, last_page, and more. The actual result objects will be available via the data key in the JSON array. Here is an example of the JSON created by returning a paginator instance from a route: { \"total\": 50, \"per_page\": 15, \"current_page\": 1, \"last_page\": 4, \"first_page_url\": \"http://laravel.app?page=1\", \"last_page_url\": \"http://laravel.app?page=4\", \"next_page_url\": \"http://laravel.app?page=2\", \"prev_page_url\": null, \"path\": \"http://laravel.app\", \"from\": 1, \"to\": 15, \"data\":[ { // Result Object }, { // Result Object } ] } Customizing The Pagination View By default, the views rendered to display the pagination links are compatible with the Bootstrap CSS framework. However, if you are not using Bootstrap, you are free to define your own views to render these links. When calling the links method on a paginator instance, pass the view name as the first argument to the method: {{ $paginator->links('view.name') }} // Passing data to the view... {{ $paginator->links('view.name', ['foo' => 'bar']) }} However, the easiest way to customize the pagination views is by exporting them to your resources/views/vendor directory using the vendor:publish command: php artisan vendor:publish --tag=laravel-pagination This command will place the views in the resources/views/vendor/pagination directory. The bootstrap-4.blade.php file within this directory corresponds to the default pagination view. You may edit this file to modify the pagination HTML. If you would like to designate a different file as the default pagination view, you may use the paginator's defaultView and defaultSimpleView methods within your AppServiceProvider: use Illuminate\\Pagination\\Paginator; public function boot() { Paginator::defaultView('view-name'); Paginator::defaultSimpleView('view-name'); } Paginator Instance Methods Each paginator instance provides additional pagination information via the following methods: Method Description $results->count() Get the number of items for the current page. $results->currentPage() Get the current page number. $results->firstItem() Get the result number of the first item in the results. $results->getOptions() Get the paginator options. $results->getUrlRange($ tart, $end) Create a range of pagination URLs. $results->hasMorePages() Determine if there are enough items to split into multiple pages. $results->items() Get the items for the current page. $results->lastItem() Get the result number of the last item in the results. $results->lastPage() Get the page number of the last available page. (Not available when using simplePaginate). $results->nextPageUrl() Get the URL for the next page. $results->onFirstPage() Determine if the paginator is on the first page. $results->perPage() The number of items to be shown per page. $results->previousPageUrl() Get the URL for the previous page. $results->total() Determine the total number of matching items in the data store. (Not available when using simplePaginate). $results->url($page) Get the URL for a given page number.","title":"Laravel Database Query"},{"location":"developerdoc/laravel_db_query/#database-query","text":"","title":"Database Query"},{"location":"developerdoc/laravel_db_query/#using-multiple-database-connections","text":"When using multiple connections, you may access each connection via the connection method on the DB facade. The name passed to the connection method should correspond to one of the connections listed in your config/database.php configuration file: $users = DB::connection('foo')->select(...); You may also access the raw, underlying PDO instance using the getPdo method on a connection instance: $pdo = DB::connection()->getPdo();","title":"Using Multiple Database Connections"},{"location":"developerdoc/laravel_db_query/#running-raw-sql-queries","text":"Once you have configured your database connection, you may run queries using the DB facade. The DB facade provides methods for each type of query: select, update, insert, delete, and statement.","title":"Running Raw SQL Queries"},{"location":"developerdoc/laravel_db_query/#running-a-select-query","text":"To run a basic query, you may use the select method on the DB facade: <?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Facades\\DB; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show a list of all of the application's users. * * @return Response */ public function index() { $users = DB::select('select * from users where active = ?', [1]); return view('user.index', ['users' => $users]); } } The first argument passed to the select method is the raw SQL query, while the second argument is any parameter bindings that need to be bound to the query. Typically, these are the values of the where clause constraints. Parameter binding provides protection against SQL injection. The select method will always return an array of results. Each result within the array will be a PHP stdClass object, allowing you to access the values of the results: foreach ($users as $user) { echo $user->name; }","title":"Running A Select Query"},{"location":"developerdoc/laravel_db_query/#using-named-bindings","text":"Instead of using ? to represent your parameter bindings, you may execute a query using named bindings: $results = DB::select('select * from users where id = :id', ['id' => 1]);","title":"Using Named Bindings"},{"location":"developerdoc/laravel_db_query/#running-an-insert-statement","text":"To execute an insert statement, you may use the insert method on the DB facade. Like select, this method takes the raw SQL query as its first argument and bindings as its second argument: DB::insert('insert into users (id, name) values (?, ?)', [1, 'Dayle']);","title":"Running An Insert Statement"},{"location":"developerdoc/laravel_db_query/#running-an-update-statement","text":"The update method should be used to update existing records in the database. The number of rows affected by the statement will be returned: $affected = DB::update('update users set votes = 100 where name = ?', ['John']);","title":"Running An Update Statement"},{"location":"developerdoc/laravel_db_query/#running-a-delete-statement","text":"The delete method should be used to delete records from the database. Like update, the number of rows affected will be returned: $deleted = DB::delete('delete from users');","title":"Running A Delete Statement"},{"location":"developerdoc/laravel_db_query/#running-a-general-statement","text":"Some database statements do not return any value. For these types of operations, you may use the statement method on the DB facade: DB::statement('drop table users');","title":"Running A General Statement"},{"location":"developerdoc/laravel_db_query/#listening-for-query-events","text":"If you would like to receive each SQL query executed by your application, you may use the listen method. This method is useful for logging queries or debugging. You may register your query listener in a service provider: <?php namespace App\\Providers; use Illuminate\\Support\\Facades\\DB; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /** * Register any application services. * * @return void */ public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { DB::listen(function ($query) { // $query->sql // $query->bindings // $query->time }); } }","title":"Listening For Query Events"},{"location":"developerdoc/laravel_db_query/#database-transactions","text":"You may use the transaction method on the DB facade to run a set of operations within a database transaction. If an exception is thrown within the transaction Closure, the transaction will automatically be rolled back. If the Closure executes successfully, the transaction will automatically be committed. You don't need to worry about manually rolling back or committing while using the transaction method: DB::transaction(function () { DB::table('users')->update(['votes' => 1]); DB::table('posts')->delete(); });","title":"Database Transactions"},{"location":"developerdoc/laravel_db_query/#handling-deadlocks","text":"The transaction method accepts an optional second argument which defines the number of times a transaction should be reattempted when a deadlock occurs. Once these attempts have been exhausted, an exception will be thrown: DB::transaction(function () { DB::table('users')->update(['votes' => 1]); DB::table('posts')->delete(); }, 5);","title":"Handling Deadlocks"},{"location":"developerdoc/laravel_db_query/#manually-using-transactions","text":"If you would like to begin a transaction manually and have complete control over rollbacks and commits, you may use the beginTransaction method on the DB facade: DB::beginTransaction(); You can rollback the transaction via the rollBack method: DB::rollBack(); Lastly, you can commit a transaction via the commit method: DB::commit(); The DB facade's transaction methods control the transactions for both the query builder and Eloquent ORM.","title":"Manually Using Transactions"},{"location":"developerdoc/laravel_db_query/#retrieving-results","text":"","title":"Retrieving Results"},{"location":"developerdoc/laravel_db_query/#retrieving-all-rows-from-a-table","text":"You may use the table method on the DB facade to begin a query. The table method returns a fluent query builder instance for the given table, allowing you to chain more constraints onto the query and then finally get the results using the get method: <?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Facades\\DB; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show a list of all of the application's users. * * @return Response */ public function index() { $users = DB::table('users')->get(); return view('user.index', ['users' => $users]); } } The get method returns an Illuminate\\Support\\Collection containing the results where each result is an instance of the PHP stdClass object. You may access each column's value by accessing the column as a property of the object: foreach ($users as $user) { echo $user->name; }","title":"Retrieving All Rows From A Table"},{"location":"developerdoc/laravel_db_query/#retrieving-a-single-row-column-from-a-table","text":"If you just need to retrieve a single row from the database table, you may use the first method. This method will return a single stdClass object: $user = DB::table('users')->where('name', 'John')->first(); echo $user->name; If you don't even need an entire row, you may extract a single value from a record using the value method. This method will return the value of the column directly: $email = DB::table('users')->where('name', 'John')->value('email'); To retrieve a single row by its id column value, use the find method: $user = DB::table('users')->find(3);","title":"Retrieving A Single Row / Column From A Table"},{"location":"developerdoc/laravel_db_query/#retrieving-a-list-of-column-values","text":"If you would like to retrieve a Collection containing the values of a single column, you may use the pluck method. In this example, we'll retrieve a Collection of role titles: $titles = DB::table('roles')->pluck('title'); foreach ($titles as $title) { echo $title; } You may also specify a custom key column for the returned Collection: $roles = DB::table('roles')->pluck('title', 'name'); foreach ($roles as $name => $title) { echo $title; }","title":"Retrieving A List Of Column Values"},{"location":"developerdoc/laravel_db_query/#chunking-results","text":"If you need to work with thousands of database records, consider using the chunk method. This method retrieves a small chunk of the results at a time and feeds each chunk into a Closure for processing. This method is very useful for writing Artisan commands that process thousands of records. For example, let's work with the entire users table in chunks of 100 records at a time: DB::table('users')->orderBy('id')->chunk(100, function ($users) { foreach ($users as $user) { // } }); You may stop further chunks from being processed by returning false from the Closure: DB::table('users')->orderBy('id')->chunk(100, function ($users) { // Process the records... return false; }); If you are updating database records while chunking results, your chunk results could change in unexpected ways. So, when updating records while chunking, it is always best to use the chunkById method instead. This method will automatically paginate the results based on the record's primary key: DB::table('users')->where('active', false) ->chunkById(100, function ($users) { foreach ($users as $user) { DB::table('users') ->where('id', $user->id) ->update(['active' => true]); } }); When updating or deleting records inside the chunk callback, any changes to the primary key or foreign keys could affect the chunk query. This could potentially result in records not being included in the chunked results.","title":"Chunking Results"},{"location":"developerdoc/laravel_db_query/#aggregates","text":"The query builder also provides a variety of aggregate methods such as count, max, min, avg, and sum. You may call any of these methods after constructing your query: $users = DB::table('users')->count(); $price = DB::table('orders')->max('price'); You may combine these methods with other clauses: $price = DB::table('orders') ->where('finalized', 1) ->avg('price');","title":"Aggregates"},{"location":"developerdoc/laravel_db_query/#determining-if-records-exist","text":"Instead of using the count method to determine if any records exist that match your query's constraints, you may use the exists and doesntExist methods: return DB::table('orders')->where('finalized', 1)->exists(); return DB::table('orders')->where('finalized', 1)->doesntExist();","title":"Determining If Records Exist"},{"location":"developerdoc/laravel_db_query/#selects","text":"Specifying A Select Clause You may not always want to select all columns from a database table. Using the select method, you can specify a custom select clause for the query: $users = DB::table('users')->select('name', 'email as user_email')->get(); The distinct method allows you to force the query to return distinct results: $users = DB::table('users')->distinct()->get(); If you already have a query builder instance and you wish to add a column to its existing select clause, you may use the addSelect method: $query = DB::table('users')->select('name'); $users = $query->addSelect('age')->get();","title":"Selects"},{"location":"developerdoc/laravel_db_query/#raw-expressions","text":"Sometimes you may need to use a raw expression in a query. To create a raw expression, you may use the DB::raw method: $users = DB::table('users') ->select(DB::raw('count(*) as user_count, status')) ->where('status', '<>', 1) ->groupBy('status') ->get(); Raw statements will be injected into the query as strings, so you should be extremely careful to not create SQL injection vulnerabilities.","title":"Raw Expressions"},{"location":"developerdoc/laravel_db_query/#raw-methods","text":"Instead of using DB::raw, you may also use the following methods to insert a raw expression into various parts of your query.","title":"Raw Methods"},{"location":"developerdoc/laravel_db_query/#selectraw","text":"The selectRaw method can be used in place of select(DB::raw(...)). This method accepts an optional array of bindings as its second argument: $orders = DB::table('orders') ->selectRaw('price * ? as price_with_tax', [1.0825]) ->get();","title":"selectRaw"},{"location":"developerdoc/laravel_db_query/#whereraw-orwhereraw","text":"The whereRaw and orWhereRaw methods can be used to inject a raw where clause into your query. These methods accept an optional array of bindings as their second argument: $orders = DB::table('orders') ->whereRaw('price > IF(state = \"TX\", ?, 100)', [200]) ->get();","title":"whereRaw / orWhereRaw"},{"location":"developerdoc/laravel_db_query/#havingraw-orhavingraw","text":"The havingRaw and orHavingRaw methods may be used to set a raw string as the value of the having clause. These methods accept an optional array of bindings as their second argument: $orders = DB::table('orders') ->select('department', DB::raw('SUM(price) as total_sales')) ->groupBy('department') ->havingRaw('SUM(price) > ?', [2500]) ->get();","title":"havingRaw / orHavingRaw"},{"location":"developerdoc/laravel_db_query/#orderbyraw","text":"The orderByRaw method may be used to set a raw string as the value of the order by clause: $orders = DB::table('orders') ->orderByRaw('updated_at - created_at DESC') ->get();","title":"orderByRaw"},{"location":"developerdoc/laravel_db_query/#joins","text":"Inner Join Clause The query builder may also be used to write join statements. To perform a basic \"inner join\", you may use the join method on a query builder instance. The first argument passed to the join method is the name of the table you need to join to, while the remaining arguments specify the column constraints for the join. You can even join to multiple tables in a single query: $users = DB::table('users') ->join('contacts', 'users.id', '=', 'contacts.user_id') ->join('orders', 'users.id', '=', 'orders.user_id') ->select('users.*', 'contacts.phone', 'orders.price') ->get();","title":"Joins"},{"location":"developerdoc/laravel_db_query/#left-join-right-join-clause","text":"If you would like to perform a \"left join\" or \"right join\" instead of an \"inner join\", use the leftJoin or rightJoin methods. These methods have the same signature as the join method: $users = DB::table('users') ->leftJoin('posts', 'users.id', '=', 'posts.user_id') ->get(); $users = DB::table('users') ->rightJoin('posts', 'users.id', '=', 'posts.user_id') ->get();","title":"Left Join / Right Join Clause"},{"location":"developerdoc/laravel_db_query/#cross-join-clause","text":"To perform a \"cross join\" use the crossJoin method with the name of the table you wish to cross join to. Cross joins generate a cartesian product between the first table and the joined table: $users = DB::table('sizes') ->crossJoin('colours') ->get();","title":"Cross Join Clause"},{"location":"developerdoc/laravel_db_query/#advanced-join-clauses","text":"You may also specify more advanced join clauses. To get started, pass a Closure as the second argument into the join method. The Closure will receive a JoinClause object which allows you to specify constraints on the join clause: DB::table('users') ->join('contacts', function ($join) { $join->on('users.id', '=', 'contacts.user_id')->orOn(...); }) ->get(); If you would like to use a \"where\" style clause on your joins, you may use the where and orWhere methods on a join. Instead of comparing two columns, these methods will compare the column against a value: DB::table('users') ->join('contacts', function ($join) { $join->on('users.id', '=', 'contacts.user_id') ->where('contacts.user_id', '>', 5); }) ->get();","title":"Advanced Join Clauses"},{"location":"developerdoc/laravel_db_query/#sub-query-joins","text":"You may use the joinSub, leftJoinSub, and rightJoinSub methods to join a query to a sub-query. Each of these methods receive three arguments: the sub-query, its table alias, and a Closure that defines the related columns: $latestPosts = DB::table('posts') ->select('user_id', DB::raw('MAX(created_at) as last_post_created_at')) ->where('is_published', true) ->groupBy('user_id'); $users = DB::table('users') ->joinSub($latestPosts, 'latest_posts', function ($join) { $join->on('users.id', '=', 'latest_posts.user_id'); })->get();","title":"Sub-Query Joins"},{"location":"developerdoc/laravel_db_query/#unions","text":"The query builder also provides a quick way to \"union\" two queries together. For example, you may create an initial query and use the union method to union it with a second query: $first = DB::table('users') ->whereNull('first_name'); $users = DB::table('users') ->whereNull('last_name') ->union($first) ->get(); The unionAll method is also available and has the same method signature as union.","title":"Unions"},{"location":"developerdoc/laravel_db_query/#where-clauses","text":"Simple Where Clauses You may use the where method on a query builder instance to add where clauses to the query. The most basic call to where requires three arguments. The first argument is the name of the column. The second argument is an operator, which can be any of the database's supported operators. Finally, the third argument is the value to evaluate against the column. For example, here is a query that verifies the value of the \"votes\" column is equal to 100: $users = DB::table('users')->where('votes', '=', 100)->get(); For convenience, if you want to verify that a column is equal to a given value, you may pass the value directly as the second argument to the where method: $users = DB::table('users')->where('votes', 100)->get(); You may use a variety of other operators when writing a where clause: $users = DB::table('users') ->where('votes', '>=', 100) ->get(); $users = DB::table('users') ->where('votes', '<>', 100) ->get(); $users = DB::table('users') ->where('name', 'like', 'T%') ->get(); You may also pass an array of conditions to the where function: $users = DB::table('users')->where([ ['status', '=', '1'], ['subscribed', '<>', '1'], ])->get();","title":"Where Clauses"},{"location":"developerdoc/laravel_db_query/#or-statements","text":"You may chain where constraints together as well as add or clauses to the query. The orWhere method accepts the same arguments as the where method: $users = DB::table('users') ->where('votes', '>', 100) ->orWhere('name', 'John') ->get();","title":"Or Statements"},{"location":"developerdoc/laravel_db_query/#additional-where-clauses","text":"","title":"Additional Where Clauses"},{"location":"developerdoc/laravel_db_query/#wherebetween-orwherebetween","text":"The whereBetween method verifies that a column's value is between two values: $users = DB::table('users') ->whereBetween('votes', [1, 100])->get();","title":"whereBetween / orWhereBetween"},{"location":"developerdoc/laravel_db_query/#wherenotbetween-orwherenotbetween","text":"The whereNotBetween method verifies that a column's value lies outside of two values: $users = DB::table('users') ->whereNotBetween('votes', [1, 100]) ->get();","title":"whereNotBetween / orWhereNotBetween"},{"location":"developerdoc/laravel_db_query/#wherein-wherenotin-orwherein-orwherenotin","text":"The whereIn method verifies that a given column's value is contained within the given array: $users = DB::table('users') ->whereIn('id', [1, 2, 3]) ->get(); The whereNotIn method verifies that the given column's value is not contained in the given array: $users = DB::table('users') ->whereNotIn('id', [1, 2, 3]) ->get(); whereNull / whereNotNull / orWhereNull / orWhereNotNull The whereNull method verifies that the value of the given column is NULL: $users = DB::table('users') ->whereNull('updated_at') ->get(); The whereNotNull method verifies that the column's value is not NULL: $users = DB::table('users') ->whereNotNull('updated_at') ->get();","title":"whereIn / whereNotIn / orWhereIn / orWhereNotIn"},{"location":"developerdoc/laravel_db_query/#wheredate-wheremonth-whereday-whereyear-wheretime","text":"The whereDate method may be used to compare a column's value against a date: $users = DB::table('users') ->whereDate('created_at', '2016-12-31') ->get(); The whereMonth method may be used to compare a column's value against a specific month of a year: $users = DB::table('users') ->whereMonth('created_at', '12') ->get(); The whereDay method may be used to compare a column's value against a specific day of a month: $users = DB::table('users') ->whereDay('created_at', '31') ->get(); The whereYear method may be used to compare a column's value against a specific year: $users = DB::table('users') ->whereYear('created_at', '2016') ->get(); The whereTime method may be used to compare a column's value against a specific time: $users = DB::table('users') ->whereTime('created_at', '=', '11:20:45') ->get();","title":"whereDate / whereMonth / whereDay / whereYear / whereTime"},{"location":"developerdoc/laravel_db_query/#wherecolumn-orwherecolumn","text":"The whereColumn method may be used to verify that two columns are equal: $users = DB::table('users') ->whereColumn('first_name', 'last_name') ->get(); You may also pass a comparison operator to the method: $users = DB::table('users') ->whereColumn('updated_at', '>', 'created_at') ->get(); The whereColumn method can also be passed an array of multiple conditions. These conditions will be joined using the and operator: $users = DB::table('users') ->whereColumn([ ['first_name', '=', 'last_name'], ['updated_at', '>', 'created_at'] ])->get();","title":"whereColumn / orWhereColumn"},{"location":"developerdoc/laravel_db_query/#parameter-grouping","text":"Sometimes you may need to create more advanced where clauses such as \"where exists\" clauses or nested parameter groupings. The Laravel query builder can handle these as well. To get started, let's look at an example of grouping constraints within parenthesis: DB::table('users') ->where('name', '=', 'John') ->where(function ($query) { $query->where('votes', '>', 100) ->orWhere('title', '=', 'Admin'); }) ->get(); As you can see, passing a Closure into the where method instructs the query builder to begin a constraint group. The Closure will receive a query builder instance which you can use to set the constraints that should be contained within the parenthesis group. The example above will produce the following SQL: select * from users where name = 'John' and (votes > 100 or title = 'Admin') You should always group orWhere calls in order to avoid unexpected behavior when global scopes are applied.","title":"Parameter Grouping"},{"location":"developerdoc/laravel_db_query/#where-exists-clauses","text":"The whereExists method allows you to write where exists SQL clauses. The whereExists method accepts a Closure argument, which will receive a query builder instance allowing you to define the query that should be placed inside of the \"exists\" clause: DB::table('users') ->whereExists(function ($query) { $query->select(DB::raw(1)) ->from('orders') ->whereRaw('orders.user_id = users.id'); }) ->get(); The query above will produce the following SQL: select * from users where exists ( select 1 from orders where orders.user_id = users.id )","title":"Where Exists Clauses"},{"location":"developerdoc/laravel_db_query/#json-where-clauses","text":"Laravel also supports querying JSON column types on databases that provide support for JSON column types. Currently, this includes MySQL 5.7, PostgreSQL, SQL Server 2016, and SQLite 3.9.0 (with the JSON1 extension). To query a JSON column, use the -> operator: $users = DB::table('users') ->where('options->language', 'en') ->get(); $users = DB::table('users') ->where('preferences->dining->meal', 'salad') ->get(); You may use whereJsonContains to query JSON arrays (not supported on SQLite): $users = DB::table('users') ->whereJsonContains('options->languages', 'en') ->get(); MySQL and PostgreSQL support whereJsonContains with multiple values: $users = DB::table('users') ->whereJsonContains('options->languages', ['en', 'de']) ->get(); You may use whereJsonLength to query JSON arrays by their length: $users = DB::table('users') ->whereJsonLength('options->languages', 0) ->get(); $users = DB::table('users') ->whereJsonLength('options->languages', '>', 1) ->get();","title":"JSON Where Clauses"},{"location":"developerdoc/laravel_db_query/#ordering-grouping-limit-offset","text":"","title":"Ordering, Grouping, Limit, &amp; Offset"},{"location":"developerdoc/laravel_db_query/#orderby","text":"The orderBy method allows you to sort the result of the query by a given column. The first argument to the orderBy method should be the column you wish to sort by, while the second argument controls the direction of the sort and may be either asc or desc: $users = DB::table('users') ->orderBy('name', 'desc') ->get();","title":"orderBy"},{"location":"developerdoc/laravel_db_query/#latest-oldest","text":"The latest and oldest methods allow you to easily order results by date. By default, result will be ordered by the created_at column. Or, you may pass the column name that you wish to sort by: $user = DB::table('users') ->latest() ->first();","title":"latest / oldest"},{"location":"developerdoc/laravel_db_query/#inrandomorder","text":"The inRandomOrder method may be used to sort the query results randomly. For example, you may use this method to fetch a random user: $randomUser = DB::table('users') ->inRandomOrder() ->first();","title":"inRandomOrder"},{"location":"developerdoc/laravel_db_query/#groupby-having","text":"The groupBy and having methods may be used to group the query results. The having method's signature is similar to that of the where method: $users = DB::table('users') ->groupBy('account_id') ->having('account_id', '>', 100) ->get(); You may pass multiple arguments to the groupBy method to group by multiple columns: $users = DB::table('users') ->groupBy('first_name', 'status') ->having('account_id', '>', 100) ->get(); For more advanced having statements, see the havingRaw method.","title":"groupBy / having"},{"location":"developerdoc/laravel_db_query/#skip-take","text":"To limit the number of results returned from the query, or to skip a given number of results in the query, you may use the skip and take methods: $users = DB::table('users')->skip(10)->take(5)->get(); Alternatively, you may use the limit and offset methods: $users = DB::table('users') ->offset(10) ->limit(5) ->get();","title":"skip / take"},{"location":"developerdoc/laravel_db_query/#conditional-clauses","text":"Sometimes you may want clauses to apply to a query only when something else is true. For instance you may only want to apply a where statement if a given input value is present on the incoming request. You may accomplish this using the when method: $role = $request->input('role'); $users = DB::table('users') ->when($role, function ($query, $role) { return $query->where('role_id', $role); }) ->get(); The when method only executes the given Closure when the first parameter is true. If the first parameter is false, the Closure will not be executed. You may pass another Closure as the third parameter to the when method. This Closure will execute if the first parameter evaluates as false. To illustrate how this feature may be used, we will use it to configure the default sorting of a query: $sortBy = null; $users = DB::table('users') ->when($sortBy, function ($query, $sortBy) { return $query->orderBy($sortBy); }, function ($query) { return $query->orderBy('name'); }) ->get();","title":"Conditional Clauses"},{"location":"developerdoc/laravel_db_query/#inserts","text":"The query builder also provides an insert method for inserting records into the database table. The insert method accepts an array of column names and values: DB::table('users')->insert( ['email' => 'john@example.com', 'votes' => 0] ); You may even insert several records into the table with a single call to insert by passing an array of arrays. Each array represents a row to be inserted into the table: DB::table('users')->insert([ ['email' => 'taylor@example.com', 'votes' => 0], ['email' => 'dayle@example.com', 'votes' => 0] ]);","title":"Inserts"},{"location":"developerdoc/laravel_db_query/#auto-incrementing-ids","text":"If the table has an auto-incrementing id, use the insertGetId method to insert a record and then retrieve the ID: $id = DB::table('users')->insertGetId( ['email' => 'john@example.com', 'votes' => 0] ); When using PostgreSQL the insertGetId method expects the auto-incrementing column to be named id. If you would like to retrieve the ID from a different \"sequence\", you may pass the column name as the second parameter to the insertGetId method.","title":"Auto-Incrementing IDs"},{"location":"developerdoc/laravel_db_query/#updates","text":"In addition to inserting records into the database, the query builder can also update existing records using the update method. The update method, like the insert method, accepts an array of column and value pairs containing the columns to be updated. You may constrain the update query using where clauses: DB::table('users') ->where('id', 1) ->update(['votes' => 1]);","title":"Updates"},{"location":"developerdoc/laravel_db_query/#update-or-insert","text":"Sometimes you may want to update an existing record in the database or create it if no matching record exists. In this scenario, the updateOrInsert method may be used. The updateOrInsert method accepts two arguments: an array of conditions by which to find the record, and an array of column and value pairs containing the columns to be updated. The updateOrInsert method will first attempt to locate a matching database record using the first argument's column and value pairs. If the record exists, it will be updated with the values in the second argument. If the record can not be found, a new record will be inserted with the merged attributes of both arguments: DB::table('users') ->updateOrInsert( ['email' => 'john@example.com', 'name' => 'John'], ['votes' => '2'] );","title":"Update Or Insert"},{"location":"developerdoc/laravel_db_query/#updating-json-columns","text":"When updating a JSON column, you should use -> syntax to access the appropriate key in the JSON object. This operation is supported on MySQL 5.7+ and PostgreSQL 9.5+: DB::table('users') ->where('id', 1) ->update(['options->enabled' => true]);","title":"Updating JSON Columns"},{"location":"developerdoc/laravel_db_query/#increment-decrement","text":"The query builder also provides convenient methods for incrementing or decrementing the value of a given column. This is a shortcut, providing a more expressive and terse interface compared to manually writing the update statement. Both of these methods accept at least one argument: the column to modify. A second argument may optionally be passed to control the amount by which the column should be incremented or decremented: DB::table('users')->increment('votes'); DB::table('users')->increment('votes', 5); DB::table('users')->decrement('votes'); DB::table('users')->decrement('votes', 5); You may also specify additional columns to update during the operation: DB::table('users')->increment('votes', 1, ['name' => 'John']);","title":"Increment &amp; Decrement"},{"location":"developerdoc/laravel_db_query/#deletes","text":"The query builder may also be used to delete records from the table via the delete method. You may constrain delete statements by adding where clauses before calling the delete method: DB::table('users')->delete(); DB::table('users')->where('votes', '>', 100)->delete(); If you wish to truncate the entire table, which will remove all rows and reset the auto-incrementing ID to zero, you may use the truncate method: DB::table('users')->truncate();","title":"Deletes"},{"location":"developerdoc/laravel_db_query/#pessimistic-locking","text":"The query builder also includes a few functions to help you do \"pessimistic locking\" on your select statements. To run the statement with a \"shared lock\", you may use the sharedLock method on a query. A shared lock prevents the selected rows from being modified until your transaction commits: DB::table('users')->where('votes', '>', 100)->sharedLock()->get(); Alternatively, you may use the lockForUpdate method. A \"for update\" lock prevents the rows from being modified or from being selected with another shared lock: DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();","title":"Pessimistic Locking"},{"location":"developerdoc/laravel_db_query/#debugging","text":"You may use the dd or dump methods while building a query to dump the query bindings and SQL. The dd method will display the debug information and then stop executing the request. The dump method will display the debug information but allow the request to keep executing: DB::table('users')->where('votes', '>', 100)->dd(); DB::table('users')->where('votes', '>', 100)->dump();","title":"Debugging"},{"location":"developerdoc/laravel_db_query/#pagination","text":"","title":"Pagination"},{"location":"developerdoc/laravel_db_query/#paginating-query-builder-results","text":"There are several ways to paginate items. The simplest is by using the paginate method on the query builder or an Eloquent query. The paginate method automatically takes care of setting the proper limit and offset based on the current page being viewed by the user. By default, the current page is detected by the value of the page query string argument on the HTTP request. This value is automatically detected by Laravel, and is also automatically inserted into links generated by the paginator. In this example, the only argument passed to the paginate method is the number of items you would like displayed \"per page\". In this case, let's specify that we would like to display 15 items per page: <?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Facades\\DB; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show all of the users for the application. * * @return Response */ public function index() { $users = DB::table('users')->paginate(15); return view('user.index', ['users' => $users]); } } Currently, pagination operations that use a groupBy statement cannot be executed efficiently by Laravel. If you need to use a groupBy with a paginated result set, it is recommended that you query the database and create a paginator manually.","title":"Paginating Query Builder Results"},{"location":"developerdoc/laravel_db_query/#simple-pagination","text":"If you only need to display simple \"Next\" and \"Previous\" links in your pagination view, you may use the simplePaginate method to perform a more efficient query. This is very useful for large datasets when you do not need to display a link for each page number when rendering your view: $users = DB::table('users')->simplePaginate(15);","title":"Simple Pagination"},{"location":"developerdoc/laravel_db_query/#paginating-eloquent-results","text":"You may also paginate Eloquent queries. In this example, we will paginate the User model with 15 items per page. As you can see, the syntax is nearly identical to paginating query builder results: $users = App\\User::paginate(15); You may call paginate after setting other constraints on the query, such as where clauses: $users = User::where('votes', '>', 100)->paginate(15); You may also use the simplePaginate method when paginating Eloquent models: $users = User::where('votes', '>', 100)->simplePaginate(15);","title":"Paginating Eloquent Results"},{"location":"developerdoc/laravel_db_query/#manually-creating-a-paginator","text":"Sometimes you may wish to create a pagination instance manually, passing it an array of items. You may do so by creating either an Illuminate\\Pagination\\Paginator or Illuminate\\Pagination\\LengthAwarePaginator instance, depending on your needs. The Paginator class does not need to know the total number of items in the result set; however, because of this, the class does not have methods for retrieving the index of the last page. The LengthAwarePaginator accepts almost the same arguments as the Paginator; however, it does require a count of the total number of items in the result set. In other words, the Paginator corresponds to the simplePaginate method on the query builder and Eloquent, while the LengthAwarePaginator corresponds to the paginate method. When manually creating a paginator instance, you should manually \"slice\" the array of results you pass to the paginator. If you're unsure how to do this, check out the array_slice PHP function.","title":"Manually Creating A Paginator"},{"location":"developerdoc/laravel_db_query/#displaying-pagination-results","text":"When calling the paginate method, you will receive an instance of Illuminate\\Pagination\\LengthAwarePaginator . When calling the simplePaginate method, you will receive an instance of Illuminate\\Pagination\\Paginator . These objects provide several methods that describe the result set. In addition to these helpers methods, the paginator instances are iterators and may be looped as an array. So, once you have retrieved the results, you may display the results and render the page links using Blade: <div class=\"container\"> @foreach ($users as $user) {{ $user->name }} @endforeach </div> {{ $users->links() }} The links method will render the links to the rest of the pages in the result set. Each of these links will already contain the proper page query string variable. Remember, the HTML generated by the links method is compatible with the Bootstrap CSS framework.","title":"Displaying Pagination Results"},{"location":"developerdoc/laravel_db_query/#customizing-the-paginator-uri","text":"The withPath method allows you to customize the URI used by the paginator when generating links. For example, if you want the paginator to generate links like http://example.com/custom/url?page=N, you should pass custom/url to the withPath method: Route::get('users', function () { $users = App\\User::paginate(15); $users->withPath('custom/url'); // });","title":"Customizing The Paginator URI"},{"location":"developerdoc/laravel_db_query/#appending-to-pagination-links","text":"You may append to the query string of pagination links using the appends method. For example, to append sort=votes to each pagination link, you should make the following call to appends: {{ $users->appends(['sort' => 'votes'])->links() }} If you wish to append a \"hash fragment\" to the paginator's URLs, you may use the fragment method. For example, to append #foo to the end of each pagination link, make the following call to the fragment method: {{ $users->fragment('foo')->links() }}","title":"Appending To Pagination Links"},{"location":"developerdoc/laravel_db_query/#adjusting-the-pagination-link-window","text":"You may control how many additional links are displayed on each side of the paginator's URL \"window\". By default, three links are displayed on each side of the primary paginator links. However, you may control this number using the onEachSide method: {{ $users->onEachSide(5)->links() }}","title":"Adjusting The Pagination Link Window"},{"location":"developerdoc/laravel_db_query/#converting-results-to-json","text":"The Laravel paginator result classes implement the Illuminate\\Contracts\\Support\\Jsonable Interface contract and expose the toJson method, so it's very easy to convert your pagination results to JSON. You may also convert a paginator instance to JSON by returning it from a route or controller action: Route::get('users', function () { return App\\User::paginate(); }); The JSON from the paginator will include meta information such as total, current_page, last_page, and more. The actual result objects will be available via the data key in the JSON array. Here is an example of the JSON created by returning a paginator instance from a route: { \"total\": 50, \"per_page\": 15, \"current_page\": 1, \"last_page\": 4, \"first_page_url\": \"http://laravel.app?page=1\", \"last_page_url\": \"http://laravel.app?page=4\", \"next_page_url\": \"http://laravel.app?page=2\", \"prev_page_url\": null, \"path\": \"http://laravel.app\", \"from\": 1, \"to\": 15, \"data\":[ { // Result Object }, { // Result Object } ] }","title":"Converting Results To JSON"},{"location":"developerdoc/laravel_db_query/#customizing-the-pagination-view","text":"By default, the views rendered to display the pagination links are compatible with the Bootstrap CSS framework. However, if you are not using Bootstrap, you are free to define your own views to render these links. When calling the links method on a paginator instance, pass the view name as the first argument to the method: {{ $paginator->links('view.name') }} // Passing data to the view... {{ $paginator->links('view.name', ['foo' => 'bar']) }} However, the easiest way to customize the pagination views is by exporting them to your resources/views/vendor directory using the vendor:publish command: php artisan vendor:publish --tag=laravel-pagination This command will place the views in the resources/views/vendor/pagination directory. The bootstrap-4.blade.php file within this directory corresponds to the default pagination view. You may edit this file to modify the pagination HTML. If you would like to designate a different file as the default pagination view, you may use the paginator's defaultView and defaultSimpleView methods within your AppServiceProvider: use Illuminate\\Pagination\\Paginator; public function boot() { Paginator::defaultView('view-name'); Paginator::defaultSimpleView('view-name'); }","title":"Customizing The Pagination View"},{"location":"developerdoc/laravel_db_query/#paginator-instance-methods","text":"Each paginator instance provides additional pagination information via the following methods: Method Description $results->count() Get the number of items for the current page. $results->currentPage() Get the current page number. $results->firstItem() Get the result number of the first item in the results. $results->getOptions() Get the paginator options. $results->getUrlRange($ tart, $end) Create a range of pagination URLs. $results->hasMorePages() Determine if there are enough items to split into multiple pages. $results->items() Get the items for the current page. $results->lastItem() Get the result number of the last item in the results. $results->lastPage() Get the page number of the last available page. (Not available when using simplePaginate). $results->nextPageUrl() Get the URL for the next page. $results->onFirstPage() Determine if the paginator is on the first page. $results->perPage() The number of items to be shown per page. $results->previousPageUrl() Get the URL for the previous page. $results->total() Determine the total number of matching items in the data store. (Not available when using simplePaginate). $results->url($page) Get the URL for a given page number.","title":"Paginator Instance Methods"},{"location":"developerdoc/laravel_db_setting/","text":"Laravel Database Laravel telah menyederhanakan interaksi dengan beberapa tipe database menggunakan raw SQL, query builder, dan Eloquent ORM. Saat ini, Laravel mendukung 4 database backend: MySQL PostgreSQL SQLite SQL Server Setting Database Setting database untuk aplikasi Anda terletak pada file config/database.php . Dalam file ini, Anda dapat mendefinisikan semua koneksi database yang dibutuhkan aplikasi Anda. Contoh setting tipe database yang didukung Laravel disediakan di dalam file tersebut. Setting untuk SQLite Setelah membuat database baru SQLite dengan menggunakan perintah seperti touch database/database.sglite , Anda dapat dengan mudah mengatur environment variable untuk merujuk ke database yang sudah Anda buat dengan menggunakan path absolut dari file database itu, berikut contoh isi file .env yang merujuk ke database SQLite: DB_CONNECTION=sqlite DB_DATABASE=/absolute/path/to/database.sqlite Secara default SQLite tidak mengaktifkan foreign key constraint, untuk mengaktifkannya Anda harus menambahkan opsi ke file config/database.php : 'sqlite' => [ // ... 'foreign_key_constraints' => true, ], Setting untuk MySQL Anda perlu menyiapkan database di MySQL Server menggunakan PHPMyAdmin create database dan useruntuk mengakses database tersebut. Anda cukup menyediakan database kosong, table akan dibuat melalui database migration yang akan dijalankan dengan perintah artisan $ php artisan migrate Read & Write Connections Terkadang Anda ingin menggunakan satu koneksi database untuk SELECT query, dan koneksi database yang lain untuk INSERT, UPDATE, and DELETE. Laravel membuat ini menjadi lebih mudah, dan koneksi database yang benar akan digunakan untuk setiap query baik saat Anda menggunakan raw SQL, query builder, maupun Eloquent ORM. Contoh: 'mysql' => [ 'read' => [ 'host' => [ '192.168.1.1', '196.168.1.2', ], ], 'write' => [ 'host' => [ '196.168.1.3', ], ], 'sticky' => true, 'driver' => 'mysql', 'database' => 'database', 'username' => 'root', 'password' => '', 'charset' => 'utf8mb4', 'collation' => 'utf8mb4_unicode_ci', 'prefix' => '', ], Using Multiple Database Connections Ketika menggunakan lebih dari satu database, setiap koneksi database harus didaftarkan dalam file config/database.php . Di dalam setting tersebut didefinisikan nama connection yang akan digunakan dalam aplikasi, nama ini dapat berbeda dengan nama database aslinya. setting database seperti nama database, hostname, user dan password biasanya mengacu ke variable di dalam file .env . Menambahkan authentikasi user Laravel sudah menyertakan authentikasi user jika Anda ingin menggunakannya. Anda juga dapat membuat sendiri atau menyesuaikan authentikasi user bawaan dengan sistem Anda sendiri. Jalankan perintah berikut ini untuk secara otomatis membuat form login, halaman registrasi, dan halaman reset password bawaan Laravel. artisan make:auth Perintah di atas juga akan membuat file migrasi database untuk keperluan authentikasi user. Kemudian untuk mencobanya Anda membutuhkan setting Database terlebih dahulu, dan melakukan migrasi database dengan perintah artisan migrate","title":"Laravel Database Setting"},{"location":"developerdoc/laravel_db_setting/#laravel-database","text":"Laravel telah menyederhanakan interaksi dengan beberapa tipe database menggunakan raw SQL, query builder, dan Eloquent ORM. Saat ini, Laravel mendukung 4 database backend: MySQL PostgreSQL SQLite SQL Server","title":"Laravel Database"},{"location":"developerdoc/laravel_db_setting/#setting-database","text":"Setting database untuk aplikasi Anda terletak pada file config/database.php . Dalam file ini, Anda dapat mendefinisikan semua koneksi database yang dibutuhkan aplikasi Anda. Contoh setting tipe database yang didukung Laravel disediakan di dalam file tersebut.","title":"Setting Database"},{"location":"developerdoc/laravel_db_setting/#setting-untuk-sqlite","text":"Setelah membuat database baru SQLite dengan menggunakan perintah seperti touch database/database.sglite , Anda dapat dengan mudah mengatur environment variable untuk merujuk ke database yang sudah Anda buat dengan menggunakan path absolut dari file database itu, berikut contoh isi file .env yang merujuk ke database SQLite: DB_CONNECTION=sqlite DB_DATABASE=/absolute/path/to/database.sqlite Secara default SQLite tidak mengaktifkan foreign key constraint, untuk mengaktifkannya Anda harus menambahkan opsi ke file config/database.php : 'sqlite' => [ // ... 'foreign_key_constraints' => true, ],","title":"Setting untuk SQLite"},{"location":"developerdoc/laravel_db_setting/#setting-untuk-mysql","text":"Anda perlu menyiapkan database di MySQL Server menggunakan PHPMyAdmin create database dan useruntuk mengakses database tersebut. Anda cukup menyediakan database kosong, table akan dibuat melalui database migration yang akan dijalankan dengan perintah artisan $ php artisan migrate","title":"Setting untuk MySQL"},{"location":"developerdoc/laravel_db_setting/#read-write-connections","text":"Terkadang Anda ingin menggunakan satu koneksi database untuk SELECT query, dan koneksi database yang lain untuk INSERT, UPDATE, and DELETE. Laravel membuat ini menjadi lebih mudah, dan koneksi database yang benar akan digunakan untuk setiap query baik saat Anda menggunakan raw SQL, query builder, maupun Eloquent ORM. Contoh: 'mysql' => [ 'read' => [ 'host' => [ '192.168.1.1', '196.168.1.2', ], ], 'write' => [ 'host' => [ '196.168.1.3', ], ], 'sticky' => true, 'driver' => 'mysql', 'database' => 'database', 'username' => 'root', 'password' => '', 'charset' => 'utf8mb4', 'collation' => 'utf8mb4_unicode_ci', 'prefix' => '', ],","title":"Read &amp; Write Connections"},{"location":"developerdoc/laravel_db_setting/#using-multiple-database-connections","text":"Ketika menggunakan lebih dari satu database, setiap koneksi database harus didaftarkan dalam file config/database.php . Di dalam setting tersebut didefinisikan nama connection yang akan digunakan dalam aplikasi, nama ini dapat berbeda dengan nama database aslinya. setting database seperti nama database, hostname, user dan password biasanya mengacu ke variable di dalam file .env .","title":"Using Multiple Database Connections"},{"location":"developerdoc/laravel_db_setting/#menambahkan-authentikasi-user","text":"Laravel sudah menyertakan authentikasi user jika Anda ingin menggunakannya. Anda juga dapat membuat sendiri atau menyesuaikan authentikasi user bawaan dengan sistem Anda sendiri. Jalankan perintah berikut ini untuk secara otomatis membuat form login, halaman registrasi, dan halaman reset password bawaan Laravel. artisan make:auth Perintah di atas juga akan membuat file migrasi database untuk keperluan authentikasi user. Kemudian untuk mencobanya Anda membutuhkan setting Database terlebih dahulu, dan melakukan migrasi database dengan perintah artisan migrate","title":"Menambahkan authentikasi user"},{"location":"developerdoc/laravel_eloquent/","text":"Laravel Eloquent Introduction The Eloquent ORM included with Laravel provides a beautiful, simple ActiveRecord implementation for working with your database. Each database table has a corresponding \"Model\" which is used to interact with that table. Models allow you to query for data in your tables, as well as insert new records into the table. Before getting started, be sure to configure a database connection in config/database.php. For more information on configuring your database, check out the documentation. Defining Models To get started, let's create an Eloquent model. Models typically live in the app directory, but you are free to place them anywhere that can be auto-loaded according to your composer.json file. All Eloquent models extend Illuminate\\Database\\Eloquent\\Model class. The easiest way to create a model instance is using the make:model Artisan command: php artisan make:model Flight If you would like to generate a database migration when you generate the model, you may use the --migration or -m option: php artisan make:model Flight --migration php artisan make:model Flight -m Eloquent Model Conventions Now, let's look at an example Flight model, which we will use to retrieve and store information from our flights database table: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { // } Table Names Note that we did not tell Eloquent which table to use for our Flight model. By convention, the \"snake case\", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the Flight model stores records in the flights table. You may specify a custom table by defining a table property on your model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The table associated with the model. * * @var string / protected $table = 'my_flights'; } Primary Keys Eloquent will also assume that each table has a primary key column named id. You may define a protected $primaryKey property to override this convention: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The primary key associated with the table. * * @var string / protected $primaryKey = 'flight_id'; } In addition, Eloquent assumes that the primary key is an incrementing integer value, which means that by default the primary key will automatically be cast to an int. If you wish to use a non-incrementing or a non-numeric primary key you must set the public $incrementing property on your model to false: class Flight extends Model { /* * Indicates if the IDs are auto-incrementing. * * @var bool / public $incrementing = false; } If your primary key is not an integer, you should set the protected $keyType property on your model to string: class Flight extends Model { /* * The \"type\" of the auto-incrementing ID. * * @var string / protected $keyType = 'string'; } Timestamps By default, Eloquent expects created_at and updated_at columns to exist on your tables. If you do not wish to have these columns automatically managed by Eloquent, set the $timestamps property on your model to false: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * Indicates if the model should be timestamped. * * @var bool / public $timestamps = false; } If you need to customize the format of your timestamps, set the $dateFormat property on your model. This property determines how date attributes are stored in the database, as well as their format when the model is serialized to an array or JSON: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The storage format of the model's date columns. * * @var string / protected $dateFormat = 'U'; } If you need to customize the names of the columns used to store the timestamps, you may set the CREATED_AT and UPDATED_AT constants in your model: class Flight extends Model { const CREATED_AT = 'creation_date'; const UPDATED_AT = 'last_update'; } Database Connection By default, all Eloquent models will use the default database connection configured for your application. If you would like to specify a different connection for the model, use the $connection property: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The connection name for the model. * * @var string / protected $connection = 'connection-name'; } Default Attribute Values If you would like to define the default values for some of your model's attributes, you may define an $attributes property on your model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The model's default values for attributes. * * @var array / protected $attributes = [ 'delayed' => false, ]; } Retrieving Models Once you have created a model and its associated database table, you are ready to start retrieving data from your database. Think of each Eloquent model as a powerful query builder allowing you to fluently query the database table associated with the model. For example: $flights = App\\Flight::all(); foreach ($flights as $flight) { echo $flight->name; } Adding Additional Constraints The Eloquent all method will return all of the results in the model's table. Since each Eloquent model serves as a query builder, you may also add constraints to queries, and then use the get method to retrieve the results: $flights = App\\Flight::where('active', 1) ->orderBy('name', 'desc') ->take(10) ->get(); Since Eloquent models are query builders, you should review all of the methods available on the query builder. You may use any of these methods in your Eloquent queries. Refreshing Models You can refresh models using the fresh and refresh methods. The fresh method will re-retrieve the model from the database. The existing model instance will not be affected: $flight = App\\Flight::where('number', 'FR 900')->first(); $freshFlight = $flight->fresh(); The refresh method will re-hydrate the existing model using fresh data from the database. In addition, all of its loaded relationships will be refreshed as well: $flight = App\\Flight::where('number', 'FR 900')->first(); $flight->number = 'FR 456'; $flight->refresh(); $flight->number; // \"FR 900\" Collections For Eloquent methods like all and get which retrieve multiple results, an instance of Illuminate\\Database\\Eloquent\\Collection will be returned. The Collection class provides a variety of helpful methods for working with your Eloquent results: $flights = $flights->reject(function ($flight) { return $flight->cancelled; }); You may also loop over the collection like an array: foreach ($flights as $flight) { echo $flight->name; } Chunking Results If you need to process thousands of Eloquent records, use the chunk command. The chunk method will retrieve a \"chunk\" of Eloquent models, feeding them to a given Closure for processing. Using the chunk method will conserve memory when working with large result sets: Flight::chunk(200, function ($flights) { foreach ($flights as $flight) { // } }); The first argument passed to the method is the number of records you wish to receive per \"chunk\". The Closure passed as the second argument will be called for each chunk that is retrieved from the database. A database query will be executed to retrieve each chunk of records passed to the Closure. Using Cursors The cursor method allows you to iterate through your database records using a cursor, which will only execute a single query. When processing large amounts of data, the cursor method may be used to greatly reduce your memory usage: foreach (Flight::where('foo', 'bar')->cursor() as $flight) { // } Retrieving Single Models / Aggregates In addition to retrieving all of the records for a given table, you may also retrieve single records using find or first. Instead of returning a collection of models, these methods return a single model instance: // Retrieve a model by its primary key... $flight = App\\Flight::find(1); // Retrieve the first model matching the query constraints... $flight = App\\Flight::where('active', 1)->first(); You may also call the find method with an array of primary keys, which will return a collection of the matching records: $flights = App\\Flight::find([1, 2, 3]); Not Found Exceptions Sometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers. The findOrFail and firstOrFail methods will retrieve the first result of the query; however, if no result is found, a Illuminate\\Database\\Eloquent\\ModelNotFoundException will be thrown: $model = App\\Flight::findOrFail(1); $model = App\\Flight::where('legs', '>', 100)->firstOrFail(); If the exception is not caught, a 404 HTTP response is automatically sent back to the user. It is not necessary to write explicit checks to return 404 responses when using these methods: Route::get('/api/flights/{id}', function ($id) { return App\\Flight::findOrFail($id); }); Retrieving Aggregates You may also use the count, sum, max, and other aggregate methods provided by the query builder. These methods return the appropriate scalar value instead of a full model instance: $count = App\\Flight::where('active', 1)->count(); $max = App\\Flight::where('active', 1)->max('price'); Inserting & Updating Models Inserts To create a new record in the database, create a new model instance, set attributes on the model, then call the save method: namespace App\\Http\\Controllers; use App\\Flight; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class FlightController extends Controller { /* * Create a new flight instance. * * @param Request $request * @return Response / public function store(Request $request) { // Validate the request... $flight = new Flight; $flight->name = $request->name; $flight->save(); } } In this example, we assign the name parameter from the incoming HTTP request to the name attribute of the App\\Flight model instance. When we call the save method, a record will be inserted into the database. The created_at and updated_at timestamps will automatically be set when the save method is called, so there is no need to set them manually. Updates The save method may also be used to update models that already exist in the database. To update a model, you should retrieve it, set any attributes you wish to update, and then call the save method. Again, the updated_at timestamp will automatically be updated, so there is no need to manually set its value: $flight = App\\Flight::find(1); $flight->name = 'New Flight Name'; $flight->save(); Mass Updates Updates can also be performed against any number of models that match a given query. In this example, all flights that are active and have a destination of San Diego will be marked as delayed: App\\Flight::where('active', 1) ->where('destination', 'San Diego') ->update(['delayed' => 1]); The update method expects an array of column and value pairs representing the columns that should be updated. When issuing a mass update via Eloquent, the saving, saved, updating, and updated model events will not be fired for the updated models. This is because the models are never actually retrieved when issuing a mass update. Mass Assignment You may also use the create method to save a new model in a single line. The inserted model instance will be returned to you from the method. However, before doing so, you will need to specify either a fillable or guarded attribute on the model, as all Eloquent models protect against mass-assignment by default. A mass-assignment vulnerability occurs when a user passes an unexpected HTTP parameter through a request, and that parameter changes a column in your database you did not expect. For example, a malicious user might send an is_admin parameter through an HTTP request, which is then passed into your model's create method, allowing the user to escalate themselves to an administrator. So, to get started, you should define which model attributes you want to make mass assignable. You may do this using the $fillable property on the model. For example, let's make the name attribute of our Flight model mass assignable: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The attributes that are mass assignable. * * @var array / protected $fillable = ['name']; } Once we have made the attributes mass assignable, we can use the create method to insert a new record in the database. The create method returns the saved model instance: $flight = App\\Flight::create(['name' => 'Flight 10']); If you already have a model instance, you may use the fill method to populate it with an array of attributes: $flight->fill(['name' => 'Flight 22']); Guarding Attributes While $fillable serves as a \"white list\" of attributes that should be mass assignable, you may also choose to use $guarded. The $guarded property should contain an array of attributes that you do not want to be mass assignable. All other attributes not in the array will be mass assignable. So, $guarded functions like a \"black list\". Importantly, you should use either $fillable or $guarded - not both. In the example below, all attributes except for price will be mass assignable: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The attributes that aren't mass assignable. * * @var array / protected $guarded = ['price']; } If you would like to make all attributes mass assignable, you may define the $guarded property as an empty array: /* * The attributes that aren't mass assignable. * * @var array / protected $guarded = []; Other Creation Methods firstOrCreate/ firstOrNew There are two other methods you may use to create models by mass assigning attributes: firstOrCreate and firstOrNew. The firstOrCreate method will attempt to locate a database record using the given column / value pairs. If the model can not be found in the database, a record will be inserted with the attributes from the first parameter, along with those in the optional second parameter. The firstOrNew method, like firstOrCreate will attempt to locate a record in the database matching the given attributes. However, if a model is not found, a new model instance will be returned. Note that the model returned by firstOrNew has not yet been persisted to the database. You will need to call save manually to persist it: // Retrieve flight by name, or create it if it doesn't exist... $flight = App\\Flight::firstOrCreate(['name' => 'Flight 10']); // Retrieve flight by name, or create it with the name, delayed, and arrival_time attributes... $flight = App\\Flight::firstOrCreate( ['name' => 'Flight 10'], ['delayed' => 1, 'arrival_time' => '11:30'] ); // Retrieve by name, or instantiate... $flight = App\\Flight::firstOrNew(['name' => 'Flight 10']); // Retrieve by name, or instantiate with the name, delayed, and arrival_time attributes... $flight = App\\Flight::firstOrNew( ['name' => 'Flight 10'], ['delayed' => 1, 'arrival_time' => '11:30'] ); updateOrCreate You may also come across situations where you want to update an existing model or create a new model if none exists. Laravel provides an updateOrCreate method to do this in one step. Like the firstOrCreate method, updateOrCreate persists the model, so there's no need to call save(): // If there's a flight from Oakland to San Diego, set the price to $99. // If no matching model exists, create one. $flight = App\\Flight::updateOrCreate( ['departure' => 'Oakland', 'destination' => 'San Diego'], ['price' => 99, 'discounted' => 1] ); Deleting Models To delete a model, call the delete method on a model instance: $flight = App\\Flight::find(1); $flight->delete(); Deleting An Existing Model By Key In the example above, we are retrieving the model from the database before calling the delete method. However, if you know the primary key of the model, you may delete the model without retrieving it by calling the destroy method. In addition to a single primary key as its argument, the destroy method will accept multiple primary keys, an array of primary keys, or a collection of primary keys: App\\Flight::destroy(1); App\\Flight::destroy(1, 2, 3); App\\Flight::destroy([1, 2, 3]); App\\Flight::destroy(collect([1, 2, 3])); Deleting Models By Query You can also run a delete statement on a set of models. In this example, we will delete all flights that are marked as inactive. Like mass updates, mass deletes will not fire any model events for the models that are deleted: $deletedRows = App\\Flight::where('active', 0)->delete(); When executing a mass delete statement via Eloquent, the deleting and deleted model events will not be fired for the deleted models. This is because the models are never actually retrieved when executing the delete statement. Soft Deleting In addition to actually removing records from your database, Eloquent can also \"soft delete\" models. When models are soft deleted, they are not actually removed from your database. Instead, a deleted_at attribute is set on the model and inserted into the database. If a model has a non-null deleted_at value, the model has been soft deleted. To enable soft deletes for a model, use the Illuminate\\Database\\Eloquent\\SoftDeletes trait on the model: namespace App; use Illuminate\\Database\\Eloquent\\Model; use Illuminate\\Database\\Eloquent\\SoftDeletes; class Flight extends Model { use SoftDeletes; } The SoftDeletes trait will automatically cast the deleted_at attribute to a DateTime / Carbon instance for you. You should also add the deleted_at column to your database table. The Laravel schema builder contains a helper method to create this column: Schema::table('flights', function (Blueprint $table) { $table->softDeletes(); }); Now, when you call the delete method on the model, the deleted_at column will be set to the current date and time. And, when querying a model that uses soft deletes, the soft deleted models will automatically be excluded from all query results. To determine if a given model instance has been soft deleted, use the trashed method: if ($flight->trashed()) { // } Querying Soft Deleted Models Including Soft Deleted Models As noted above, soft deleted models will automatically be excluded from query results. However, you may force soft deleted models to appear in a result set using the withTrashed method on the query: $flights = App\\Flight::withTrashed() ->where('account_id', 1) ->get(); The withTrashed method may also be used on a relationship query: $flight->history()->withTrashed()->get(); Retrieving Only Soft Deleted Models The onlyTrashed method will retrieve only soft deleted models: $flights = App\\Flight::onlyTrashed() ->where('airline_id', 1) ->get(); Restoring Soft Deleted Models Sometimes you may wish to \"un-delete\" a soft deleted model. To restore a soft deleted model into an active state, use the restore method on a model instance: $flight->restore(); You may also use the restore method in a query to quickly restore multiple models. Again, like other \"mass\" operations, this will not fire any model events for the models that are restored: App\\Flight::withTrashed() ->where('airline_id', 1) ->restore(); Like the withTrashed method, the restore method may also be used on relationships: $flight->history()->restore(); Permanently Deleting Models Sometimes you may need to truly remove a model from your database. To permanently remove a soft deleted model from the database, use the forceDelete method: // Force deleting a single model instance... $flight->forceDelete(); // Force deleting all related models... $flight->history()->forceDelete(); Query Scopes Global Scopes Global scopes allow you to add constraints to all queries for a given model. Laravel's own soft delete functionality utilizes global scopes to only pull \"non-deleted\" models from the database. Writing your own global scopes can provide a convenient, easy way to make sure every query for a given model receives certain constraints. Writing Global Scopes Writing a global scope is simple. Define a class that implements the Illuminate\\Database\\Eloquent\\Scope interface. This interface requires you to implement one method: apply. The apply method may add where constraints to the query as needed: namespace App\\Scopes; use Illuminate\\Database\\Eloquent\\Scope; use Illuminate\\Database\\Eloquent\\Model; use Illuminate\\Database\\Eloquent\\Builder; class AgeScope implements Scope { /* * Apply the scope to a given Eloquent query builder. * * @param \\Illuminate\\Database\\Eloquent\\Builder $builder * @param \\Illuminate\\Database\\Eloquent\\Model $model * @return void / public function apply(Builder $builder, Model $model) { $builder->where('age', '>', 200); } } If your global scope is adding columns to the select clause of the query, you should use the addSelect method instead of select. This will prevent the unintentional replacement of the query's existing select clause. Applying Global Scopes To assign a global scope to a model, you should override a given model's boot method and use the addGlobalScope method: namespace App; use App\\Scopes\\AgeScope; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The \"booting\" method of the model. * * @return void / protected static function boot() { parent::boot(); static::addGlobalScope(new AgeScope); } } After adding the scope, a query to User::all() will produce the following SQL: select * from users where age > 200 Anonymous Global Scopes Eloquent also allows you to define global scopes using Closures, which is particularly useful for simple scopes that do not warrant a separate class: namespace App; use Illuminate\\Database\\Eloquent\\Model; use Illuminate\\Database\\Eloquent\\Builder; class User extends Model { /* * The \"booting\" method of the model. * * @return void / protected static function boot() { parent::boot(); static::addGlobalScope('age', function (Builder $builder) { $builder->where('age', '>', 200); }); } } Removing Global Scopes If you would like to remove a global scope for a given query, you may use the withoutGlobalScope method. The method accepts the class name of the global scope as its only argument: User::withoutGlobalScope(AgeScope::class)->get(); Or, if you defined the global scope using a Closure: User::withoutGlobalScope('age')->get(); If you would like to remove several or even all of the global scopes, you may use the withoutGlobalScopes method: // Remove all of the global scopes... User::withoutGlobalScopes()->get(); // Remove some of the global scopes... User::withoutGlobalScopes([ FirstScope::class, SecondScope::class ])->get(); Local Scopes Local scopes allow you to define common sets of constraints that you may easily re-use throughout your application. For example, you may need to frequently retrieve all users that are considered \"popular\". To define a scope, prefix an Eloquent model method with scope. Scopes should always return a query builder instance: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Scope a query to only include popular users. * * @param \\Illuminate\\Database\\Eloquent\\Builder $query * @return \\Illuminate\\Database\\Eloquent\\Builder / public function scopePopular($query) { return $query->where('votes', '>', 100); } /** * Scope a query to only include active users. * * @param \\Illuminate\\Database\\Eloquent\\Builder $query * @return \\Illuminate\\Database\\Eloquent\\Builder */ public function scopeActive($query) { return $query->where('active', 1); } } Utilizing A Local Scope Once the scope has been defined, you may call the scope methods when querying the model. However, you should not include the scope prefix when calling the method. You can even chain calls to various scopes, for example: $users = App\\User::popular()->active()->orderBy('created_at')->get(); Combining multiple Eloquent model scopes via an or query operator may require the use of Closure callbacks: $users = App\\User::popular()->orWhere(function (Builder $query) { $query->active(); })->get(); However, since this can be cumbersome, Laravel provides a \"higher order\" orWhere method that allows you to fluently chain these scopes together without the use of Closures: $users = App\\User::popular()->orWhere->active()->get(); Dynamic Scopes Sometimes you may wish to define a scope that accepts parameters. To get started, just add your additional parameters to your scope. Scope parameters should be defined after the $query parameter: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Scope a query to only include users of a given type. * * @param \\Illuminate\\Database\\Eloquent\\Builder $query * @param mixed $type * @return \\Illuminate\\Database\\Eloquent\\Builder / public function scopeOfType($query, $type) { return $query->where('type', $type); } } Now, you may pass the parameters when calling the scope: $users = App\\User::ofType('admin')->get(); Comparing Models Sometimes you may need to determine if two models are the \"same\". The is method may be used to quickly verify two models have same primary key, table, and database connection: if ($post->is($anotherPost)) { // } Events Eloquent models fire several events, allowing you to hook into the following points in a model's lifecycle: retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, restoring, restored. Events allow you to easily execute code each time a specific model class is saved or updated in the database. Each event receives the instance of the model through its constructor. The retrieved event will fire when an existing model is retrieved from the database. When a new model is saved for the first time, the creating and created events will fire. If a model already existed in the database and the save method is called, the updating / updated events will fire. However, in both cases, the saving / saved events will fire. When issuing a mass update via Eloquent, the saved and updated model events will not be fired for the updated models. This is because the models are never actually retrieved when issuing a mass update. To get started, define a $dispatchesEvents property on your Eloquent model that maps various points of the Eloquent model's lifecycle to your own event classes: namespace App; use App\\Events\\UserSaved; use App\\Events\\UserDeleted; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * The event map for the model. * * @var array */ protected $dispatchesEvents = [ 'saved' => UserSaved::class, 'deleted' => UserDeleted::class, ]; } After defining and mapping your Eloquent events, you may use event listeners to handle the events. Observers Defining Observers If you are listening for many events on a given model, you may use observers to group all of your listeners into a single class. Observers classes have method names which reflect the Eloquent events you wish to listen for. Each of these methods receives the model as their only argument. The make:observer Artisan command is the easiest way to create a new observer class: php artisan make:observer UserObserver --model=User This command will place the new observer in your App/Observers directory. If this directory does not exist, Artisan will create it for you. Your fresh observer will look like the following: namespace App\\Observers; use App\\User; class UserObserver { /* * Handle the User \"created\" event. * * @param \\App\\User $user * @return void / public function created(User $user) { // } /** * Handle the User \"updated\" event. * * @param \\App\\User $user * @return void */ public function updated(User $user) { // } /** * Handle the User \"deleted\" event. * * @param \\App\\User $user * @return void */ public function deleted(User $user) { // } } To register an observer, use the observe method on the model you wish to observe. You may register observers in the boot method of one of your service providers. In this example, we'll register the observer in the AppServiceProvider: namespace App\\Providers; use App\\User; use App\\Observers\\UserObserver; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /* * Register any application services. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { User::observe(UserObserver::class); } } Relationship Introduction Database tables are often related to one another. For example, a blog post may have many comments, or an order could be related to the user who placed it. Eloquent makes managing and working with these relationships easy, and supports several different types of relationships: One To One One To Many Many To Many Has One Through Has Many Through One To One (Polymorphic) One To Many (Polymorphic) Many To Many (Polymorphic) Defining Relationships Eloquent relationships are defined as methods on your Eloquent model classes. Since, like Eloquent models themselves, relationships also serve as powerful query builders, defining relationships as methods provides powerful method chaining and querying capabilities. For example, we may chain additional constraints on this posts relationship: $user->posts()->where('active', 1)->get(); But, before diving too deep into using relationships, let's learn how to define each type. One To One A one-to-one relationship is a very basic relation. For example, a User model might be associated with one Phone. To define this relationship, we place a phone method on the User model. The phone method should call the hasOne method and return its result: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Get the phone record associated with the user. / public function phone() { return $this->hasOne('App\\Phone'); } } The first argument passed to the hasOne method is the name of the related model. Once the relationship is defined, we may retrieve the related record using Eloquent's dynamic properties. Dynamic properties allow you to access relationship methods as if they were properties defined on the model: $phone = User::find(1)->phone; Eloquent determines the foreign key of the relationship based on the model name. In this case, the Phone model is automatically assumed to have a user_id foreign key. If you wish to override this convention, you may pass a second argument to the hasOne method: return $this->hasOne('App\\Phone', 'foreign_key'); Additionally, Eloquent assumes that the foreign key should have a value matching the id (or the custom $primaryKey) column of the parent. In other words, Eloquent will look for the value of the user's id column in the user_id column of the Phone record. If you would like the relationship to use a value other than id, you may pass a third argument to the hasOne method specifying your custom key: return $this->hasOne('App\\Phone', 'foreign_key', 'local_key'); Defining The Inverse Of The Relationship So, we can access the Phone model from our User. Now, let's define a relationship on the Phone model that will let us access the User that owns the phone. We can define the inverse of a hasOne relationship using the belongsTo method: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Phone extends Model { /* * Get the user that owns the phone. / public function user() { return $this->belongsTo('App\\User'); } } In the example above, Eloquent will try to match the user_id from the Phone model to an id on the User model. Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with _id. However, if the foreign key on the Phone model is not user_id, you may pass a custom key name as the second argument to the belongsTo method: /* * Get the user that owns the phone. / public function user() { return $this->belongsTo('App\\User', 'foreign_key'); } If your parent model does not use id as its primary key, or you wish to join the child model to a different column, you may pass a third argument to the belongsTo method specifying your parent table's custom key: /* * Get the user that owns the phone. / public function user() { return $this->belongsTo('App\\User', 'foreign_key', 'other_key'); } One To Many A one-to-many relationship is used to define relationships where a single model owns any amount of other models. For example, a blog post may have an infinite number of comments. Like all other Eloquent relationships, one-to-many relationships are defined by placing a function on your Eloquent model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Post extends Model { /* * Get the comments for the blog post. / public function comments() { return $this->hasMany('App\\Comment'); } } Remember, Eloquent will automatically determine the proper foreign key column on the Comment model. By convention, Eloquent will take the \"snake case\" name of the owning model and suffix it with _id. So, for this example, Eloquent will assume the foreign key on the Comment model is post_id. Once the relationship has been defined, we can access the collection of comments by accessing the comments property. Remember, since Eloquent provides \"dynamic properties\", we can access relationship methods as if they were defined as properties on the model: $comments = App\\Post::find(1)->comments; foreach ($comments as $comment) { // } Since all relationships also serve as query builders, you can add further constraints to which comments are retrieved by calling the comments method and continuing to chain conditions onto the query: $comment = App\\Post::find(1)->comments()->where('title', 'foo')->first(); Like the hasOne method, you may also override the foreign and local keys by passing additional arguments to the hasMany method: return $this->hasMany('App\\Comment', 'foreign_key'); return $this->hasMany('App\\Comment', 'foreign_key', 'local_key'); One To Many (Inverse) Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a hasMany relationship, define a relationship function on the child model which calls the belongsTo method: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Comment extends Model { /* * Get the post that owns the comment. / public function post() { return $this->belongsTo('App\\Post'); } } Once the relationship has been defined, we can retrieve the Post model for a Comment by accessing the post \"dynamic property\": $comment = App\\Comment::find(1); echo $comment->post->title; In the example above, Eloquent will try to match the post_id from the Comment model to an id on the Post model. Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with a _ followed by the name of the primary key column. However, if the foreign key on the Comment model is not post_id, you may pass a custom key name as the second argument to the belongsTo method: /* * Get the post that owns the comment. / public function post() { return $this->belongsTo('App\\Post', 'foreign_key'); } If your parent model does not use id as its primary key, or you wish to join the child model to a different column, you may pass a third argument to the belongsTo method specifying your parent table's custom key: /* * Get the post that owns the comment. / public function post() { return $this->belongsTo('App\\Post', 'foreign_key', 'other_key'); } Many To Many Many-to-many relations are slightly more complicated than hasOne and hasMany relationships. An example of such a relationship is a user with many roles, where the roles are also shared by other users. For example, many users may have the role of \"Admin\". To define this relationship, three database tables are needed: users, roles, and role_user. The role_user table is derived from the alphabetical order of the related model names, and contains the user_id and role_id columns. Many-to-many relationships are defined by writing a method that returns the result of the belongsToMany method. For example, let's define the roles method on our User model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The roles that belong to the user. / public function roles() { return $this->belongsToMany('App\\Role'); } } Once the relationship is defined, you may access the user's roles using the roles dynamic property: $user = App\\User::find(1); foreach ($user->roles as $role) { // } Like all other relationship types, you may call the roles method to continue chaining query constraints onto the relationship: $roles = App\\User::find(1)->roles()->orderBy('name')->get(); As mentioned previously, to determine the table name of the relationship's joining table, Eloquent will join the two related model names in alphabetical order. However, you are free to override this convention. You may do so by passing a second argument to the belongsToMany method: return $this->belongsToMany('App\\Role', 'role_user'); In addition to customizing the name of the joining table, you may also customize the column names of the keys on the table by passing additional arguments to the belongsToMany method. The third argument is the foreign key name of the model on which you are defining the relationship, while the fourth argument is the foreign key name of the model that you are joining to: return $this->belongsToMany('App\\Role', 'role_user', 'user_id', 'role_id'); Defining The Inverse Of The Relationship To define the inverse of a many-to-many relationship, you place another call to belongsToMany on your related model. To continue our user roles example, let's define the users method on the Role model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Role extends Model { /* * The users that belong to the role. / public function users() { return $this->belongsToMany('App\\User'); } } As you can see, the relationship is defined exactly the same as its User counterpart, with the exception of referencing the App\\User model. Since we're reusing the belongsToMany method, all of the usual table and key customization options are available when defining the inverse of many-to-many relationships. Retrieving Intermediate Table Columns As you have already learned, working with many-to-many relations requires the presence of an intermediate table. Eloquent provides some very helpful ways of interacting with this table. For example, let's assume our User object has many Role objects that it is related to. After accessing this relationship, we may access the intermediate table using the pivot attribute on the models: $user = App\\User::find(1); foreach ($user->roles as $role) { echo $role->pivot->created_at; } Notice that each Role model we retrieve is automatically assigned a pivot attribute. This attribute contains a model representing the intermediate table, and may be used like any other Eloquent model. By default, only the model keys will be present on the pivot object. If your pivot table contains extra attributes, you must specify them when defining the relationship: return $this->belongsToMany('App\\Role')->withPivot('column1', 'column2'); If you want your pivot table to have automatically maintained created_at and updated_at timestamps, use the withTimestamps method on the relationship definition: return $this->belongsToMany('App\\Role')->withTimestamps(); Customizing The pivot Attribute Name As noted earlier, attributes from the intermediate table may be accessed on models using the pivot attribute. However, you are free to customize the name of this attribute to better reflect its purpose within your application. For example, if your application contains users that may subscribe to podcasts, you probably have a many-to-many relationship between users and podcasts. If this is the case, you may wish to rename your intermediate table accessor to subscription instead of pivot. This can be done using the as method when defining the relationship: return $this->belongsToMany('App\\Podcast') ->as('subscription') ->withTimestamps(); Once this is done, you may access the intermediate table data using the customized name: $users = User::with('podcasts')->get(); foreach ($users->flatMap->podcasts as $podcast) { echo $podcast->subscription->created_at; } Filtering Relationships Via Intermediate Table Columns You can also filter the results returned by belongsToMany using the wherePivot and wherePivotIn methods when defining the relationship: return $this->belongsToMany('App\\Role')->wherePivot('approved', 1); return $this->belongsToMany('App\\Role')->wherePivotIn('priority', [1, 2]); Defining Custom Intermediate Table Models If you would like to define a custom model to represent the intermediate table of your relationship, you may call the using method when defining the relationship. Custom many-to-many pivot models should extend the Illuminate\\Database\\Eloquent\\Relations\\Pivot class while custom polymorphic many-to-many pivot models should extend the Illuminate\\Database\\Eloquent\\Relations\\MorphPivot class. For example, we may define a Role which uses a custom RoleUser pivot model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Role extends Model { /* * The users that belong to the role. / public function users() { return $this->belongsToMany('App\\User')->using('App\\RoleUser'); } } When defining the RoleUser model, we will extend the Pivot class: namespace App; use Illuminate\\Database\\Eloquent\\Relations\\Pivot; class RoleUser extends Pivot { // } You can combine using and withPivot in order to retrieve columns from the intermediate table. For example, you may retrieve the created_by and updated_by columns from the RoleUser pivot table by passing the column names to the withPivot method: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Role extends Model { /* * The users that belong to the role. / public function users() { return $this->belongsToMany('App\\User') ->using('App\\RoleUser') ->withPivot([ 'created_by', 'updated_by' ]); } } Note: Pivot models may not use the SoftDeletes trait. If you need to soft delete pivot records consider converting your pivot model to an actual Eloquent model. Custom Pivot Models And Incrementing IDs If you have defined a many-to-many relationship that uses a custom pivot model, and that pivot model has an auto-incrementing primary key, you should ensure your custom pivot model class defines an incrementing property that is set to true. /* * Indicates if the IDs are auto-incrementing. * * @var bool / public $incrementing = true; Has One Through The \"has-one-through\" relationship links models through a single intermediate relation. For example, if each supplier has one user, and each user is associated with one user history record, then the supplier model may access the user's history through the user. Let's look at the database tables necessary to define this relationship: users id - integer supplier_id - integer suppliers id - integer history id - integer user_id - integer Though the history table does not contain a supplier_id column, the hasOneThrough relation can provide access to the user's history to the supplier model. Now that we have examined the table structure for the relationship, let's define it on the Supplier model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Supplier extends Model { /* * Get the user's history. / public function userHistory() { return $this->hasOneThrough('App\\History', 'App\\User'); } } The first argument passed to the hasOneThrough method is the name of the final model we wish to access, while the second argument is the name of the intermediate model. Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the hasOneThrough method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model: class Supplier extends Model { /* * Get the user's history. / public function userHistory() { return $this->hasOneThrough( 'App\\History', 'App\\User', 'supplier_id', // Foreign key on users table... 'user_id', // Foreign key on history table... 'id', // Local key on suppliers table... 'id' // Local key on users table... ); } } Has Many Through The \"has-many-through\" relationship provides a convenient shortcut for accessing distant relations via an intermediate relation. For example, a Country model might have many Post models through an intermediate User model. In this example, you could easily gather all blog posts for a given country. Let's look at the tables required to define this relationship: countries id - integer name - string users id - integer country_id - integer name - string posts id - integer user_id - integer title - string Though posts does not contain a country_id column, the hasManyThrough relation provides access to a country's posts via $country->posts. To perform this query, Eloquent inspects the country_id on the intermediate users table. After finding the matching user IDs, they are used to query the posts table. Now that we have examined the table structure for the relationship, let's define it on the Country model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Country extends Model { /* * Get all of the posts for the country. / public function posts() { return $this->hasManyThrough('App\\Post', 'App\\User'); } } The first argument passed to the hasManyThrough method is the name of the final model we wish to access, while the second argument is the name of the intermediate model. Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the hasManyThrough method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model: class Country extends Model { public function posts() { return $this->hasManyThrough( 'App\\Post', 'App\\User', 'country_id', // Foreign key on users table... 'user_id', // Foreign key on posts table... 'id', // Local key on countries table... 'id' // Local key on users table... ); } } Polymorphic Relationships A polymorphic relationship allows the target model to belong to more than one type of model using a single association. One To One (Polymorphic) Table Structure A one-to-one polymorphic relation is similar to a simple one-to-one relation; however, the target model can belong to more than one type of model on a single association. For example, a blog Post and a User may share a polymorphic relation to an Image model. Using a one-to-one polymorphic relation allows you to have a single list of unique images that are used for both blog posts and user accounts. First, let's examine the table structure: posts id - integer name - string users id - integer name - string images id - integer url - string imageable_id - integer imageable_type - string Take note of the imageable_id and imageable_type columns on the images table. The imageable_id column will contain the ID value of the post or user, while the imageable_type column will contain the class name of the parent model. The imageable_type column is used by Eloquent to determine which \"type\" of parent model to return when accessing the imageable relation. Model Structure Next, let's examine the model definitions needed to build this relationship: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Image extends Model { /* * Get the owning imageable model. / public function imageable() { return $this->morphTo(); } } class Post extends Model { /* * Get the post's image. / public function image() { return $this->morphOne('App\\Image', 'imageable'); } } class User extends Model { /* * Get the user's image. / public function image() { return $this->morphOne('App\\Image', 'imageable'); } } Retrieving The Relationship Once your database table and models are defined, you may access the relationships via your models. For example, to retrieve the image for a post, we can use the image dynamic property: $post = App\\Post::find(1); $image = $post->image; You may also retrieve the parent from the polymorphic model by accessing the name of the method that performs the call to morphTo. In our case, that is the imageable method on the Image model. So, we will access that method as a dynamic property: $image = App\\Image::find(1); $imageable = $image->imageable; The imageable relation on the Image model will return either a Post or User instance, depending on which type of model owns the image. One To Many (Polymorphic) Table Structure A one-to-many polymorphic relation is similar to a simple one-to-many relation; however, the target model can belong to more than one type of model on a single association. For example, imagine users of your application can \"comment\" on both posts and videos. Using polymorphic relationships, you may use a single comments table for both of these scenarios. First, let's examine the table structure required to build this relationship: posts id - integer title - string body - text videos id - integer title - string url - string comments id - integer body - text commentable_id - integer commentable_type - string Model Structure Next, let's examine the model definitions needed to build this relationship: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Comment extends Model { /* * Get the owning commentable model. / public function commentable() { return $this->morphTo(); } } class Post extends Model { /* * Get all of the post's comments. / public function comments() { return $this->morphMany('App\\Comment', 'commentable'); } } class Video extends Model { /* * Get all of the video's comments. / public function comments() { return $this->morphMany('App\\Comment', 'commentable'); } } Retrieving The Relationship Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the comments for a post, we can use the comments dynamic property: $post = App\\Post::find(1); foreach ($post->comments as $comment) { // } You may also retrieve the owner of a polymorphic relation from the polymorphic model by accessing the name of the method that performs the call to morphTo. In our case, that is the commentable method on the Comment model. So, we will access that method as a dynamic property: $comment = App\\Comment::find(1); $commentable = $comment->commentable; The commentable relation on the Comment model will return either a Post or Video instance, depending on which type of model owns the comment. Many To Many (Polymorphic) Table Structure Many-to-many polymorphic relations are slightly more complicated than morphOne and morphMany relationships. For example, a blog Post and Video model could share a polymorphic relation to a Tag model. Using a many-to-many polymorphic relation allows you to have a single list of unique tags that are shared across blog posts and videos. First, let's examine the table structure: posts id - integer name - string videos id - integer name - string tags id - integer name - string taggables tag_id - integer taggable_id - integer taggable_type - string Model Structure Next, we're ready to define the relationships on the model. The Post and Video models will both have a tags method that calls the morphToMany method on the base Eloquent class: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Post extends Model { /* * Get all of the tags for the post. / public function tags() { return $this->morphToMany('App\\Tag', 'taggable'); } } Defining The Inverse Of The Relationship Next, on the Tag model, you should define a method for each of its related models. So, for this example, we will define a posts method and a videos method: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Tag extends Model { /* * Get all of the posts that are assigned this tag. / public function posts() { return $this->morphedByMany('App\\Post', 'taggable'); } /** * Get all of the videos that are assigned this tag. */ public function videos() { return $this->morphedByMany('App\\Video', 'taggable'); } } Retrieving The Relationship Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the tags for a post, you can use the tags dynamic property: $post = App\\Post::find(1); foreach ($post->tags as $tag) { // } You may also retrieve the owner of a polymorphic relation from the polymorphic model by accessing the name of the method that performs the call to morphedByMany. In our case, that is the posts or videos methods on the Tag model. So, you will access those methods as dynamic properties: $tag = App\\Tag::find(1); foreach ($tag->videos as $video) { // } Custom Polymorphic Types By default, Laravel will use the fully qualified class name to store the type of the related model. For instance, given the one-to-many example above where a Comment may belong to a Post or a Video, the default commentable_type would be either App\\Post or App\\Video, respectively. However, you may wish to decouple your database from your application's internal structure. In that case, you may define a \"morph map\" to instruct Eloquent to use a custom name for each model instead of the class name: use Illuminate\\Database\\Eloquent\\Relations\\Relation; Relation::morphMap([ 'posts' => 'App\\Post', 'videos' => 'App\\Video', ]); You may register the morphMap in the boot function of your AppServiceProvider or create a separate service provider if you wish. When adding a \"morph map\" to your existing application, every morphable *_type column value in your database that still contains a fully-qualified class will need to be converted to its \"map\" name. Querying Relations Since all types of Eloquent relationships are defined via methods, you may call those methods to obtain an instance of the relationship without actually executing the relationship queries. In addition, all types of Eloquent relationships also serve as query builders, allowing you to continue to chain constraints onto the relationship query before finally executing the SQL against your database. For example, imagine a blog system in which a User model has many associated Post models: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Get all of the posts for the user. / public function posts() { return $this->hasMany('App\\Post'); } } You may query the posts relationship and add additional constraints to the relationship like so: $user = App\\User::find(1); $user->posts()->where('active', 1)->get(); You are able to use any of the query builder methods on the relationship, so be sure to explore the query builder documentation to learn about all of the methods that are available to you. Chaining orWhere Clauses After Relationships As demonstrated in the example above, you are free to add additional constraints to relationships when querying them. However, use caution when chaining orWhere clauses onto a relationship, as the orWhere clauses will be logically grouped at the same level as the relationship constraint: $user->posts() ->where('active', 1) ->orWhere('votes', '>=', 100) ->get(); // select * from posts // where user_id = ? and active = 1 or votes >= 100 In most situations, you likely intend to use constraint groups to logically group the conditional checks between parentheses: use Illuminate\\Database\\Eloquent\\Builder; $user->posts() ->where(function (Builder $query) { return $query->where('active', 1) ->orWhere('votes', '>=', 100); }) ->get(); // select * from posts // where user_id = ? and (active = 1 or votes >= 100) Relationship Methods Vs. Dynamic Properties If you do not need to add additional constraints to an Eloquent relationship query, you may access the relationship as if it were a property. For example, continuing to use our User and Post example models, we may access all of a user's posts like so: $user = App\\User::find(1); foreach ($user->posts as $post) { // } Dynamic properties are \"lazy loading\", meaning they will only load their relationship data when you actually access them. Because of this, developers often use eager loading to pre-load relationships they know will be accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to load a model's relations. Querying Relationship Existence When accessing the records for a model, you may wish to limit your results based on the existence of a relationship. For example, imagine you want to retrieve all blog posts that have at least one comment. To do so, you may pass the name of the relationship to the has and orHas methods: // Retrieve all posts that have at least one comment... $posts = App\\Post::has('comments')->get(); You may also specify an operator and count to further customize the query: // Retrieve all posts that have three or more comments... $posts = App\\Post::has('comments', '>=', 3)->get(); Nested has statements may also be constructed using \"dot\" notation. For example, you may retrieve all posts that have at least one comment and vote: // Retrieve posts that have at least one comment with votes... $posts = App\\Post::has('comments.votes')->get(); If you need even more power, you may use the whereHas and orWhereHas methods to put \"where\" conditions on your has queries. These methods allow you to add customized constraints to a relationship constraint, such as checking the content of a comment: use Illuminate\\Database\\Eloquent\\Builder; // Retrieve posts with at least one comment containing words like foo%... $posts = App\\Post::whereHas('comments', function (Builder $query) { $query->where('content', 'like', 'foo%'); })->get(); // Retrieve posts with at least ten comments containing words like foo%... $posts = App\\Post::whereHas('comments', function (Builder $query) { $query->where('content', 'like', 'foo%'); }, '>=', 10)->get(); Querying Relationship Absence When accessing the records for a model, you may wish to limit your results based on the absence of a relationship. For example, imagine you want to retrieve all blog posts that don't have any comments. To do so, you may pass the name of the relationship to the doesntHave and orDoesntHave methods: $posts = App\\Post::doesntHave('comments')->get(); If you need even more power, you may use the whereDoesntHave and orWhereDoesntHave methods to put \"where\" conditions on your doesntHave queries. These methods allows you to add customized constraints to a relationship constraint, such as checking the content of a comment: use Illuminate\\Database\\Eloquent\\Builder; $posts = App\\Post::whereDoesntHave('comments', function (Builder $query) { $query->where('content', 'like', 'foo%'); })->get(); You may use \"dot\" notation to execute a query against a nested relationship. For example, the following query will retrieve all posts with comments from authors that are not banned: use Illuminate\\Database\\Eloquent\\Builder; $posts = App\\Post::whereDoesntHave('comments.author', function (Builder $query) { $query->where('banned', 1); })->get(); Querying Polymorphic Relationships To query the existence of MorphTo relationships, you may use the whereHasMorph method and its corresponding methods: use Illuminate\\Database\\Eloquent\\Builder; // Retrieve comments associated to posts or videos with a title like foo%... $comments = App\\Comment::whereHasMorph( 'commentable', ['App\\Post', 'App\\Video'], function (Builder $query) { $query->where('title', 'like', 'foo%'); } )->get(); // Retrieve comments associated to posts with a title not like foo%... $comments = App\\Comment::whereDoesntHaveMorph( 'commentable', 'App\\Post', function (Builder $query) { $query->where('title', 'like', 'foo%'); } )->get(); You may use the $type parameter to add different constraints depending on the related model: use Illuminate\\Database\\Eloquent\\Builder; $comments = App\\Comment::whereHasMorph( 'commentable', ['App\\Post', 'App\\Video'], function (Builder $query, $type) { $query->where('title', 'like', 'foo%'); if ($type === 'App\\Post') { $query->orWhere('content', 'like', 'foo%'); } } )->get(); Instead of passing an array of possible polymorphic models, you may provide * as a wildcard and let Laravel retrieve all the possible polymorphic types from the database. Laravel will execute an additional query in order to perform this operation: use Illuminate\\Database\\Eloquent\\Builder; $comments = App\\Comment::whereHasMorph('commentable', '*', function (Builder $query) { $query->where('title', 'like', 'foo%'); })->get(); Counting Related Models If you want to count the number of results from a relationship without actually loading them you may use the withCount method, which will place a {relation}_count column on your resulting models. For example: $posts = App\\Post::withCount('comments')->get(); foreach ($posts as $post) { echo $post->comments_count; } You may add the \"counts\" for multiple relations as well as add constraints to the queries: use Illuminate\\Database\\Eloquent\\Builder; $posts = App\\Post::withCount(['votes', 'comments' => function (Builder $query) { $query->where('content', 'like', 'foo%'); }])->get(); echo $posts[0]->votes_count; echo $posts[0]->comments_count; You may also alias the relationship count result, allowing multiple counts on the same relationship: use Illuminate\\Database\\Eloquent\\Builder; $posts = App\\Post::withCount([ 'comments', 'comments as pending_comments_count' => function (Builder $query) { $query->where('approved', false); } ])->get(); echo $posts[0]->comments_count; echo $posts[0]->pending_comments_count; If you're combining withCount with a select statement, ensure that you call withCount after the select method: $posts = App\\Post::select(['title', 'body'])->withCount('comments')->get(); echo $posts[0]->title; echo $posts[0]->body; echo $posts[0]->comments_count; Eager Loading When accessing Eloquent relationships as properties, the relationship data is \"lazy loaded\". This means the relationship data is not actually loaded until you first access the property. However, Eloquent can \"eager load\" relationships at the time you query the parent model. Eager loading alleviates the N + 1 query problem. To illustrate the N + 1 query problem, consider a Book model that is related to Author: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Book extends Model { /* * Get the author that wrote the book. / public function author() { return $this->belongsTo('App\\Author'); } } Now, let's retrieve all books and their authors: $books = App\\Book::all(); foreach ($books as $book) { echo $book->author->name; } This loop will execute 1 query to retrieve all of the books on the table, then another query for each book to retrieve the author. So, if we have 25 books, this loop would run 26 queries: 1 for the original book, and 25 additional queries to retrieve the author of each book. Thankfully, we can use eager loading to reduce this operation to just 2 queries. When querying, you may specify which relationships should be eager loaded using the with method: $books = App\\Book::with('author')->get(); foreach ($books as $book) { echo $book->author->name; } For this operation, only two queries will be executed: select * from books select * from authors where id in (1, 2, 3, 4, 5, ...) Eager Loading Multiple Relationships Sometimes you may need to eager load several different relationships in a single operation. To do so, just pass additional arguments to the with method: $books = App\\Book::with(['author', 'publisher'])->get(); Nested Eager Loading To eager load nested relationships, you may use \"dot\" syntax. For example, let's eager load all of the book's authors and all of the author's personal contacts in one Eloquent statement: $books = App\\Book::with('author.contacts')->get(); Nested Eager Loading morphTo Relationships If you would like to eager load a morphTo relationship, as well as nested relationships on the various entities that may be returned by that relationship, you may use the with method in combination with the morphTo relationship's morphWith method. To help illustrate this method, let's consider the following model: use Illuminate\\Database\\Eloquent\\Model; class ActivityFeed extends Model { /* * Get the parent of the activity feed record. / public function parentable() { return $this->morphTo(); } } In this example, let's assume Event, Photo, and Post models may create ActivityFeed models. Additionally, let's assume that Event models belong to a Calendar model, Photo models are associated with Tag models, and Post models belong to an Author model. Using these model definitions and relationships, we may retrieve ActivityFeed model instances and eager load all parentable models and their respective nested relationships: use Illuminate\\Database\\Eloquent\\Relations\\MorphTo; $activities = ActivityFeed::query() ->with(['parentable' => function (MorphTo $morphTo) { $morphTo->morphWith([ Event::class => ['calendar'], Photo::class => ['tags'], Post::class => ['author'], ]); }])->get(); Eager Loading Specific Columns You may not always need every column from the relationships you are retrieving. For this reason, Eloquent allows you to specify which columns of the relationship you would like to retrieve: $books = App\\Book::with('author:id,name')->get(); When using this feature, you should always include the id column and any relevant foreign key columns in the list of columns you wish to retrieve. Eager Loading By Default Sometimes you might want to always load some relationships when retrieving a model. To accomplish this, you may define a $with property on the model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Book extends Model { /* * The relationships that should always be loaded. * * @var array / protected $with = ['author']; /** * Get the author that wrote the book. */ public function author() { return $this->belongsTo('App\\Author'); } } If you would like to remove an item from the $with property for a single query, you may use the without method: $books = App\\Book::without('author')->get(); Constraining Eager Loads Sometimes you may wish to eager load a relationship, but also specify additional query conditions for the eager loading query. Here's an example: use Illuminate\\Database\\Eloquent\\Builder; $users = App\\User::with(['posts' => function (Builder $query) { $query->where('title', 'like', '%first%'); }])->get(); In this example, Eloquent will only eager load posts where the post's title column contains the word first. You may call other query builder methods to further customize the eager loading operation: use Illuminate\\Database\\Eloquent\\Builder; $users = App\\User::with(['posts' => function (Builder $query) { $query->orderBy('created_at', 'desc'); }])->get(); The limit and take query builder methods may not be used when constraining eager loads. Lazy Eager Loading Sometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this may be useful if you need to dynamically decide whether to load related models: $books = App\\Book::all(); if ($someCondition) { $books->load('author', 'publisher'); } If you need to set additional query constraints on the eager loading query, you may pass an array keyed by the relationships you wish to load. The array values should be Closure instances which receive the query instance: use Illuminate\\Database\\Eloquent\\Builder; $books->load(['author' => function (Builder $query) { $query->orderBy('published_date', 'asc'); }]); To load a relationship only when it has not already been loaded, use the loadMissing method: public function format(Book $book) { $book->loadMissing('author'); return [ 'name' => $book->name, 'author' => $book->author->name ]; } Nested Lazy Eager Loading & morphTo If you would like to eager load a morphTo relationship, as well as nested relationships on the various entities that may be returned by that relationship, you may use the loadMorph method. This method accepts the name of the morphTo relationship as its first argument, and an array of model / relationship pairs as its second argument. To help illustrate this method, let's consider the following model: use Illuminate\\Database\\Eloquent\\Model; class ActivityFeed extends Model { /* * Get the parent of the activity feed record. / public function parentable() { return $this->morphTo(); } } In this example, let's assume Event, Photo, and Post models may create ActivityFeed models. Additionally, let's assume that Event models belong to a Calendar model, Photo models are associated with Tag models, and Post models belong to an Author model. Using these model definitions and relationships, we may retrieve ActivityFeed model instances and eager load all parentable models and their respective nested relationships: $activities = ActivityFeed::with('parentable') ->get() ->loadMorph('parentable', [ Event::class => ['calendar'], Photo::class => ['tags'], Post::class => ['author'], ]); Inserting & Updating Related Models The Save Method Eloquent provides convenient methods for adding new models to relationships. For example, perhaps you need to insert a new Comment for a Post model. Instead of manually setting the post_id attribute on the Comment, you may insert the Comment directly from the relationship's save method: $comment = new App\\Comment(['message' => 'A new comment.']); $post = App\\Post::find(1); $post->comments()->save($comment); Notice that we did not access the comments relationship as a dynamic property. Instead, we called the comments method to obtain an instance of the relationship. The save method will automatically add the appropriate post_id value to the new Comment model. If you need to save multiple related models, you may use the saveMany method: $post = App\\Post::find(1); $post->comments()->saveMany([ new App\\Comment(['message' => 'A new comment.']), new App\\Comment(['message' => 'Another comment.']), ]); Recursively Saving Models & Relationships If you would like to save your model and all of its associated relationships, you may use the push method: $post = App\\Post::find(1); $post->comments[0]->message = 'Message'; $post->comments[0]->author->name = 'Author Name'; $post->push(); The Create Method In addition to the save and saveMany methods, you may also use the create method, which accepts an array of attributes, creates a model, and inserts it into the database. Again, the difference between save and create is that save accepts a full Eloquent model instance while create accepts a plain PHP array: $post = App\\Post::find(1); $comment = $post->comments()->create([ 'message' => 'A new comment.', ]); Before using the create method, be sure to review the documentation on attribute mass assignment. You may use the createMany method to create multiple related models: $post = App\\Post::find(1); $post->comments()->createMany([ [ 'message' => 'A new comment.', ], [ 'message' => 'Another new comment.', ], ]); You may also use the findOrNew, firstOrNew, firstOrCreate and updateOrCreate methods to create and update models on relationships. Belongs To Relationships When updating a belongsTo relationship, you may use the associate method. This method will set the foreign key on the child model: $account = App\\Account::find(10); $user->account()->associate($account); $user->save(); When removing a belongsTo relationship, you may use the dissociate method. This method will set the relationship's foreign key to null: $user->account()->dissociate(); $user->save(); Default Models The belongsTo, hasOne, hasOneThrough, and morphOne relationships allow you to define a default model that will be returned if the given relationship is null. This pattern is often referred to as the Null Object pattern and can help remove conditional checks in your code. In the following example, the user relation will return an empty App\\User model if no user is attached to the post: /* * Get the author of the post. / public function user() { return $this->belongsTo('App\\User')->withDefault(); } To populate the default model with attributes, you may pass an array or Closure to the withDefault method: /* * Get the author of the post. / public function user() { return $this->belongsTo('App\\User')->withDefault([ 'name' => 'Guest Author', ]); } /* * Get the author of the post. / public function user() { return $this->belongsTo('App\\User')->withDefault(function ($user) { $user->name = 'Guest Author'; }); } Many To Many Relationships Attaching / Detaching Eloquent also provides a few additional helper methods to make working with related models more convenient. For example, let's imagine a user can have many roles and a role can have many users. To attach a role to a user by inserting a record in the intermediate table that joins the models, use the attach method: $user = App\\User::find(1); $user->roles()->attach($roleId); When attaching a relationship to a model, you may also pass an array of additional data to be inserted into the intermediate table: $user->roles()->attach($roleId, ['expires' => $expires]); Sometimes it may be necessary to remove a role from a user. To remove a many-to-many relationship record, use the detach method. The detach method will delete the appropriate record out of the intermediate table; however, both models will remain in the database: // Detach a single role from the user... $user->roles()->detach($roleId); // Detach all roles from the user... $user->roles()->detach(); For convenience, attach and detach also accept arrays of IDs as input: $user = App\\User::find(1); $user->roles()->detach([1, 2, 3]); $user->roles()->attach([ 1 => ['expires' => $expires], 2 => ['expires' => $expires] ]); Syncing Associations You may also use the sync method to construct many-to-many associations. The sync method accepts an array of IDs to place on the intermediate table. Any IDs that are not in the given array will be removed from the intermediate table. So, after this operation is complete, only the IDs in the given array will exist in the intermediate table: $user->roles()->sync([1, 2, 3]); You may also pass additional intermediate table values with the IDs: $user->roles()->sync([1 => ['expires' => true], 2, 3]); If you do not want to detach existing IDs, you may use the syncWithoutDetaching method: $user->roles()->syncWithoutDetaching([1, 2, 3]); Toggling Associations The many-to-many relationship also provides a toggle method which \"toggles\" the attachment status of the given IDs. If the given ID is currently attached, it will be detached. Likewise, if it is currently detached, it will be attached: $user->roles()->toggle([1, 2, 3]); Saving Additional Data On A Pivot Table When working with a many-to-many relationship, the save method accepts an array of additional intermediate table attributes as its second argument: App\\User::find(1)->roles()->save($role, ['expires' => $expires]); Updating A Record On A Pivot Table If you need to update an existing row in your pivot table, you may use updateExistingPivot method. This method accepts the pivot record foreign key and an array of attributes to update: $user = App\\User::find(1); $user->roles()->updateExistingPivot($roleId, $attributes); Touching Parent Timestamps When a model belongsTo or belongsToMany another model, such as a Comment which belongs to a Post, it is sometimes helpful to update the parent's timestamp when the child model is updated. For example, when a Comment model is updated, you may want to automatically \"touch\" the updated_at timestamp of the owning Post. Eloquent makes it easy. Just add a touches property containing the names of the relationships to the child model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Comment extends Model { /* * All of the relationships to be touched. * * @var array / protected $touches = ['post']; /** * Get the post that the comment belongs to. */ public function post() { return $this->belongsTo('App\\Post'); } } Now, when you update a Comment, the owning Post will have its updated_at column updated as well, making it more convenient to know when to invalidate a cache of the Post model: $comment = App\\Comment::find(1); $comment->text = 'Edit to this comment!'; $comment->save(); Eloquent Collection Introduction All multi-result sets returned by Eloquent are instances of the Illuminate\\Database\\Eloquent\\Collection object, including results retrieved via the get method or accessed via a relationship. The Eloquent collection object extends the Laravel base collection, so it naturally inherits dozens of methods used to fluently work with the underlying array of Eloquent models. All collections also serve as iterators, allowing you to loop over them as if they were simple PHP arrays: $users = App\\User::where('active', 1)->get(); foreach ($users as $user) { echo $user->name; } However, collections are much more powerful than arrays and expose a variety of map / reduce operations that may be chained using an intuitive interface. For example, let's remove all inactive models and gather the first name for each remaining user: $users = App\\User::all(); $names = $users->reject(function ($user) { return $user->active === false; }) ->map(function ($user) { return $user->name; }); While most Eloquent collection methods return a new instance of an Eloquent collection, the pluck, keys, zip, collapse, flatten and flip methods return a base collection instance. Likewise, if a map operation returns a collection that does not contain any Eloquent models, it will be automatically cast to a base collection. Available Methods All Eloquent collections extend the base Laravel collection object; therefore, they inherit all of the powerful methods provided by the base collection class. In addition, the Illuminate\\Database\\Eloquent\\Collection class provides a superset of methods to aid with managing your model collections. Most methods return Illuminate\\Database\\Eloquent\\Collection instances; however, some methods return a base Illuminate\\Support\\Collection instance. contains($key, $operator = null, $value = null) The contains method may be used to determine if a given model instance is contained by the collection. This method accepts a primary key or a model instance: $users->contains(1); $users->contains(User::find(1)); diff($items) The diff method returns all of the models that are not present in the given collection: use App\\User; $users = $users->diff(User::whereIn('id', [1, 2, 3])->get()); except($keys) The except method returns all of the models that do not have the given primary keys: $users = $users->except([1, 2, 3]); find($key) The find method finds a model that has a given primary key. If $key is a model instance, find will attempt to return a model matching the primary key. If $key is an array of keys, find will return all models which match the $keys using whereIn(): $users = User::all(); $user = $users->find(1); fresh($with = []) The fresh method retrieves a fresh instance of each model in the collection from the database. In addition, any specified relationships will be eager loaded: $users = $users->fresh(); $users = $users->fresh('comments'); intersect($items) The intersect method returns all of the models that are also present in the given collection: use App\\User; $users = $users->intersect(User::whereIn('id', [1, 2, 3])->get()); load($relations) The load method eager loads the given relationships for all models in the collection: $users->load('comments', 'posts'); $users->load('comments.author'); loadMissing($relations) The loadMissing method eager loads the given relationships for all models in the collection if the relationships are not already loaded: $users->loadMissing('comments', 'posts'); $users->loadMissing('comments.author'); modelKeys() The modelKeys method returns the primary keys for all models in the collection: $users->modelKeys(); // [1, 2, 3, 4, 5] makeVisible($attributes) The makeVisible method makes visible attributes that are typically \"hidden\" on each model in the collection: $users = $users->makeVisible(['address', 'phone_number']); makeHidden($attributes) The makeHidden method hides attributes that are typically \"visible\" on each model in the collection: $users = $users->makeHidden(['address', 'phone_number']); only($keys) The only method returns all of the models that have the given primary keys: $users = $users->only([1, 2, 3]); unique($key = null, $strict = false) The unique method returns all of the unique models in the collection. Any models of the same type with the same primary key as another model in the collection are removed. $users = $users->unique(); Custom Collections If you need to use a custom Collection object with your own extension methods, you may override the newCollection method on your model: namespace App; use App\\CustomCollection; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Create a new Eloquent Collection instance. * * @param array $models * @return \\Illuminate\\Database\\Eloquent\\Collection / public function newCollection(array $models = []) { return new CustomCollection($models); } } Once you have defined a newCollection method, you will receive an instance of your custom collection anytime Eloquent returns a Collection instance of that model. If you would like to use a custom collection for every model in your application, you should override the newCollection method on a base model class that is extended by all of your models Eloquent Mutator Introduction Accessors and mutators allow you to format Eloquent attribute values when you retrieve or set them on model instances. For example, you may want to use the Laravel encrypter to encrypt a value while it is stored in the database, and then automatically decrypt the attribute when you access it on an Eloquent model. In addition to custom accessors and mutators, Eloquent can also automatically cast date fields to Carbon instances or even cast text fields to JSON. Accessors & Mutators Defining An Accessor To define an accessor, create a getFooAttribute method on your model where Foo is the \"studly\" cased name of the column you wish to access. In this example, we'll define an accessor for the first_name attribute. The accessor will automatically be called by Eloquent when attempting to retrieve the value of the first_name attribute: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Get the user's first name. * * @param string $value * @return string / public function getFirstNameAttribute($value) { return ucfirst($value); } } As you can see, the original value of the column is passed to the accessor, allowing you to manipulate and return the value. To access the value of the accessor, you may access the first_name attribute on a model instance: $user = App\\User::find(1); $firstName = $user->first_name; You may also use accessors to return new, computed values from existing attributes: /* * Get the user's full name. * * @return string / public function getFullNameAttribute() { return \"{$this->first_name} {$this->last_name}\"; } If you would like these computed values to be added to the array / JSON representations of your model, you will need to append them. Defining A Mutator To define a mutator, define a setFooAttribute method on your model where Foo is the \"studly\" cased name of the column you wish to access. So, again, let's define a mutator for the first_name attribute. This mutator will be automatically called when we attempt to set the value of the first_name attribute on the model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Set the user's first name. * * @param string $value * @return void / public function setFirstNameAttribute($value) { $this->attributes['first_name'] = strtolower($value); } } The mutator will receive the value that is being set on the attribute, allowing you to manipulate the value and set the manipulated value on the Eloquent model's internal $attributes property. So, for example, if we attempt to set the first_name attribute to Sally: $user = App\\User::find(1); $user->first_name = 'Sally'; In this example, the setFirstNameAttribute function will be called with the value Sally. The mutator will then apply the strtolower function to the name and set its resulting value in the internal $attributes array. Date Mutators By default, Eloquent will convert the created_at and updated_at columns to instances of Carbon, which extends the PHP DateTime class and provides an assortment of helpful methods. You may add additional date attributes by setting the $dates property of your model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The attributes that should be mutated to dates. * * @var array / protected $dates = [ 'seen_at', ]; } You may disable the default created_at and updated_at timestamps by setting the public $timestamps property of your model to false. When a column is considered a date, you may set its value to a UNIX timestamp, date string (Y-m-d), date-time string, or a DateTime / Carbon instance. The date's value will be correctly converted and stored in your database: $user = App\\User::find(1); $user->deleted_at = now(); $user->save(); As noted above, when retrieving attributes that are listed in your $dates property, they will automatically be cast to Carbon instances, allowing you to use any of Carbon's methods on your attributes: $user = App\\User::find(1); return $user->deleted_at->getTimestamp(); Date Formats By default, timestamps are formatted as 'Y-m-d H:i:s'. If you need to customize the timestamp format, set the $dateFormat property on your model. This property determines how date attributes are stored in the database, as well as their format when the model is serialized to an array or JSON: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The storage format of the model's date columns. * * @var string / protected $dateFormat = 'U'; } Attribute Casting The $casts property on your model provides a convenient method of converting attributes to common data types. The $casts property should be an array where the key is the name of the attribute being cast and the value is the type you wish to cast the column to. The supported cast types are: integer, real, float, double, decimal: , string, boolean, object, array, collection, date, datetime, and timestamp. When casting to decimal, you must define the number of digits (decimal:2). To demonstrate attribute casting, let's cast the is_admin attribute, which is stored in our database as an integer (0 or 1) to a boolean value: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The attributes that should be cast to native types. * * @var array / protected $casts = [ 'is_admin' => 'boolean', ]; } Now the is_admin attribute will always be cast to a boolean when you access it, even if the underlying value is stored in the database as an integer: $user = App\\User::find(1); if ($user->is_admin) { // } Array & JSON Casting The array cast type is particularly useful when working with columns that are stored as serialized JSON. For example, if your database has a JSON or TEXT field type that contains serialized JSON, adding the array cast to that attribute will automatically deserialize the attribute to a PHP array when you access it on your Eloquent model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The attributes that should be cast to native types. * * @var array / protected $casts = [ 'options' => 'array', ]; } Once the cast is defined, you may access the options attribute and it will automatically be deserialized from JSON into a PHP array. When you set the value of the options attribute, the given array will automatically be serialized back into JSON for storage: $user = App\\User::find(1); $options = $user->options; $options['key'] = 'value'; $user->options = $options; $user->save(); Date Casting When using the date or datetime cast type, you may specify the date's format. This format will be used when the model is serialized to an array or JSON: /* * The attributes that should be cast to native types. * * @var array / protected $casts = [ 'created_at' => 'datetime:Y-m-d', ];","title":"Laravel Eloquent"},{"location":"developerdoc/laravel_eloquent/#laravel-eloquent","text":"Introduction The Eloquent ORM included with Laravel provides a beautiful, simple ActiveRecord implementation for working with your database. Each database table has a corresponding \"Model\" which is used to interact with that table. Models allow you to query for data in your tables, as well as insert new records into the table. Before getting started, be sure to configure a database connection in config/database.php. For more information on configuring your database, check out the documentation. Defining Models To get started, let's create an Eloquent model. Models typically live in the app directory, but you are free to place them anywhere that can be auto-loaded according to your composer.json file. All Eloquent models extend Illuminate\\Database\\Eloquent\\Model class. The easiest way to create a model instance is using the make:model Artisan command: php artisan make:model Flight If you would like to generate a database migration when you generate the model, you may use the --migration or -m option: php artisan make:model Flight --migration php artisan make:model Flight -m Eloquent Model Conventions Now, let's look at an example Flight model, which we will use to retrieve and store information from our flights database table: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { // } Table Names Note that we did not tell Eloquent which table to use for our Flight model. By convention, the \"snake case\", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the Flight model stores records in the flights table. You may specify a custom table by defining a table property on your model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The table associated with the model. * * @var string / protected $table = 'my_flights'; } Primary Keys Eloquent will also assume that each table has a primary key column named id. You may define a protected $primaryKey property to override this convention: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The primary key associated with the table. * * @var string / protected $primaryKey = 'flight_id'; } In addition, Eloquent assumes that the primary key is an incrementing integer value, which means that by default the primary key will automatically be cast to an int. If you wish to use a non-incrementing or a non-numeric primary key you must set the public $incrementing property on your model to false: class Flight extends Model { /* * Indicates if the IDs are auto-incrementing. * * @var bool / public $incrementing = false; } If your primary key is not an integer, you should set the protected $keyType property on your model to string: class Flight extends Model { /* * The \"type\" of the auto-incrementing ID. * * @var string / protected $keyType = 'string'; } Timestamps By default, Eloquent expects created_at and updated_at columns to exist on your tables. If you do not wish to have these columns automatically managed by Eloquent, set the $timestamps property on your model to false: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * Indicates if the model should be timestamped. * * @var bool / public $timestamps = false; } If you need to customize the format of your timestamps, set the $dateFormat property on your model. This property determines how date attributes are stored in the database, as well as their format when the model is serialized to an array or JSON: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The storage format of the model's date columns. * * @var string / protected $dateFormat = 'U'; } If you need to customize the names of the columns used to store the timestamps, you may set the CREATED_AT and UPDATED_AT constants in your model: class Flight extends Model { const CREATED_AT = 'creation_date'; const UPDATED_AT = 'last_update'; } Database Connection By default, all Eloquent models will use the default database connection configured for your application. If you would like to specify a different connection for the model, use the $connection property: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The connection name for the model. * * @var string / protected $connection = 'connection-name'; } Default Attribute Values If you would like to define the default values for some of your model's attributes, you may define an $attributes property on your model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The model's default values for attributes. * * @var array / protected $attributes = [ 'delayed' => false, ]; } Retrieving Models Once you have created a model and its associated database table, you are ready to start retrieving data from your database. Think of each Eloquent model as a powerful query builder allowing you to fluently query the database table associated with the model. For example: $flights = App\\Flight::all(); foreach ($flights as $flight) { echo $flight->name; } Adding Additional Constraints The Eloquent all method will return all of the results in the model's table. Since each Eloquent model serves as a query builder, you may also add constraints to queries, and then use the get method to retrieve the results: $flights = App\\Flight::where('active', 1) ->orderBy('name', 'desc') ->take(10) ->get(); Since Eloquent models are query builders, you should review all of the methods available on the query builder. You may use any of these methods in your Eloquent queries. Refreshing Models You can refresh models using the fresh and refresh methods. The fresh method will re-retrieve the model from the database. The existing model instance will not be affected: $flight = App\\Flight::where('number', 'FR 900')->first(); $freshFlight = $flight->fresh(); The refresh method will re-hydrate the existing model using fresh data from the database. In addition, all of its loaded relationships will be refreshed as well: $flight = App\\Flight::where('number', 'FR 900')->first(); $flight->number = 'FR 456'; $flight->refresh(); $flight->number; // \"FR 900\" Collections For Eloquent methods like all and get which retrieve multiple results, an instance of Illuminate\\Database\\Eloquent\\Collection will be returned. The Collection class provides a variety of helpful methods for working with your Eloquent results: $flights = $flights->reject(function ($flight) { return $flight->cancelled; }); You may also loop over the collection like an array: foreach ($flights as $flight) { echo $flight->name; } Chunking Results If you need to process thousands of Eloquent records, use the chunk command. The chunk method will retrieve a \"chunk\" of Eloquent models, feeding them to a given Closure for processing. Using the chunk method will conserve memory when working with large result sets: Flight::chunk(200, function ($flights) { foreach ($flights as $flight) { // } }); The first argument passed to the method is the number of records you wish to receive per \"chunk\". The Closure passed as the second argument will be called for each chunk that is retrieved from the database. A database query will be executed to retrieve each chunk of records passed to the Closure. Using Cursors The cursor method allows you to iterate through your database records using a cursor, which will only execute a single query. When processing large amounts of data, the cursor method may be used to greatly reduce your memory usage: foreach (Flight::where('foo', 'bar')->cursor() as $flight) { // } Retrieving Single Models / Aggregates In addition to retrieving all of the records for a given table, you may also retrieve single records using find or first. Instead of returning a collection of models, these methods return a single model instance: // Retrieve a model by its primary key... $flight = App\\Flight::find(1); // Retrieve the first model matching the query constraints... $flight = App\\Flight::where('active', 1)->first(); You may also call the find method with an array of primary keys, which will return a collection of the matching records: $flights = App\\Flight::find([1, 2, 3]); Not Found Exceptions Sometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers. The findOrFail and firstOrFail methods will retrieve the first result of the query; however, if no result is found, a Illuminate\\Database\\Eloquent\\ModelNotFoundException will be thrown: $model = App\\Flight::findOrFail(1); $model = App\\Flight::where('legs', '>', 100)->firstOrFail(); If the exception is not caught, a 404 HTTP response is automatically sent back to the user. It is not necessary to write explicit checks to return 404 responses when using these methods: Route::get('/api/flights/{id}', function ($id) { return App\\Flight::findOrFail($id); }); Retrieving Aggregates You may also use the count, sum, max, and other aggregate methods provided by the query builder. These methods return the appropriate scalar value instead of a full model instance: $count = App\\Flight::where('active', 1)->count(); $max = App\\Flight::where('active', 1)->max('price'); Inserting & Updating Models Inserts To create a new record in the database, create a new model instance, set attributes on the model, then call the save method: namespace App\\Http\\Controllers; use App\\Flight; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class FlightController extends Controller { /* * Create a new flight instance. * * @param Request $request * @return Response / public function store(Request $request) { // Validate the request... $flight = new Flight; $flight->name = $request->name; $flight->save(); } } In this example, we assign the name parameter from the incoming HTTP request to the name attribute of the App\\Flight model instance. When we call the save method, a record will be inserted into the database. The created_at and updated_at timestamps will automatically be set when the save method is called, so there is no need to set them manually. Updates The save method may also be used to update models that already exist in the database. To update a model, you should retrieve it, set any attributes you wish to update, and then call the save method. Again, the updated_at timestamp will automatically be updated, so there is no need to manually set its value: $flight = App\\Flight::find(1); $flight->name = 'New Flight Name'; $flight->save(); Mass Updates Updates can also be performed against any number of models that match a given query. In this example, all flights that are active and have a destination of San Diego will be marked as delayed: App\\Flight::where('active', 1) ->where('destination', 'San Diego') ->update(['delayed' => 1]); The update method expects an array of column and value pairs representing the columns that should be updated. When issuing a mass update via Eloquent, the saving, saved, updating, and updated model events will not be fired for the updated models. This is because the models are never actually retrieved when issuing a mass update. Mass Assignment You may also use the create method to save a new model in a single line. The inserted model instance will be returned to you from the method. However, before doing so, you will need to specify either a fillable or guarded attribute on the model, as all Eloquent models protect against mass-assignment by default. A mass-assignment vulnerability occurs when a user passes an unexpected HTTP parameter through a request, and that parameter changes a column in your database you did not expect. For example, a malicious user might send an is_admin parameter through an HTTP request, which is then passed into your model's create method, allowing the user to escalate themselves to an administrator. So, to get started, you should define which model attributes you want to make mass assignable. You may do this using the $fillable property on the model. For example, let's make the name attribute of our Flight model mass assignable: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The attributes that are mass assignable. * * @var array / protected $fillable = ['name']; } Once we have made the attributes mass assignable, we can use the create method to insert a new record in the database. The create method returns the saved model instance: $flight = App\\Flight::create(['name' => 'Flight 10']); If you already have a model instance, you may use the fill method to populate it with an array of attributes: $flight->fill(['name' => 'Flight 22']); Guarding Attributes While $fillable serves as a \"white list\" of attributes that should be mass assignable, you may also choose to use $guarded. The $guarded property should contain an array of attributes that you do not want to be mass assignable. All other attributes not in the array will be mass assignable. So, $guarded functions like a \"black list\". Importantly, you should use either $fillable or $guarded - not both. In the example below, all attributes except for price will be mass assignable: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The attributes that aren't mass assignable. * * @var array / protected $guarded = ['price']; } If you would like to make all attributes mass assignable, you may define the $guarded property as an empty array: /* * The attributes that aren't mass assignable. * * @var array / protected $guarded = []; Other Creation Methods firstOrCreate/ firstOrNew There are two other methods you may use to create models by mass assigning attributes: firstOrCreate and firstOrNew. The firstOrCreate method will attempt to locate a database record using the given column / value pairs. If the model can not be found in the database, a record will be inserted with the attributes from the first parameter, along with those in the optional second parameter. The firstOrNew method, like firstOrCreate will attempt to locate a record in the database matching the given attributes. However, if a model is not found, a new model instance will be returned. Note that the model returned by firstOrNew has not yet been persisted to the database. You will need to call save manually to persist it: // Retrieve flight by name, or create it if it doesn't exist... $flight = App\\Flight::firstOrCreate(['name' => 'Flight 10']); // Retrieve flight by name, or create it with the name, delayed, and arrival_time attributes... $flight = App\\Flight::firstOrCreate( ['name' => 'Flight 10'], ['delayed' => 1, 'arrival_time' => '11:30'] ); // Retrieve by name, or instantiate... $flight = App\\Flight::firstOrNew(['name' => 'Flight 10']); // Retrieve by name, or instantiate with the name, delayed, and arrival_time attributes... $flight = App\\Flight::firstOrNew( ['name' => 'Flight 10'], ['delayed' => 1, 'arrival_time' => '11:30'] ); updateOrCreate You may also come across situations where you want to update an existing model or create a new model if none exists. Laravel provides an updateOrCreate method to do this in one step. Like the firstOrCreate method, updateOrCreate persists the model, so there's no need to call save(): // If there's a flight from Oakland to San Diego, set the price to $99. // If no matching model exists, create one. $flight = App\\Flight::updateOrCreate( ['departure' => 'Oakland', 'destination' => 'San Diego'], ['price' => 99, 'discounted' => 1] ); Deleting Models To delete a model, call the delete method on a model instance: $flight = App\\Flight::find(1); $flight->delete(); Deleting An Existing Model By Key In the example above, we are retrieving the model from the database before calling the delete method. However, if you know the primary key of the model, you may delete the model without retrieving it by calling the destroy method. In addition to a single primary key as its argument, the destroy method will accept multiple primary keys, an array of primary keys, or a collection of primary keys: App\\Flight::destroy(1); App\\Flight::destroy(1, 2, 3); App\\Flight::destroy([1, 2, 3]); App\\Flight::destroy(collect([1, 2, 3])); Deleting Models By Query You can also run a delete statement on a set of models. In this example, we will delete all flights that are marked as inactive. Like mass updates, mass deletes will not fire any model events for the models that are deleted: $deletedRows = App\\Flight::where('active', 0)->delete(); When executing a mass delete statement via Eloquent, the deleting and deleted model events will not be fired for the deleted models. This is because the models are never actually retrieved when executing the delete statement. Soft Deleting In addition to actually removing records from your database, Eloquent can also \"soft delete\" models. When models are soft deleted, they are not actually removed from your database. Instead, a deleted_at attribute is set on the model and inserted into the database. If a model has a non-null deleted_at value, the model has been soft deleted. To enable soft deletes for a model, use the Illuminate\\Database\\Eloquent\\SoftDeletes trait on the model: namespace App; use Illuminate\\Database\\Eloquent\\Model; use Illuminate\\Database\\Eloquent\\SoftDeletes; class Flight extends Model { use SoftDeletes; } The SoftDeletes trait will automatically cast the deleted_at attribute to a DateTime / Carbon instance for you. You should also add the deleted_at column to your database table. The Laravel schema builder contains a helper method to create this column: Schema::table('flights', function (Blueprint $table) { $table->softDeletes(); }); Now, when you call the delete method on the model, the deleted_at column will be set to the current date and time. And, when querying a model that uses soft deletes, the soft deleted models will automatically be excluded from all query results. To determine if a given model instance has been soft deleted, use the trashed method: if ($flight->trashed()) { // } Querying Soft Deleted Models Including Soft Deleted Models As noted above, soft deleted models will automatically be excluded from query results. However, you may force soft deleted models to appear in a result set using the withTrashed method on the query: $flights = App\\Flight::withTrashed() ->where('account_id', 1) ->get(); The withTrashed method may also be used on a relationship query: $flight->history()->withTrashed()->get(); Retrieving Only Soft Deleted Models The onlyTrashed method will retrieve only soft deleted models: $flights = App\\Flight::onlyTrashed() ->where('airline_id', 1) ->get(); Restoring Soft Deleted Models Sometimes you may wish to \"un-delete\" a soft deleted model. To restore a soft deleted model into an active state, use the restore method on a model instance: $flight->restore(); You may also use the restore method in a query to quickly restore multiple models. Again, like other \"mass\" operations, this will not fire any model events for the models that are restored: App\\Flight::withTrashed() ->where('airline_id', 1) ->restore(); Like the withTrashed method, the restore method may also be used on relationships: $flight->history()->restore(); Permanently Deleting Models Sometimes you may need to truly remove a model from your database. To permanently remove a soft deleted model from the database, use the forceDelete method: // Force deleting a single model instance... $flight->forceDelete(); // Force deleting all related models... $flight->history()->forceDelete(); Query Scopes Global Scopes Global scopes allow you to add constraints to all queries for a given model. Laravel's own soft delete functionality utilizes global scopes to only pull \"non-deleted\" models from the database. Writing your own global scopes can provide a convenient, easy way to make sure every query for a given model receives certain constraints. Writing Global Scopes Writing a global scope is simple. Define a class that implements the Illuminate\\Database\\Eloquent\\Scope interface. This interface requires you to implement one method: apply. The apply method may add where constraints to the query as needed: namespace App\\Scopes; use Illuminate\\Database\\Eloquent\\Scope; use Illuminate\\Database\\Eloquent\\Model; use Illuminate\\Database\\Eloquent\\Builder; class AgeScope implements Scope { /* * Apply the scope to a given Eloquent query builder. * * @param \\Illuminate\\Database\\Eloquent\\Builder $builder * @param \\Illuminate\\Database\\Eloquent\\Model $model * @return void / public function apply(Builder $builder, Model $model) { $builder->where('age', '>', 200); } } If your global scope is adding columns to the select clause of the query, you should use the addSelect method instead of select. This will prevent the unintentional replacement of the query's existing select clause. Applying Global Scopes To assign a global scope to a model, you should override a given model's boot method and use the addGlobalScope method: namespace App; use App\\Scopes\\AgeScope; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The \"booting\" method of the model. * * @return void / protected static function boot() { parent::boot(); static::addGlobalScope(new AgeScope); } } After adding the scope, a query to User::all() will produce the following SQL: select * from users where age > 200 Anonymous Global Scopes Eloquent also allows you to define global scopes using Closures, which is particularly useful for simple scopes that do not warrant a separate class: namespace App; use Illuminate\\Database\\Eloquent\\Model; use Illuminate\\Database\\Eloquent\\Builder; class User extends Model { /* * The \"booting\" method of the model. * * @return void / protected static function boot() { parent::boot(); static::addGlobalScope('age', function (Builder $builder) { $builder->where('age', '>', 200); }); } } Removing Global Scopes If you would like to remove a global scope for a given query, you may use the withoutGlobalScope method. The method accepts the class name of the global scope as its only argument: User::withoutGlobalScope(AgeScope::class)->get(); Or, if you defined the global scope using a Closure: User::withoutGlobalScope('age')->get(); If you would like to remove several or even all of the global scopes, you may use the withoutGlobalScopes method: // Remove all of the global scopes... User::withoutGlobalScopes()->get(); // Remove some of the global scopes... User::withoutGlobalScopes([ FirstScope::class, SecondScope::class ])->get(); Local Scopes Local scopes allow you to define common sets of constraints that you may easily re-use throughout your application. For example, you may need to frequently retrieve all users that are considered \"popular\". To define a scope, prefix an Eloquent model method with scope. Scopes should always return a query builder instance: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Scope a query to only include popular users. * * @param \\Illuminate\\Database\\Eloquent\\Builder $query * @return \\Illuminate\\Database\\Eloquent\\Builder / public function scopePopular($query) { return $query->where('votes', '>', 100); } /** * Scope a query to only include active users. * * @param \\Illuminate\\Database\\Eloquent\\Builder $query * @return \\Illuminate\\Database\\Eloquent\\Builder */ public function scopeActive($query) { return $query->where('active', 1); } } Utilizing A Local Scope Once the scope has been defined, you may call the scope methods when querying the model. However, you should not include the scope prefix when calling the method. You can even chain calls to various scopes, for example: $users = App\\User::popular()->active()->orderBy('created_at')->get(); Combining multiple Eloquent model scopes via an or query operator may require the use of Closure callbacks: $users = App\\User::popular()->orWhere(function (Builder $query) { $query->active(); })->get(); However, since this can be cumbersome, Laravel provides a \"higher order\" orWhere method that allows you to fluently chain these scopes together without the use of Closures: $users = App\\User::popular()->orWhere->active()->get(); Dynamic Scopes Sometimes you may wish to define a scope that accepts parameters. To get started, just add your additional parameters to your scope. Scope parameters should be defined after the $query parameter: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Scope a query to only include users of a given type. * * @param \\Illuminate\\Database\\Eloquent\\Builder $query * @param mixed $type * @return \\Illuminate\\Database\\Eloquent\\Builder / public function scopeOfType($query, $type) { return $query->where('type', $type); } } Now, you may pass the parameters when calling the scope: $users = App\\User::ofType('admin')->get(); Comparing Models Sometimes you may need to determine if two models are the \"same\". The is method may be used to quickly verify two models have same primary key, table, and database connection: if ($post->is($anotherPost)) { // } Events Eloquent models fire several events, allowing you to hook into the following points in a model's lifecycle: retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, restoring, restored. Events allow you to easily execute code each time a specific model class is saved or updated in the database. Each event receives the instance of the model through its constructor. The retrieved event will fire when an existing model is retrieved from the database. When a new model is saved for the first time, the creating and created events will fire. If a model already existed in the database and the save method is called, the updating / updated events will fire. However, in both cases, the saving / saved events will fire. When issuing a mass update via Eloquent, the saved and updated model events will not be fired for the updated models. This is because the models are never actually retrieved when issuing a mass update. To get started, define a $dispatchesEvents property on your Eloquent model that maps various points of the Eloquent model's lifecycle to your own event classes: namespace App; use App\\Events\\UserSaved; use App\\Events\\UserDeleted; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * The event map for the model. * * @var array */ protected $dispatchesEvents = [ 'saved' => UserSaved::class, 'deleted' => UserDeleted::class, ]; } After defining and mapping your Eloquent events, you may use event listeners to handle the events. Observers Defining Observers If you are listening for many events on a given model, you may use observers to group all of your listeners into a single class. Observers classes have method names which reflect the Eloquent events you wish to listen for. Each of these methods receives the model as their only argument. The make:observer Artisan command is the easiest way to create a new observer class: php artisan make:observer UserObserver --model=User This command will place the new observer in your App/Observers directory. If this directory does not exist, Artisan will create it for you. Your fresh observer will look like the following: namespace App\\Observers; use App\\User; class UserObserver { /* * Handle the User \"created\" event. * * @param \\App\\User $user * @return void / public function created(User $user) { // } /** * Handle the User \"updated\" event. * * @param \\App\\User $user * @return void */ public function updated(User $user) { // } /** * Handle the User \"deleted\" event. * * @param \\App\\User $user * @return void */ public function deleted(User $user) { // } } To register an observer, use the observe method on the model you wish to observe. You may register observers in the boot method of one of your service providers. In this example, we'll register the observer in the AppServiceProvider: namespace App\\Providers; use App\\User; use App\\Observers\\UserObserver; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /* * Register any application services. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { User::observe(UserObserver::class); } }","title":"Laravel Eloquent"},{"location":"developerdoc/laravel_eloquent/#relationship","text":"Introduction Database tables are often related to one another. For example, a blog post may have many comments, or an order could be related to the user who placed it. Eloquent makes managing and working with these relationships easy, and supports several different types of relationships: One To One One To Many Many To Many Has One Through Has Many Through One To One (Polymorphic) One To Many (Polymorphic) Many To Many (Polymorphic) Defining Relationships Eloquent relationships are defined as methods on your Eloquent model classes. Since, like Eloquent models themselves, relationships also serve as powerful query builders, defining relationships as methods provides powerful method chaining and querying capabilities. For example, we may chain additional constraints on this posts relationship: $user->posts()->where('active', 1)->get(); But, before diving too deep into using relationships, let's learn how to define each type. One To One A one-to-one relationship is a very basic relation. For example, a User model might be associated with one Phone. To define this relationship, we place a phone method on the User model. The phone method should call the hasOne method and return its result: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Get the phone record associated with the user. / public function phone() { return $this->hasOne('App\\Phone'); } } The first argument passed to the hasOne method is the name of the related model. Once the relationship is defined, we may retrieve the related record using Eloquent's dynamic properties. Dynamic properties allow you to access relationship methods as if they were properties defined on the model: $phone = User::find(1)->phone; Eloquent determines the foreign key of the relationship based on the model name. In this case, the Phone model is automatically assumed to have a user_id foreign key. If you wish to override this convention, you may pass a second argument to the hasOne method: return $this->hasOne('App\\Phone', 'foreign_key'); Additionally, Eloquent assumes that the foreign key should have a value matching the id (or the custom $primaryKey) column of the parent. In other words, Eloquent will look for the value of the user's id column in the user_id column of the Phone record. If you would like the relationship to use a value other than id, you may pass a third argument to the hasOne method specifying your custom key: return $this->hasOne('App\\Phone', 'foreign_key', 'local_key'); Defining The Inverse Of The Relationship So, we can access the Phone model from our User. Now, let's define a relationship on the Phone model that will let us access the User that owns the phone. We can define the inverse of a hasOne relationship using the belongsTo method: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Phone extends Model { /* * Get the user that owns the phone. / public function user() { return $this->belongsTo('App\\User'); } } In the example above, Eloquent will try to match the user_id from the Phone model to an id on the User model. Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with _id. However, if the foreign key on the Phone model is not user_id, you may pass a custom key name as the second argument to the belongsTo method: /* * Get the user that owns the phone. / public function user() { return $this->belongsTo('App\\User', 'foreign_key'); } If your parent model does not use id as its primary key, or you wish to join the child model to a different column, you may pass a third argument to the belongsTo method specifying your parent table's custom key: /* * Get the user that owns the phone. / public function user() { return $this->belongsTo('App\\User', 'foreign_key', 'other_key'); } One To Many A one-to-many relationship is used to define relationships where a single model owns any amount of other models. For example, a blog post may have an infinite number of comments. Like all other Eloquent relationships, one-to-many relationships are defined by placing a function on your Eloquent model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Post extends Model { /* * Get the comments for the blog post. / public function comments() { return $this->hasMany('App\\Comment'); } } Remember, Eloquent will automatically determine the proper foreign key column on the Comment model. By convention, Eloquent will take the \"snake case\" name of the owning model and suffix it with _id. So, for this example, Eloquent will assume the foreign key on the Comment model is post_id. Once the relationship has been defined, we can access the collection of comments by accessing the comments property. Remember, since Eloquent provides \"dynamic properties\", we can access relationship methods as if they were defined as properties on the model: $comments = App\\Post::find(1)->comments; foreach ($comments as $comment) { // } Since all relationships also serve as query builders, you can add further constraints to which comments are retrieved by calling the comments method and continuing to chain conditions onto the query: $comment = App\\Post::find(1)->comments()->where('title', 'foo')->first(); Like the hasOne method, you may also override the foreign and local keys by passing additional arguments to the hasMany method: return $this->hasMany('App\\Comment', 'foreign_key'); return $this->hasMany('App\\Comment', 'foreign_key', 'local_key'); One To Many (Inverse) Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a hasMany relationship, define a relationship function on the child model which calls the belongsTo method: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Comment extends Model { /* * Get the post that owns the comment. / public function post() { return $this->belongsTo('App\\Post'); } } Once the relationship has been defined, we can retrieve the Post model for a Comment by accessing the post \"dynamic property\": $comment = App\\Comment::find(1); echo $comment->post->title; In the example above, Eloquent will try to match the post_id from the Comment model to an id on the Post model. Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with a _ followed by the name of the primary key column. However, if the foreign key on the Comment model is not post_id, you may pass a custom key name as the second argument to the belongsTo method: /* * Get the post that owns the comment. / public function post() { return $this->belongsTo('App\\Post', 'foreign_key'); } If your parent model does not use id as its primary key, or you wish to join the child model to a different column, you may pass a third argument to the belongsTo method specifying your parent table's custom key: /* * Get the post that owns the comment. / public function post() { return $this->belongsTo('App\\Post', 'foreign_key', 'other_key'); } Many To Many Many-to-many relations are slightly more complicated than hasOne and hasMany relationships. An example of such a relationship is a user with many roles, where the roles are also shared by other users. For example, many users may have the role of \"Admin\". To define this relationship, three database tables are needed: users, roles, and role_user. The role_user table is derived from the alphabetical order of the related model names, and contains the user_id and role_id columns. Many-to-many relationships are defined by writing a method that returns the result of the belongsToMany method. For example, let's define the roles method on our User model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The roles that belong to the user. / public function roles() { return $this->belongsToMany('App\\Role'); } } Once the relationship is defined, you may access the user's roles using the roles dynamic property: $user = App\\User::find(1); foreach ($user->roles as $role) { // } Like all other relationship types, you may call the roles method to continue chaining query constraints onto the relationship: $roles = App\\User::find(1)->roles()->orderBy('name')->get(); As mentioned previously, to determine the table name of the relationship's joining table, Eloquent will join the two related model names in alphabetical order. However, you are free to override this convention. You may do so by passing a second argument to the belongsToMany method: return $this->belongsToMany('App\\Role', 'role_user'); In addition to customizing the name of the joining table, you may also customize the column names of the keys on the table by passing additional arguments to the belongsToMany method. The third argument is the foreign key name of the model on which you are defining the relationship, while the fourth argument is the foreign key name of the model that you are joining to: return $this->belongsToMany('App\\Role', 'role_user', 'user_id', 'role_id'); Defining The Inverse Of The Relationship To define the inverse of a many-to-many relationship, you place another call to belongsToMany on your related model. To continue our user roles example, let's define the users method on the Role model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Role extends Model { /* * The users that belong to the role. / public function users() { return $this->belongsToMany('App\\User'); } } As you can see, the relationship is defined exactly the same as its User counterpart, with the exception of referencing the App\\User model. Since we're reusing the belongsToMany method, all of the usual table and key customization options are available when defining the inverse of many-to-many relationships. Retrieving Intermediate Table Columns As you have already learned, working with many-to-many relations requires the presence of an intermediate table. Eloquent provides some very helpful ways of interacting with this table. For example, let's assume our User object has many Role objects that it is related to. After accessing this relationship, we may access the intermediate table using the pivot attribute on the models: $user = App\\User::find(1); foreach ($user->roles as $role) { echo $role->pivot->created_at; } Notice that each Role model we retrieve is automatically assigned a pivot attribute. This attribute contains a model representing the intermediate table, and may be used like any other Eloquent model. By default, only the model keys will be present on the pivot object. If your pivot table contains extra attributes, you must specify them when defining the relationship: return $this->belongsToMany('App\\Role')->withPivot('column1', 'column2'); If you want your pivot table to have automatically maintained created_at and updated_at timestamps, use the withTimestamps method on the relationship definition: return $this->belongsToMany('App\\Role')->withTimestamps(); Customizing The pivot Attribute Name As noted earlier, attributes from the intermediate table may be accessed on models using the pivot attribute. However, you are free to customize the name of this attribute to better reflect its purpose within your application. For example, if your application contains users that may subscribe to podcasts, you probably have a many-to-many relationship between users and podcasts. If this is the case, you may wish to rename your intermediate table accessor to subscription instead of pivot. This can be done using the as method when defining the relationship: return $this->belongsToMany('App\\Podcast') ->as('subscription') ->withTimestamps(); Once this is done, you may access the intermediate table data using the customized name: $users = User::with('podcasts')->get(); foreach ($users->flatMap->podcasts as $podcast) { echo $podcast->subscription->created_at; } Filtering Relationships Via Intermediate Table Columns You can also filter the results returned by belongsToMany using the wherePivot and wherePivotIn methods when defining the relationship: return $this->belongsToMany('App\\Role')->wherePivot('approved', 1); return $this->belongsToMany('App\\Role')->wherePivotIn('priority', [1, 2]); Defining Custom Intermediate Table Models If you would like to define a custom model to represent the intermediate table of your relationship, you may call the using method when defining the relationship. Custom many-to-many pivot models should extend the Illuminate\\Database\\Eloquent\\Relations\\Pivot class while custom polymorphic many-to-many pivot models should extend the Illuminate\\Database\\Eloquent\\Relations\\MorphPivot class. For example, we may define a Role which uses a custom RoleUser pivot model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Role extends Model { /* * The users that belong to the role. / public function users() { return $this->belongsToMany('App\\User')->using('App\\RoleUser'); } } When defining the RoleUser model, we will extend the Pivot class: namespace App; use Illuminate\\Database\\Eloquent\\Relations\\Pivot; class RoleUser extends Pivot { // } You can combine using and withPivot in order to retrieve columns from the intermediate table. For example, you may retrieve the created_by and updated_by columns from the RoleUser pivot table by passing the column names to the withPivot method: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Role extends Model { /* * The users that belong to the role. / public function users() { return $this->belongsToMany('App\\User') ->using('App\\RoleUser') ->withPivot([ 'created_by', 'updated_by' ]); } } Note: Pivot models may not use the SoftDeletes trait. If you need to soft delete pivot records consider converting your pivot model to an actual Eloquent model. Custom Pivot Models And Incrementing IDs If you have defined a many-to-many relationship that uses a custom pivot model, and that pivot model has an auto-incrementing primary key, you should ensure your custom pivot model class defines an incrementing property that is set to true. /* * Indicates if the IDs are auto-incrementing. * * @var bool / public $incrementing = true; Has One Through The \"has-one-through\" relationship links models through a single intermediate relation. For example, if each supplier has one user, and each user is associated with one user history record, then the supplier model may access the user's history through the user. Let's look at the database tables necessary to define this relationship: users id - integer supplier_id - integer suppliers id - integer history id - integer user_id - integer Though the history table does not contain a supplier_id column, the hasOneThrough relation can provide access to the user's history to the supplier model. Now that we have examined the table structure for the relationship, let's define it on the Supplier model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Supplier extends Model { /* * Get the user's history. / public function userHistory() { return $this->hasOneThrough('App\\History', 'App\\User'); } } The first argument passed to the hasOneThrough method is the name of the final model we wish to access, while the second argument is the name of the intermediate model. Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the hasOneThrough method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model: class Supplier extends Model { /* * Get the user's history. / public function userHistory() { return $this->hasOneThrough( 'App\\History', 'App\\User', 'supplier_id', // Foreign key on users table... 'user_id', // Foreign key on history table... 'id', // Local key on suppliers table... 'id' // Local key on users table... ); } } Has Many Through The \"has-many-through\" relationship provides a convenient shortcut for accessing distant relations via an intermediate relation. For example, a Country model might have many Post models through an intermediate User model. In this example, you could easily gather all blog posts for a given country. Let's look at the tables required to define this relationship: countries id - integer name - string users id - integer country_id - integer name - string posts id - integer user_id - integer title - string Though posts does not contain a country_id column, the hasManyThrough relation provides access to a country's posts via $country->posts. To perform this query, Eloquent inspects the country_id on the intermediate users table. After finding the matching user IDs, they are used to query the posts table. Now that we have examined the table structure for the relationship, let's define it on the Country model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Country extends Model { /* * Get all of the posts for the country. / public function posts() { return $this->hasManyThrough('App\\Post', 'App\\User'); } } The first argument passed to the hasManyThrough method is the name of the final model we wish to access, while the second argument is the name of the intermediate model. Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the hasManyThrough method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model: class Country extends Model { public function posts() { return $this->hasManyThrough( 'App\\Post', 'App\\User', 'country_id', // Foreign key on users table... 'user_id', // Foreign key on posts table... 'id', // Local key on countries table... 'id' // Local key on users table... ); } } Polymorphic Relationships A polymorphic relationship allows the target model to belong to more than one type of model using a single association. One To One (Polymorphic) Table Structure A one-to-one polymorphic relation is similar to a simple one-to-one relation; however, the target model can belong to more than one type of model on a single association. For example, a blog Post and a User may share a polymorphic relation to an Image model. Using a one-to-one polymorphic relation allows you to have a single list of unique images that are used for both blog posts and user accounts. First, let's examine the table structure: posts id - integer name - string users id - integer name - string images id - integer url - string imageable_id - integer imageable_type - string Take note of the imageable_id and imageable_type columns on the images table. The imageable_id column will contain the ID value of the post or user, while the imageable_type column will contain the class name of the parent model. The imageable_type column is used by Eloquent to determine which \"type\" of parent model to return when accessing the imageable relation. Model Structure Next, let's examine the model definitions needed to build this relationship: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Image extends Model { /* * Get the owning imageable model. / public function imageable() { return $this->morphTo(); } } class Post extends Model { /* * Get the post's image. / public function image() { return $this->morphOne('App\\Image', 'imageable'); } } class User extends Model { /* * Get the user's image. / public function image() { return $this->morphOne('App\\Image', 'imageable'); } } Retrieving The Relationship Once your database table and models are defined, you may access the relationships via your models. For example, to retrieve the image for a post, we can use the image dynamic property: $post = App\\Post::find(1); $image = $post->image; You may also retrieve the parent from the polymorphic model by accessing the name of the method that performs the call to morphTo. In our case, that is the imageable method on the Image model. So, we will access that method as a dynamic property: $image = App\\Image::find(1); $imageable = $image->imageable; The imageable relation on the Image model will return either a Post or User instance, depending on which type of model owns the image. One To Many (Polymorphic) Table Structure A one-to-many polymorphic relation is similar to a simple one-to-many relation; however, the target model can belong to more than one type of model on a single association. For example, imagine users of your application can \"comment\" on both posts and videos. Using polymorphic relationships, you may use a single comments table for both of these scenarios. First, let's examine the table structure required to build this relationship: posts id - integer title - string body - text videos id - integer title - string url - string comments id - integer body - text commentable_id - integer commentable_type - string Model Structure Next, let's examine the model definitions needed to build this relationship: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Comment extends Model { /* * Get the owning commentable model. / public function commentable() { return $this->morphTo(); } } class Post extends Model { /* * Get all of the post's comments. / public function comments() { return $this->morphMany('App\\Comment', 'commentable'); } } class Video extends Model { /* * Get all of the video's comments. / public function comments() { return $this->morphMany('App\\Comment', 'commentable'); } } Retrieving The Relationship Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the comments for a post, we can use the comments dynamic property: $post = App\\Post::find(1); foreach ($post->comments as $comment) { // } You may also retrieve the owner of a polymorphic relation from the polymorphic model by accessing the name of the method that performs the call to morphTo. In our case, that is the commentable method on the Comment model. So, we will access that method as a dynamic property: $comment = App\\Comment::find(1); $commentable = $comment->commentable; The commentable relation on the Comment model will return either a Post or Video instance, depending on which type of model owns the comment. Many To Many (Polymorphic) Table Structure Many-to-many polymorphic relations are slightly more complicated than morphOne and morphMany relationships. For example, a blog Post and Video model could share a polymorphic relation to a Tag model. Using a many-to-many polymorphic relation allows you to have a single list of unique tags that are shared across blog posts and videos. First, let's examine the table structure: posts id - integer name - string videos id - integer name - string tags id - integer name - string taggables tag_id - integer taggable_id - integer taggable_type - string Model Structure Next, we're ready to define the relationships on the model. The Post and Video models will both have a tags method that calls the morphToMany method on the base Eloquent class: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Post extends Model { /* * Get all of the tags for the post. / public function tags() { return $this->morphToMany('App\\Tag', 'taggable'); } } Defining The Inverse Of The Relationship Next, on the Tag model, you should define a method for each of its related models. So, for this example, we will define a posts method and a videos method: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Tag extends Model { /* * Get all of the posts that are assigned this tag. / public function posts() { return $this->morphedByMany('App\\Post', 'taggable'); } /** * Get all of the videos that are assigned this tag. */ public function videos() { return $this->morphedByMany('App\\Video', 'taggable'); } } Retrieving The Relationship Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the tags for a post, you can use the tags dynamic property: $post = App\\Post::find(1); foreach ($post->tags as $tag) { // } You may also retrieve the owner of a polymorphic relation from the polymorphic model by accessing the name of the method that performs the call to morphedByMany. In our case, that is the posts or videos methods on the Tag model. So, you will access those methods as dynamic properties: $tag = App\\Tag::find(1); foreach ($tag->videos as $video) { // } Custom Polymorphic Types By default, Laravel will use the fully qualified class name to store the type of the related model. For instance, given the one-to-many example above where a Comment may belong to a Post or a Video, the default commentable_type would be either App\\Post or App\\Video, respectively. However, you may wish to decouple your database from your application's internal structure. In that case, you may define a \"morph map\" to instruct Eloquent to use a custom name for each model instead of the class name: use Illuminate\\Database\\Eloquent\\Relations\\Relation; Relation::morphMap([ 'posts' => 'App\\Post', 'videos' => 'App\\Video', ]); You may register the morphMap in the boot function of your AppServiceProvider or create a separate service provider if you wish. When adding a \"morph map\" to your existing application, every morphable *_type column value in your database that still contains a fully-qualified class will need to be converted to its \"map\" name. Querying Relations Since all types of Eloquent relationships are defined via methods, you may call those methods to obtain an instance of the relationship without actually executing the relationship queries. In addition, all types of Eloquent relationships also serve as query builders, allowing you to continue to chain constraints onto the relationship query before finally executing the SQL against your database. For example, imagine a blog system in which a User model has many associated Post models: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Get all of the posts for the user. / public function posts() { return $this->hasMany('App\\Post'); } } You may query the posts relationship and add additional constraints to the relationship like so: $user = App\\User::find(1); $user->posts()->where('active', 1)->get(); You are able to use any of the query builder methods on the relationship, so be sure to explore the query builder documentation to learn about all of the methods that are available to you. Chaining orWhere Clauses After Relationships As demonstrated in the example above, you are free to add additional constraints to relationships when querying them. However, use caution when chaining orWhere clauses onto a relationship, as the orWhere clauses will be logically grouped at the same level as the relationship constraint: $user->posts() ->where('active', 1) ->orWhere('votes', '>=', 100) ->get(); // select * from posts // where user_id = ? and active = 1 or votes >= 100 In most situations, you likely intend to use constraint groups to logically group the conditional checks between parentheses: use Illuminate\\Database\\Eloquent\\Builder; $user->posts() ->where(function (Builder $query) { return $query->where('active', 1) ->orWhere('votes', '>=', 100); }) ->get(); // select * from posts // where user_id = ? and (active = 1 or votes >= 100) Relationship Methods Vs. Dynamic Properties If you do not need to add additional constraints to an Eloquent relationship query, you may access the relationship as if it were a property. For example, continuing to use our User and Post example models, we may access all of a user's posts like so: $user = App\\User::find(1); foreach ($user->posts as $post) { // } Dynamic properties are \"lazy loading\", meaning they will only load their relationship data when you actually access them. Because of this, developers often use eager loading to pre-load relationships they know will be accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to load a model's relations. Querying Relationship Existence When accessing the records for a model, you may wish to limit your results based on the existence of a relationship. For example, imagine you want to retrieve all blog posts that have at least one comment. To do so, you may pass the name of the relationship to the has and orHas methods: // Retrieve all posts that have at least one comment... $posts = App\\Post::has('comments')->get(); You may also specify an operator and count to further customize the query: // Retrieve all posts that have three or more comments... $posts = App\\Post::has('comments', '>=', 3)->get(); Nested has statements may also be constructed using \"dot\" notation. For example, you may retrieve all posts that have at least one comment and vote: // Retrieve posts that have at least one comment with votes... $posts = App\\Post::has('comments.votes')->get(); If you need even more power, you may use the whereHas and orWhereHas methods to put \"where\" conditions on your has queries. These methods allow you to add customized constraints to a relationship constraint, such as checking the content of a comment: use Illuminate\\Database\\Eloquent\\Builder; // Retrieve posts with at least one comment containing words like foo%... $posts = App\\Post::whereHas('comments', function (Builder $query) { $query->where('content', 'like', 'foo%'); })->get(); // Retrieve posts with at least ten comments containing words like foo%... $posts = App\\Post::whereHas('comments', function (Builder $query) { $query->where('content', 'like', 'foo%'); }, '>=', 10)->get(); Querying Relationship Absence When accessing the records for a model, you may wish to limit your results based on the absence of a relationship. For example, imagine you want to retrieve all blog posts that don't have any comments. To do so, you may pass the name of the relationship to the doesntHave and orDoesntHave methods: $posts = App\\Post::doesntHave('comments')->get(); If you need even more power, you may use the whereDoesntHave and orWhereDoesntHave methods to put \"where\" conditions on your doesntHave queries. These methods allows you to add customized constraints to a relationship constraint, such as checking the content of a comment: use Illuminate\\Database\\Eloquent\\Builder; $posts = App\\Post::whereDoesntHave('comments', function (Builder $query) { $query->where('content', 'like', 'foo%'); })->get(); You may use \"dot\" notation to execute a query against a nested relationship. For example, the following query will retrieve all posts with comments from authors that are not banned: use Illuminate\\Database\\Eloquent\\Builder; $posts = App\\Post::whereDoesntHave('comments.author', function (Builder $query) { $query->where('banned', 1); })->get(); Querying Polymorphic Relationships To query the existence of MorphTo relationships, you may use the whereHasMorph method and its corresponding methods: use Illuminate\\Database\\Eloquent\\Builder; // Retrieve comments associated to posts or videos with a title like foo%... $comments = App\\Comment::whereHasMorph( 'commentable', ['App\\Post', 'App\\Video'], function (Builder $query) { $query->where('title', 'like', 'foo%'); } )->get(); // Retrieve comments associated to posts with a title not like foo%... $comments = App\\Comment::whereDoesntHaveMorph( 'commentable', 'App\\Post', function (Builder $query) { $query->where('title', 'like', 'foo%'); } )->get(); You may use the $type parameter to add different constraints depending on the related model: use Illuminate\\Database\\Eloquent\\Builder; $comments = App\\Comment::whereHasMorph( 'commentable', ['App\\Post', 'App\\Video'], function (Builder $query, $type) { $query->where('title', 'like', 'foo%'); if ($type === 'App\\Post') { $query->orWhere('content', 'like', 'foo%'); } } )->get(); Instead of passing an array of possible polymorphic models, you may provide * as a wildcard and let Laravel retrieve all the possible polymorphic types from the database. Laravel will execute an additional query in order to perform this operation: use Illuminate\\Database\\Eloquent\\Builder; $comments = App\\Comment::whereHasMorph('commentable', '*', function (Builder $query) { $query->where('title', 'like', 'foo%'); })->get(); Counting Related Models If you want to count the number of results from a relationship without actually loading them you may use the withCount method, which will place a {relation}_count column on your resulting models. For example: $posts = App\\Post::withCount('comments')->get(); foreach ($posts as $post) { echo $post->comments_count; } You may add the \"counts\" for multiple relations as well as add constraints to the queries: use Illuminate\\Database\\Eloquent\\Builder; $posts = App\\Post::withCount(['votes', 'comments' => function (Builder $query) { $query->where('content', 'like', 'foo%'); }])->get(); echo $posts[0]->votes_count; echo $posts[0]->comments_count; You may also alias the relationship count result, allowing multiple counts on the same relationship: use Illuminate\\Database\\Eloquent\\Builder; $posts = App\\Post::withCount([ 'comments', 'comments as pending_comments_count' => function (Builder $query) { $query->where('approved', false); } ])->get(); echo $posts[0]->comments_count; echo $posts[0]->pending_comments_count; If you're combining withCount with a select statement, ensure that you call withCount after the select method: $posts = App\\Post::select(['title', 'body'])->withCount('comments')->get(); echo $posts[0]->title; echo $posts[0]->body; echo $posts[0]->comments_count; Eager Loading When accessing Eloquent relationships as properties, the relationship data is \"lazy loaded\". This means the relationship data is not actually loaded until you first access the property. However, Eloquent can \"eager load\" relationships at the time you query the parent model. Eager loading alleviates the N + 1 query problem. To illustrate the N + 1 query problem, consider a Book model that is related to Author: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Book extends Model { /* * Get the author that wrote the book. / public function author() { return $this->belongsTo('App\\Author'); } } Now, let's retrieve all books and their authors: $books = App\\Book::all(); foreach ($books as $book) { echo $book->author->name; } This loop will execute 1 query to retrieve all of the books on the table, then another query for each book to retrieve the author. So, if we have 25 books, this loop would run 26 queries: 1 for the original book, and 25 additional queries to retrieve the author of each book. Thankfully, we can use eager loading to reduce this operation to just 2 queries. When querying, you may specify which relationships should be eager loaded using the with method: $books = App\\Book::with('author')->get(); foreach ($books as $book) { echo $book->author->name; } For this operation, only two queries will be executed: select * from books select * from authors where id in (1, 2, 3, 4, 5, ...) Eager Loading Multiple Relationships Sometimes you may need to eager load several different relationships in a single operation. To do so, just pass additional arguments to the with method: $books = App\\Book::with(['author', 'publisher'])->get(); Nested Eager Loading To eager load nested relationships, you may use \"dot\" syntax. For example, let's eager load all of the book's authors and all of the author's personal contacts in one Eloquent statement: $books = App\\Book::with('author.contacts')->get(); Nested Eager Loading morphTo Relationships If you would like to eager load a morphTo relationship, as well as nested relationships on the various entities that may be returned by that relationship, you may use the with method in combination with the morphTo relationship's morphWith method. To help illustrate this method, let's consider the following model: use Illuminate\\Database\\Eloquent\\Model; class ActivityFeed extends Model { /* * Get the parent of the activity feed record. / public function parentable() { return $this->morphTo(); } } In this example, let's assume Event, Photo, and Post models may create ActivityFeed models. Additionally, let's assume that Event models belong to a Calendar model, Photo models are associated with Tag models, and Post models belong to an Author model. Using these model definitions and relationships, we may retrieve ActivityFeed model instances and eager load all parentable models and their respective nested relationships: use Illuminate\\Database\\Eloquent\\Relations\\MorphTo; $activities = ActivityFeed::query() ->with(['parentable' => function (MorphTo $morphTo) { $morphTo->morphWith([ Event::class => ['calendar'], Photo::class => ['tags'], Post::class => ['author'], ]); }])->get(); Eager Loading Specific Columns You may not always need every column from the relationships you are retrieving. For this reason, Eloquent allows you to specify which columns of the relationship you would like to retrieve: $books = App\\Book::with('author:id,name')->get(); When using this feature, you should always include the id column and any relevant foreign key columns in the list of columns you wish to retrieve. Eager Loading By Default Sometimes you might want to always load some relationships when retrieving a model. To accomplish this, you may define a $with property on the model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Book extends Model { /* * The relationships that should always be loaded. * * @var array / protected $with = ['author']; /** * Get the author that wrote the book. */ public function author() { return $this->belongsTo('App\\Author'); } } If you would like to remove an item from the $with property for a single query, you may use the without method: $books = App\\Book::without('author')->get(); Constraining Eager Loads Sometimes you may wish to eager load a relationship, but also specify additional query conditions for the eager loading query. Here's an example: use Illuminate\\Database\\Eloquent\\Builder; $users = App\\User::with(['posts' => function (Builder $query) { $query->where('title', 'like', '%first%'); }])->get(); In this example, Eloquent will only eager load posts where the post's title column contains the word first. You may call other query builder methods to further customize the eager loading operation: use Illuminate\\Database\\Eloquent\\Builder; $users = App\\User::with(['posts' => function (Builder $query) { $query->orderBy('created_at', 'desc'); }])->get(); The limit and take query builder methods may not be used when constraining eager loads. Lazy Eager Loading Sometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this may be useful if you need to dynamically decide whether to load related models: $books = App\\Book::all(); if ($someCondition) { $books->load('author', 'publisher'); } If you need to set additional query constraints on the eager loading query, you may pass an array keyed by the relationships you wish to load. The array values should be Closure instances which receive the query instance: use Illuminate\\Database\\Eloquent\\Builder; $books->load(['author' => function (Builder $query) { $query->orderBy('published_date', 'asc'); }]); To load a relationship only when it has not already been loaded, use the loadMissing method: public function format(Book $book) { $book->loadMissing('author'); return [ 'name' => $book->name, 'author' => $book->author->name ]; } Nested Lazy Eager Loading & morphTo If you would like to eager load a morphTo relationship, as well as nested relationships on the various entities that may be returned by that relationship, you may use the loadMorph method. This method accepts the name of the morphTo relationship as its first argument, and an array of model / relationship pairs as its second argument. To help illustrate this method, let's consider the following model: use Illuminate\\Database\\Eloquent\\Model; class ActivityFeed extends Model { /* * Get the parent of the activity feed record. / public function parentable() { return $this->morphTo(); } } In this example, let's assume Event, Photo, and Post models may create ActivityFeed models. Additionally, let's assume that Event models belong to a Calendar model, Photo models are associated with Tag models, and Post models belong to an Author model. Using these model definitions and relationships, we may retrieve ActivityFeed model instances and eager load all parentable models and their respective nested relationships: $activities = ActivityFeed::with('parentable') ->get() ->loadMorph('parentable', [ Event::class => ['calendar'], Photo::class => ['tags'], Post::class => ['author'], ]); Inserting & Updating Related Models The Save Method Eloquent provides convenient methods for adding new models to relationships. For example, perhaps you need to insert a new Comment for a Post model. Instead of manually setting the post_id attribute on the Comment, you may insert the Comment directly from the relationship's save method: $comment = new App\\Comment(['message' => 'A new comment.']); $post = App\\Post::find(1); $post->comments()->save($comment); Notice that we did not access the comments relationship as a dynamic property. Instead, we called the comments method to obtain an instance of the relationship. The save method will automatically add the appropriate post_id value to the new Comment model. If you need to save multiple related models, you may use the saveMany method: $post = App\\Post::find(1); $post->comments()->saveMany([ new App\\Comment(['message' => 'A new comment.']), new App\\Comment(['message' => 'Another comment.']), ]); Recursively Saving Models & Relationships If you would like to save your model and all of its associated relationships, you may use the push method: $post = App\\Post::find(1); $post->comments[0]->message = 'Message'; $post->comments[0]->author->name = 'Author Name'; $post->push(); The Create Method In addition to the save and saveMany methods, you may also use the create method, which accepts an array of attributes, creates a model, and inserts it into the database. Again, the difference between save and create is that save accepts a full Eloquent model instance while create accepts a plain PHP array: $post = App\\Post::find(1); $comment = $post->comments()->create([ 'message' => 'A new comment.', ]); Before using the create method, be sure to review the documentation on attribute mass assignment. You may use the createMany method to create multiple related models: $post = App\\Post::find(1); $post->comments()->createMany([ [ 'message' => 'A new comment.', ], [ 'message' => 'Another new comment.', ], ]); You may also use the findOrNew, firstOrNew, firstOrCreate and updateOrCreate methods to create and update models on relationships. Belongs To Relationships When updating a belongsTo relationship, you may use the associate method. This method will set the foreign key on the child model: $account = App\\Account::find(10); $user->account()->associate($account); $user->save(); When removing a belongsTo relationship, you may use the dissociate method. This method will set the relationship's foreign key to null: $user->account()->dissociate(); $user->save(); Default Models The belongsTo, hasOne, hasOneThrough, and morphOne relationships allow you to define a default model that will be returned if the given relationship is null. This pattern is often referred to as the Null Object pattern and can help remove conditional checks in your code. In the following example, the user relation will return an empty App\\User model if no user is attached to the post: /* * Get the author of the post. / public function user() { return $this->belongsTo('App\\User')->withDefault(); } To populate the default model with attributes, you may pass an array or Closure to the withDefault method: /* * Get the author of the post. / public function user() { return $this->belongsTo('App\\User')->withDefault([ 'name' => 'Guest Author', ]); } /* * Get the author of the post. / public function user() { return $this->belongsTo('App\\User')->withDefault(function ($user) { $user->name = 'Guest Author'; }); } Many To Many Relationships Attaching / Detaching Eloquent also provides a few additional helper methods to make working with related models more convenient. For example, let's imagine a user can have many roles and a role can have many users. To attach a role to a user by inserting a record in the intermediate table that joins the models, use the attach method: $user = App\\User::find(1); $user->roles()->attach($roleId); When attaching a relationship to a model, you may also pass an array of additional data to be inserted into the intermediate table: $user->roles()->attach($roleId, ['expires' => $expires]); Sometimes it may be necessary to remove a role from a user. To remove a many-to-many relationship record, use the detach method. The detach method will delete the appropriate record out of the intermediate table; however, both models will remain in the database: // Detach a single role from the user... $user->roles()->detach($roleId); // Detach all roles from the user... $user->roles()->detach(); For convenience, attach and detach also accept arrays of IDs as input: $user = App\\User::find(1); $user->roles()->detach([1, 2, 3]); $user->roles()->attach([ 1 => ['expires' => $expires], 2 => ['expires' => $expires] ]); Syncing Associations You may also use the sync method to construct many-to-many associations. The sync method accepts an array of IDs to place on the intermediate table. Any IDs that are not in the given array will be removed from the intermediate table. So, after this operation is complete, only the IDs in the given array will exist in the intermediate table: $user->roles()->sync([1, 2, 3]); You may also pass additional intermediate table values with the IDs: $user->roles()->sync([1 => ['expires' => true], 2, 3]); If you do not want to detach existing IDs, you may use the syncWithoutDetaching method: $user->roles()->syncWithoutDetaching([1, 2, 3]); Toggling Associations The many-to-many relationship also provides a toggle method which \"toggles\" the attachment status of the given IDs. If the given ID is currently attached, it will be detached. Likewise, if it is currently detached, it will be attached: $user->roles()->toggle([1, 2, 3]); Saving Additional Data On A Pivot Table When working with a many-to-many relationship, the save method accepts an array of additional intermediate table attributes as its second argument: App\\User::find(1)->roles()->save($role, ['expires' => $expires]); Updating A Record On A Pivot Table If you need to update an existing row in your pivot table, you may use updateExistingPivot method. This method accepts the pivot record foreign key and an array of attributes to update: $user = App\\User::find(1); $user->roles()->updateExistingPivot($roleId, $attributes); Touching Parent Timestamps When a model belongsTo or belongsToMany another model, such as a Comment which belongs to a Post, it is sometimes helpful to update the parent's timestamp when the child model is updated. For example, when a Comment model is updated, you may want to automatically \"touch\" the updated_at timestamp of the owning Post. Eloquent makes it easy. Just add a touches property containing the names of the relationships to the child model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Comment extends Model { /* * All of the relationships to be touched. * * @var array / protected $touches = ['post']; /** * Get the post that the comment belongs to. */ public function post() { return $this->belongsTo('App\\Post'); } } Now, when you update a Comment, the owning Post will have its updated_at column updated as well, making it more convenient to know when to invalidate a cache of the Post model: $comment = App\\Comment::find(1); $comment->text = 'Edit to this comment!'; $comment->save();","title":"Relationship"},{"location":"developerdoc/laravel_eloquent/#eloquent-collection","text":"Introduction All multi-result sets returned by Eloquent are instances of the Illuminate\\Database\\Eloquent\\Collection object, including results retrieved via the get method or accessed via a relationship. The Eloquent collection object extends the Laravel base collection, so it naturally inherits dozens of methods used to fluently work with the underlying array of Eloquent models. All collections also serve as iterators, allowing you to loop over them as if they were simple PHP arrays: $users = App\\User::where('active', 1)->get(); foreach ($users as $user) { echo $user->name; } However, collections are much more powerful than arrays and expose a variety of map / reduce operations that may be chained using an intuitive interface. For example, let's remove all inactive models and gather the first name for each remaining user: $users = App\\User::all(); $names = $users->reject(function ($user) { return $user->active === false; }) ->map(function ($user) { return $user->name; }); While most Eloquent collection methods return a new instance of an Eloquent collection, the pluck, keys, zip, collapse, flatten and flip methods return a base collection instance. Likewise, if a map operation returns a collection that does not contain any Eloquent models, it will be automatically cast to a base collection. Available Methods All Eloquent collections extend the base Laravel collection object; therefore, they inherit all of the powerful methods provided by the base collection class. In addition, the Illuminate\\Database\\Eloquent\\Collection class provides a superset of methods to aid with managing your model collections. Most methods return Illuminate\\Database\\Eloquent\\Collection instances; however, some methods return a base Illuminate\\Support\\Collection instance. contains($key, $operator = null, $value = null) The contains method may be used to determine if a given model instance is contained by the collection. This method accepts a primary key or a model instance: $users->contains(1); $users->contains(User::find(1)); diff($items) The diff method returns all of the models that are not present in the given collection: use App\\User; $users = $users->diff(User::whereIn('id', [1, 2, 3])->get()); except($keys) The except method returns all of the models that do not have the given primary keys: $users = $users->except([1, 2, 3]); find($key) The find method finds a model that has a given primary key. If $key is a model instance, find will attempt to return a model matching the primary key. If $key is an array of keys, find will return all models which match the $keys using whereIn(): $users = User::all(); $user = $users->find(1); fresh($with = []) The fresh method retrieves a fresh instance of each model in the collection from the database. In addition, any specified relationships will be eager loaded: $users = $users->fresh(); $users = $users->fresh('comments'); intersect($items) The intersect method returns all of the models that are also present in the given collection: use App\\User; $users = $users->intersect(User::whereIn('id', [1, 2, 3])->get()); load($relations) The load method eager loads the given relationships for all models in the collection: $users->load('comments', 'posts'); $users->load('comments.author'); loadMissing($relations) The loadMissing method eager loads the given relationships for all models in the collection if the relationships are not already loaded: $users->loadMissing('comments', 'posts'); $users->loadMissing('comments.author'); modelKeys() The modelKeys method returns the primary keys for all models in the collection: $users->modelKeys(); // [1, 2, 3, 4, 5] makeVisible($attributes) The makeVisible method makes visible attributes that are typically \"hidden\" on each model in the collection: $users = $users->makeVisible(['address', 'phone_number']); makeHidden($attributes) The makeHidden method hides attributes that are typically \"visible\" on each model in the collection: $users = $users->makeHidden(['address', 'phone_number']); only($keys) The only method returns all of the models that have the given primary keys: $users = $users->only([1, 2, 3]); unique($key = null, $strict = false) The unique method returns all of the unique models in the collection. Any models of the same type with the same primary key as another model in the collection are removed. $users = $users->unique(); Custom Collections If you need to use a custom Collection object with your own extension methods, you may override the newCollection method on your model: namespace App; use App\\CustomCollection; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Create a new Eloquent Collection instance. * * @param array $models * @return \\Illuminate\\Database\\Eloquent\\Collection / public function newCollection(array $models = []) { return new CustomCollection($models); } } Once you have defined a newCollection method, you will receive an instance of your custom collection anytime Eloquent returns a Collection instance of that model. If you would like to use a custom collection for every model in your application, you should override the newCollection method on a base model class that is extended by all of your models","title":"Eloquent Collection"},{"location":"developerdoc/laravel_eloquent/#eloquent-mutator","text":"Introduction Accessors and mutators allow you to format Eloquent attribute values when you retrieve or set them on model instances. For example, you may want to use the Laravel encrypter to encrypt a value while it is stored in the database, and then automatically decrypt the attribute when you access it on an Eloquent model. In addition to custom accessors and mutators, Eloquent can also automatically cast date fields to Carbon instances or even cast text fields to JSON. Accessors & Mutators Defining An Accessor To define an accessor, create a getFooAttribute method on your model where Foo is the \"studly\" cased name of the column you wish to access. In this example, we'll define an accessor for the first_name attribute. The accessor will automatically be called by Eloquent when attempting to retrieve the value of the first_name attribute: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Get the user's first name. * * @param string $value * @return string / public function getFirstNameAttribute($value) { return ucfirst($value); } } As you can see, the original value of the column is passed to the accessor, allowing you to manipulate and return the value. To access the value of the accessor, you may access the first_name attribute on a model instance: $user = App\\User::find(1); $firstName = $user->first_name; You may also use accessors to return new, computed values from existing attributes: /* * Get the user's full name. * * @return string / public function getFullNameAttribute() { return \"{$this->first_name} {$this->last_name}\"; } If you would like these computed values to be added to the array / JSON representations of your model, you will need to append them. Defining A Mutator To define a mutator, define a setFooAttribute method on your model where Foo is the \"studly\" cased name of the column you wish to access. So, again, let's define a mutator for the first_name attribute. This mutator will be automatically called when we attempt to set the value of the first_name attribute on the model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * Set the user's first name. * * @param string $value * @return void / public function setFirstNameAttribute($value) { $this->attributes['first_name'] = strtolower($value); } } The mutator will receive the value that is being set on the attribute, allowing you to manipulate the value and set the manipulated value on the Eloquent model's internal $attributes property. So, for example, if we attempt to set the first_name attribute to Sally: $user = App\\User::find(1); $user->first_name = 'Sally'; In this example, the setFirstNameAttribute function will be called with the value Sally. The mutator will then apply the strtolower function to the name and set its resulting value in the internal $attributes array. Date Mutators By default, Eloquent will convert the created_at and updated_at columns to instances of Carbon, which extends the PHP DateTime class and provides an assortment of helpful methods. You may add additional date attributes by setting the $dates property of your model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The attributes that should be mutated to dates. * * @var array / protected $dates = [ 'seen_at', ]; } You may disable the default created_at and updated_at timestamps by setting the public $timestamps property of your model to false. When a column is considered a date, you may set its value to a UNIX timestamp, date string (Y-m-d), date-time string, or a DateTime / Carbon instance. The date's value will be correctly converted and stored in your database: $user = App\\User::find(1); $user->deleted_at = now(); $user->save(); As noted above, when retrieving attributes that are listed in your $dates property, they will automatically be cast to Carbon instances, allowing you to use any of Carbon's methods on your attributes: $user = App\\User::find(1); return $user->deleted_at->getTimestamp(); Date Formats By default, timestamps are formatted as 'Y-m-d H:i:s'. If you need to customize the timestamp format, set the $dateFormat property on your model. This property determines how date attributes are stored in the database, as well as their format when the model is serialized to an array or JSON: namespace App; use Illuminate\\Database\\Eloquent\\Model; class Flight extends Model { /* * The storage format of the model's date columns. * * @var string / protected $dateFormat = 'U'; } Attribute Casting The $casts property on your model provides a convenient method of converting attributes to common data types. The $casts property should be an array where the key is the name of the attribute being cast and the value is the type you wish to cast the column to. The supported cast types are: integer, real, float, double, decimal: , string, boolean, object, array, collection, date, datetime, and timestamp. When casting to decimal, you must define the number of digits (decimal:2). To demonstrate attribute casting, let's cast the is_admin attribute, which is stored in our database as an integer (0 or 1) to a boolean value: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The attributes that should be cast to native types. * * @var array / protected $casts = [ 'is_admin' => 'boolean', ]; } Now the is_admin attribute will always be cast to a boolean when you access it, even if the underlying value is stored in the database as an integer: $user = App\\User::find(1); if ($user->is_admin) { // } Array & JSON Casting The array cast type is particularly useful when working with columns that are stored as serialized JSON. For example, if your database has a JSON or TEXT field type that contains serialized JSON, adding the array cast to that attribute will automatically deserialize the attribute to a PHP array when you access it on your Eloquent model: namespace App; use Illuminate\\Database\\Eloquent\\Model; class User extends Model { /* * The attributes that should be cast to native types. * * @var array / protected $casts = [ 'options' => 'array', ]; } Once the cast is defined, you may access the options attribute and it will automatically be deserialized from JSON into a PHP array. When you set the value of the options attribute, the given array will automatically be serialized back into JSON for storage: $user = App\\User::find(1); $options = $user->options; $options['key'] = 'value'; $user->options = $options; $user->save(); Date Casting When using the date or datetime cast type, you may specify the date's format. This format will be used when the model is serialized to an array or JSON: /* * The attributes that should be cast to native types. * * @var array / protected $casts = [ 'created_at' => 'datetime:Y-m-d', ];","title":"Eloquent Mutator"},{"location":"developerdoc/laravel_queue/","text":"Queue Introduction Laravel now offers Horizon, a beautiful dashboard and configuration system for your Redis powered queues. Check out the full Horizon documentation for more information. Laravel queues provide a unified API across a variety of different queue backends, such as Beanstalk, Amazon SQS, Redis, or even a relational database. Queues allow you to defer the processing of a time consuming task, such as sending an email, until a later time. Deferring these time consuming tasks drastically speeds up web requests to your application. The queue configuration file is stored in config/queue.php. In this file you will find connection configurations for each of the queue drivers that are included with the framework, which includes a database, Beanstalkd, Amazon SQS, Redis, and a synchronous driver that will execute jobs immediately (for local use). A null queue driver is also included which discards queued jobs. Connections Vs. Queues Before getting started with Laravel queues, it is important to understand the distinction between \"connections\" and \"queues\". In your config/queue.php configuration file, there is a connections configuration option. This option defines a particular connection to a backend service such as Amazon SQS, Beanstalk, or Redis. However, any given queue connection may have multiple \"queues\" which may be thought of as different stacks or piles of queued jobs. Note that each connection configuration example in the queue configuration file contains a queue attribute. This is the default queue that jobs will be dispatched to when they are sent to a given connection. In other words, if you dispatch a job without explicitly defining which queue it should be dispatched to, the job will be placed on the queue that is defined in the queue attribute of the connection configuration: // This job is sent to the default queue... Job::dispatch(); // This job is sent to the \"emails\" queue... Job::dispatch()->onQueue('emails'); Some applications may not need to ever push jobs onto multiple queues, instead preferring to have one simple queue. However, pushing jobs to multiple queues can be especially useful for applications that wish to prioritize or segment how jobs are processed, since the Laravel queue worker allows you to specify which queues it should process by priority. For example, if you push jobs to a high queue, you may run a worker that gives them higher processing priority: php artisan queue:work --queue=high,default Driver Notes & Prerequisites Database In order to use the database queue driver, you will need a database table to hold the jobs. To generate a migration that creates this table, run the queue:table Artisan command. Once the migration has been created, you may migrate your database using the migrate command: php artisan queue:table php artisan migrate Redis In order to use the redis queue driver, you should configure a Redis database connection in your config/database.php configuration file. Redis Cluster If your Redis queue connection uses a Redis Cluster, your queue names must contain a key hash tag. This is required in order to ensure all of the Redis keys for a given queue are placed into the same hash slot: 'redis' => [ 'driver' => 'redis', 'connection' => 'default', 'queue' => '{default}', 'retry_after' => 90, ], Blocking When using the Redis queue, you may use the block_for configuration option to specify how long the driver should wait for a job to become available before iterating through the worker loop and re-polling the Redis database. Adjusting this value based on your queue load can be more efficient than continually polling the Redis database for new jobs. For instance, you may set the value to 5 to indicate that the driver should block for five seconds while waiting for a job to become available: 'redis' => [ 'driver' => 'redis', 'connection' => 'default', 'queue' => 'default', 'retry_after' => 90, 'block_for' => 5, ], Other Driver Prerequisites The following dependencies are needed for the listed queue drivers: Amazon SQS: aws/aws-sdk-php ~3.0 Beanstalkd: pda/pheanstalk ~4.0 Redis: predis/predis ~1.0 Creating Jobs Generating Job Classes By default, all of the queueable jobs for your application are stored in the app/Jobs directory. If the app/Jobs directory doesn't exist, it will be created when you run the make:job Artisan command. You may generate a new queued job using the Artisan CLI: php artisan make:job ProcessPodcast The generated class will implement the Illuminate\\Contracts\\Queue\\ShouldQueue interface, indicating to Laravel that the job should be pushed onto the queue to run asynchronously. Class Structure Job classes are very simple, normally containing only a handle method which is called when the job is processed by the queue. To get started, let's take a look at an example job class. In this example, we'll pretend we manage a podcast publishing service and need to process the uploaded podcast files before they are published: namespace App\\Jobs; use App\\Podcast; use App\\AudioProcessor; use Illuminate\\Bus\\Queueable; use Illuminate\\Queue\\SerializesModels; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Contracts\\Queue\\ShouldQueue; use Illuminate\\Foundation\\Bus\\Dispatchable; class ProcessPodcast implements ShouldQueue { use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $podcast; /** * Create a new job instance. * * @param Podcast $podcast * @return void */ public function __construct(Podcast $podcast) { $this->podcast = $podcast; } /** * Execute the job. * * @param AudioProcessor $processor * @return void */ public function handle(AudioProcessor $processor) { // Process uploaded podcast... } } In this example, note that we were able to pass an Eloquent model directly into the queued job's constructor. Because of the SerializesModels trait that the job is using, Eloquent models will be gracefully serialized and unserialized when the job is processing. If your queued job accepts an Eloquent model in its constructor, only the identifier for the model will be serialized onto the queue. When the job is actually handled, the queue system will automatically re-retrieve the full model instance from the database. It's all totally transparent to your application and prevents issues that can arise from serializing full Eloquent model instances. The handle method is called when the job is processed by the queue. Note that we are able to type-hint dependencies on the handle method of the job. The Laravel service container automatically injects these dependencies. If you would like to take total control over how the container injects dependencies into the handle method, you may use the container's bindMethod method. The bindMethod method accepts a callback which receives the job and the container. Within the callback, you are free to invoke the handle method however you wish. Typically, you should call this method from a service provider: use App\\Jobs\\ProcessPodcast; $this->app->bindMethod(ProcessPodcast::class.'@handle', function ($job, $app) { return $job->handle($app->make(AudioProcessor::class)); }); Binary data, such as raw image contents, should be passed through the base64_encode function before being passed to a queued job. Otherwise, the job may not properly serialize to JSON when being placed on the queue. Dispatching Jobs Once you have written your job class, you may dispatch it using the dispatch method on the job itself. The arguments passed to the dispatch method will be given to the job's constructor: namespace App\\Http\\Controllers; use App\\Jobs\\ProcessPodcast; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatch($podcast); } } Delayed Dispatching If you would like to delay the execution of a queued job, you may use the delay method when dispatching a job. For example, let's specify that a job should not be available for processing until 10 minutes after it has been dispatched: namespace App\\Http\\Controllers; use App\\Jobs\\ProcessPodcast; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatch($podcast) ->delay(now()->addMinutes(10)); } } The Amazon SQS queue service has a maximum delay time of 15 minutes. Synchronous Dispatching If you would like to dispatch a job immediately (synchronously), you may use the dispatchNow method. When using this method, the job will not be queued and will be run immediately within the current process: namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Jobs\\ProcessPodcast; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatchNow($podcast); } } Job Chaining Job chaining allows you to specify a list of queued jobs that should be run in sequence. If one job in the sequence fails, the rest of the jobs will not be run. To execute a queued job chain, you may use the withChain method on any of your dispatchable jobs: ProcessPodcast::withChain([ new OptimizePodcast, new ReleasePodcast ])->dispatch(); Deleting jobs using the $this->delete() method will not prevent chained jobs from being processed. The chain will only stop executing if a job in the chain fails. Chain Connection & Queue If you would like to specify the default connection and queue that should be used for the chained jobs, you may use the allOnConnection and allOnQueue methods. These methods specify the queue connection and queue name that should be used unless the queued job is explicitly assigned a different connection / queue: ProcessPodcast::withChain([ new OptimizePodcast, new ReleasePodcast ])->dispatch()->allOnConnection('redis')->allOnQueue('podcasts'); Customizing The Queue & Connection Dispatching To A Particular Queue By pushing jobs to different queues, you may \"categorize\" your queued jobs and even prioritize how many workers you assign to various queues. Keep in mind, this does not push jobs to different queue \"connections\" as defined by your queue configuration file, but only to specific queues within a single connection. To specify the queue, use the onQueue method when dispatching the job: namespace App\\Http\\Controllers; use App\\Jobs\\ProcessPodcast; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatch($podcast)->onQueue('processing'); } } Dispatching To A Particular Connection If you are working with multiple queue connections, you may specify which connection to push a job to. To specify the connection, use the onConnection method when dispatching the job: namespace App\\Http\\Controllers; use App\\Jobs\\ProcessPodcast; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatch($podcast)->onConnection('sqs'); } } You may chain the onConnection and onQueue methods to specify the connection and the queue for a job: ProcessPodcast::dispatch($podcast) ->onConnection('sqs') ->onQueue('processing'); Alternatively, you may specify the connection as a property on the job class: namespace App\\Jobs; class ProcessPodcast implements ShouldQueue { /* * The queue connection that should handle the job. * * @var string / public $connection = 'sqs'; } Specifying Max Job Attempts / Timeout Values Max Attempts One approach to specifying the maximum number of times a job may be attempted is via the --tries switch on the Artisan command line: php artisan queue:work --tries=3 However, you may take a more granular approach by defining the maximum number of attempts on the job class itself. If the maximum number of attempts is specified on the job, it will take precedence over the value provided on the command line: namespace App\\Jobs; class ProcessPodcast implements ShouldQueue { /* * The number of times the job may be attempted. * * @var int / public $tries = 5; } Time Based Attempts As an alternative to defining how many times a job may be attempted before it fails, you may define a time at which the job should timeout. This allows a job to be attempted any number of times within a given time frame. To define the time at which a job should timeout, add a retryUntil method to your job class: /* * Determine the time at which the job should timeout. * * @return \\DateTime / public function retryUntil() { return now()->addSeconds(5); } You may also define a retryUntil method on your queued event listeners. Timeout The timeout feature is optimized for PHP 7.1+ and the pcntl PHP extension. Likewise, the maximum number of seconds that jobs can run may be specified using the --timeout switch on the Artisan command line: php artisan queue:work --timeout=30 However, you may also define the maximum number of seconds a job should be allowed to run on the job class itself. If the timeout is specified on the job, it will take precedence over any timeout specified on the command line: namespace App\\Jobs; class ProcessPodcast implements ShouldQueue { /* * The number of seconds the job can run before timing out. * * @var int / public $timeout = 120; } Rate Limiting This feature requires that your application can interact with a Redis server. If your application interacts with Redis, you may throttle your queued jobs by time or concurrency. This feature can be of assistance when your queued jobs are interacting with APIs that are also rate limited. For example, using the throttle method, you may throttle a given type of job to only run 10 times every 60 seconds. If a lock can not be obtained, you should typically release the job back onto the queue so it can be retried later: Redis::throttle('key')->allow(10)->every(60)->then(function () { // Job logic... }, function () { // Could not obtain lock... return $this->release(10); }); In the example above, the key may be any string that uniquely identifies the type of job you would like to rate limit. For example, you may wish to construct the key based on the class name of the job and the IDs of the Eloquent models it operates on. Releasing a throttled job back onto the queue will still increment the job's total number of attempts. Alternatively, you may specify the maximum number of workers that may simultaneously process a given job. This can be helpful when a queued job is modifying a resource that should only be modified by one job at a time. For example, using the funnel method, you may limit jobs of a given type to only be processed by one worker at a time: Redis::funnel('key')->limit(1)->then(function () { // Job logic... }, function () { // Could not obtain lock... return $this->release(10); }); When using rate limiting, the number of attempts your job will need to run successfully can be hard to determine. Therefore, it is useful to combine rate limiting with time based attempts. Error Handling If an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it may be attempted again. The job will continue to be released until it has been attempted the maximum number of times allowed by your application. The maximum number of attempts is defined by the --tries switch used on the queue:work Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself. More information on running the queue worker can be found below. Queueing Closures Instead of dispatching a job class to the queue, you may also dispatch a Closure. This is great for quick, simple tasks that need to be executed outside of the current request cycle: $podcast = App\\Podcast::find(1); dispatch(function () use ($podcast) { $podcast->publish(); }); When dispatching Closures to the queue, the Closure's code contents is cryptographically signed so it can not be modified in transit. Running The Queue Worker Laravel includes a queue worker that will process new jobs as they are pushed onto the queue. You may run the worker using the queue:work Artisan command. Note that once the queue:work command has started, it will continue to run until it is manually stopped or you close your terminal: php artisan queue:work To keep the queue:work process running permanently in the background, you should use a process monitor such as Supervisor to ensure that the queue worker does not stop running. Remember, queue workers are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to restart your queue workers. Alternatively, you may run the queue:listen command. When using the queue:listen command, you don't have to manually restart the worker after your code is changed; however, this command is not as efficient as queue:work: php artisan queue:listen Specifying The Connection & Queue You may also specify which queue connection the worker should utilize. The connection name passed to the work command should correspond to one of the connections defined in your config/queue.php configuration file: php artisan queue:work redis You may customize your queue worker even further by only processing particular queues for a given connection. For example, if all of your emails are processed in an emails queue on your redis queue connection, you may issue the following command to start a worker that only processes only that queue: php artisan queue:work redis --queue=emails Processing A Single Job The --once option may be used to instruct the worker to only process a single job from the queue: php artisan queue:work --once Processing All Queued Jobs & Then Exiting The --stop-when-empty option may be used to instruct the worker to process all jobs and then exit gracefully. This option can be useful when working Laravel queues within a Docker container if you wish to shutdown the container after the queue is empty: php artisan queue:work --stop-when-empty Resource Considerations Daemon queue workers do not \"reboot\" the framework before processing each job. Therefore, you should free any heavy resources after each job completes. For example, if you are doing image manipulation with the GD library, you should free the memory with imagedestroy when you are done. Queue Priorities Sometimes you may wish to prioritize how your queues are processed. For example, in your config/queue.php you may set the default queue for your redis connection to low. However, occasionally you may wish to push a job to a high priority queue like so: dispatch((new Job)->onQueue('high')); To start a worker that verifies that all of the high queue jobs are processed before continuing to any jobs on the low queue, pass a comma-delimited list of queue names to the work command: php artisan queue:work --queue=high,low Queue Workers & Deployment Since queue workers are long-lived processes, they will not pick up changes to your code without being restarted. So, the simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You may gracefully restart all of the workers by issuing the queue:restart command: php artisan queue:restart This command will instruct all queue workers to gracefully \"die\" after they finish processing their current job so that no existing jobs are lost. Since the queue workers will die when the queue:restart command is executed, you should be running a process manager such as Supervisor to automatically restart the queue workers. The queue uses the cache to store restart signals, so you should verify a cache driver is properly configured for your application before using this feature. Job Expirations & Timeouts Job Expiration In your config/queue.php configuration file, each queue connection defines a retry_after option. This option specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example, if the value of retry_after is set to 90, the job will be released back onto the queue if it has been processing for 90 seconds without being deleted. Typically, you should set the retry_after value to the maximum number of seconds your jobs should reasonably take to complete processing. The only queue connection which does not contain a retry_after value is Amazon SQS. SQS will retry the job based on the Default Visibility Timeout which is managed within the AWS console. Worker Timeouts The queue:work Artisan command exposes a --timeout option. The --timeout option specifies how long the Laravel queue master process will wait before killing off a child queue worker that is processing a job. Sometimes a child queue process can become \"frozen\" for various reasons, such as an external HTTP call that is not responding. The --timeout option removes frozen processes that have exceeded that specified time limit: php artisan queue:work --timeout=60 The retry_after configuration option and the --timeout CLI option are different, but work together to ensure that jobs are not lost and that jobs are only successfully processed once. The --timeout value should always be at least several seconds shorter than your retry_after configuration value. This will ensure that a worker processing a given job is always killed before the job is retried. If your --timeout option is longer than your retry_after configuration value, your jobs may be processed twice. Worker Sleep Duration When jobs are available on the queue, the worker will keep processing jobs with no delay in between them. However, the sleep option determines how long (in seconds) the worker will \"sleep\" if there are no new jobs available. While sleeping, the worker will not process any new jobs - the jobs will be processed after the worker wakes up again. php artisan queue:work --sleep=3 Supervisor Configuration Installing Supervisor Supervisor is a process monitor for the Linux operating system, and will automatically restart your queue:work process if it fails. To install Supervisor on Ubuntu, you may use the following command: sudo apt-get install supervisor If configuring Supervisor yourself sounds overwhelming, consider using Laravel Forge, which will automatically install and configure Supervisor for your Laravel projects. Configuring Supervisor Supervisor configuration files are typically stored in the /etc/supervisor/conf.d directory. Within this directory, you may create any number of configuration files that instruct supervisor how your processes should be monitored. For example, let's create a laravel-worker.conf file that starts and monitors a queue:work process: [program:laravel-worker] process_name=%(program_name)s_%(process_num)02d command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 autostart=true autorestart=true user=forge numprocs=8 redirect_stderr=true stdout_logfile=/home/forge/app.com/worker.log In this example, the numprocs directive will instruct Supervisor to run 8 queue:work processes and monitor all of them, automatically restarting them if they fail. You should change the queue:work sqs portion of the command directive to reflect your desired queue connection. Starting Supervisor Once the configuration file has been created, you may update the Supervisor configuration and start the processes using the following commands: sudo supervisorctl reread sudo supervisorctl update sudo supervisorctl start laravel-worker:* For more information on Supervisor, consult the Supervisor documentation. Dealing With Failed Jobs Sometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to specify the maximum number of times a job should be attempted. After a job has exceeded this amount of attempts, it will be inserted into the failed_jobs database table. To create a migration for the failed_jobs table, you may use the queue:failed-table command: php artisan queue:failed-table php artisan migrate Then, when running your queue worker, you should specify the maximum number of times a job should be attempted using the --tries switch on the queue:work command. If you do not specify a value for the --tries option, jobs will be attempted indefinitely: php artisan queue:work redis --tries=3 In addition, you may specify how many seconds Laravel should wait before retrying a job that has failed using the --delay option. By default, a job is retried immediately: php artisan queue:work redis --tries=3 --delay=3 If you would like to configure the failed job retry delay on a per-job basis, you may do so by defining a retryAfter property on your queued job class: /* * The number of seconds to wait before retrying the job. * * @var int / public $retryAfter = 3; Cleaning Up After Failed Jobs You may define a failed method directly on your job class, allowing you to perform job specific clean-up when a failure occurs. This is the perfect location to send an alert to your users or revert any actions performed by the job. The Exception that caused the job to fail will be passed to the failed method: namespace App\\Jobs; use Exception; use App\\Podcast; use App\\AudioProcessor; use Illuminate\\Bus\\Queueable; use Illuminate\\Queue\\SerializesModels; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Contracts\\Queue\\ShouldQueue; class ProcessPodcast implements ShouldQueue { use InteractsWithQueue, Queueable, SerializesModels; protected $podcast; /** * Create a new job instance. * * @param Podcast $podcast * @return void */ public function __construct(Podcast $podcast) { $this->podcast = $podcast; } /** * Execute the job. * * @param AudioProcessor $processor * @return void */ public function handle(AudioProcessor $processor) { // Process uploaded podcast... } /** * The job failed to process. * * @param Exception $exception * @return void */ public function failed(Exception $exception) { // Send user notification of failure, etc... } } Failed Job Events If you would like to register an event that will be called when a job fails, you may use the Queue::failing method. This event is a great opportunity to notify your team via email or Slack. For example, we may attach a callback to this event from the AppServiceProvider that is included with Laravel: namespace App\\Providers; use Illuminate\\Support\\Facades\\Queue; use Illuminate\\Queue\\Events\\JobFailed; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /* * Register any application services. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { Queue::failing(function (JobFailed $event) { // $event->connectionName // $event->job // $event->exception }); } } Retrying Failed Jobs To view all of your failed jobs that have been inserted into your failed_jobs database table, you may use the queue:failed Artisan command: php artisan queue:failed The queue:failed command will list the job ID, connection, queue, and failure time. The job ID may be used to retry the failed job. For instance, to retry a failed job that has an ID of 5, issue the following command: php artisan queue:retry 5 To retry all of your failed jobs, execute the queue:retry command and pass all as the ID: php artisan queue:retry all If you would like to delete a failed job, you may use the queue:forget command: php artisan queue:forget 5 To delete all of your failed jobs, you may use the queue:flush command: php artisan queue:flush Ignoring Missing Models When injecting an Eloquent model into a job, it is automatically serialized before being placed on the queue and restored when the job is processed. However, if the model has been deleted while the job was waiting to be processed by a worker, your job may fail with a ModelNotFoundException. For convenience, you may choose to automatically delete jobs with missing models by setting your job's deleteWhenMissingModels property to true: /* * Delete the job if its models no longer exist. * * @var bool / public $deleteWhenMissingModels = true; Job Events Using the before and after methods on the Queue facade, you may specify callbacks to be executed before or after a queued job is processed. These callbacks are a great opportunity to perform additional logging or increment statistics for a dashboard. Typically, you should call these methods from a service provider. For example, we may use the AppServiceProvider that is included with Laravel: namespace App\\Providers; use Illuminate\\Support\\Facades\\Queue; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Queue\\Events\\JobProcessed; use Illuminate\\Queue\\Events\\JobProcessing; class AppServiceProvider extends ServiceProvider { /* * Register any application services. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { Queue::before(function (JobProcessing $event) { // $event->connectionName // $event->job // $event->job->payload() }); Queue::after(function (JobProcessed $event) { // $event->connectionName // $event->job // $event->job->payload() }); } } Using the looping method on the Queue facade, you may specify callbacks that execute before the worker attempts to fetch a job from a queue. For example, you might register a Closure to rollback any transactions that were left open by a previously failed job: Queue::looping(function () { while (DB::transactionLevel() > 0) { DB::rollBack(); } });","title":"Laravel Queue"},{"location":"developerdoc/laravel_queue/#queue","text":"Introduction Laravel now offers Horizon, a beautiful dashboard and configuration system for your Redis powered queues. Check out the full Horizon documentation for more information. Laravel queues provide a unified API across a variety of different queue backends, such as Beanstalk, Amazon SQS, Redis, or even a relational database. Queues allow you to defer the processing of a time consuming task, such as sending an email, until a later time. Deferring these time consuming tasks drastically speeds up web requests to your application. The queue configuration file is stored in config/queue.php. In this file you will find connection configurations for each of the queue drivers that are included with the framework, which includes a database, Beanstalkd, Amazon SQS, Redis, and a synchronous driver that will execute jobs immediately (for local use). A null queue driver is also included which discards queued jobs. Connections Vs. Queues Before getting started with Laravel queues, it is important to understand the distinction between \"connections\" and \"queues\". In your config/queue.php configuration file, there is a connections configuration option. This option defines a particular connection to a backend service such as Amazon SQS, Beanstalk, or Redis. However, any given queue connection may have multiple \"queues\" which may be thought of as different stacks or piles of queued jobs. Note that each connection configuration example in the queue configuration file contains a queue attribute. This is the default queue that jobs will be dispatched to when they are sent to a given connection. In other words, if you dispatch a job without explicitly defining which queue it should be dispatched to, the job will be placed on the queue that is defined in the queue attribute of the connection configuration: // This job is sent to the default queue... Job::dispatch(); // This job is sent to the \"emails\" queue... Job::dispatch()->onQueue('emails'); Some applications may not need to ever push jobs onto multiple queues, instead preferring to have one simple queue. However, pushing jobs to multiple queues can be especially useful for applications that wish to prioritize or segment how jobs are processed, since the Laravel queue worker allows you to specify which queues it should process by priority. For example, if you push jobs to a high queue, you may run a worker that gives them higher processing priority: php artisan queue:work --queue=high,default Driver Notes & Prerequisites Database In order to use the database queue driver, you will need a database table to hold the jobs. To generate a migration that creates this table, run the queue:table Artisan command. Once the migration has been created, you may migrate your database using the migrate command: php artisan queue:table php artisan migrate Redis In order to use the redis queue driver, you should configure a Redis database connection in your config/database.php configuration file. Redis Cluster If your Redis queue connection uses a Redis Cluster, your queue names must contain a key hash tag. This is required in order to ensure all of the Redis keys for a given queue are placed into the same hash slot: 'redis' => [ 'driver' => 'redis', 'connection' => 'default', 'queue' => '{default}', 'retry_after' => 90, ], Blocking When using the Redis queue, you may use the block_for configuration option to specify how long the driver should wait for a job to become available before iterating through the worker loop and re-polling the Redis database. Adjusting this value based on your queue load can be more efficient than continually polling the Redis database for new jobs. For instance, you may set the value to 5 to indicate that the driver should block for five seconds while waiting for a job to become available: 'redis' => [ 'driver' => 'redis', 'connection' => 'default', 'queue' => 'default', 'retry_after' => 90, 'block_for' => 5, ], Other Driver Prerequisites The following dependencies are needed for the listed queue drivers: Amazon SQS: aws/aws-sdk-php ~3.0 Beanstalkd: pda/pheanstalk ~4.0 Redis: predis/predis ~1.0 Creating Jobs Generating Job Classes By default, all of the queueable jobs for your application are stored in the app/Jobs directory. If the app/Jobs directory doesn't exist, it will be created when you run the make:job Artisan command. You may generate a new queued job using the Artisan CLI: php artisan make:job ProcessPodcast The generated class will implement the Illuminate\\Contracts\\Queue\\ShouldQueue interface, indicating to Laravel that the job should be pushed onto the queue to run asynchronously. Class Structure Job classes are very simple, normally containing only a handle method which is called when the job is processed by the queue. To get started, let's take a look at an example job class. In this example, we'll pretend we manage a podcast publishing service and need to process the uploaded podcast files before they are published: namespace App\\Jobs; use App\\Podcast; use App\\AudioProcessor; use Illuminate\\Bus\\Queueable; use Illuminate\\Queue\\SerializesModels; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Contracts\\Queue\\ShouldQueue; use Illuminate\\Foundation\\Bus\\Dispatchable; class ProcessPodcast implements ShouldQueue { use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $podcast; /** * Create a new job instance. * * @param Podcast $podcast * @return void */ public function __construct(Podcast $podcast) { $this->podcast = $podcast; } /** * Execute the job. * * @param AudioProcessor $processor * @return void */ public function handle(AudioProcessor $processor) { // Process uploaded podcast... } } In this example, note that we were able to pass an Eloquent model directly into the queued job's constructor. Because of the SerializesModels trait that the job is using, Eloquent models will be gracefully serialized and unserialized when the job is processing. If your queued job accepts an Eloquent model in its constructor, only the identifier for the model will be serialized onto the queue. When the job is actually handled, the queue system will automatically re-retrieve the full model instance from the database. It's all totally transparent to your application and prevents issues that can arise from serializing full Eloquent model instances. The handle method is called when the job is processed by the queue. Note that we are able to type-hint dependencies on the handle method of the job. The Laravel service container automatically injects these dependencies. If you would like to take total control over how the container injects dependencies into the handle method, you may use the container's bindMethod method. The bindMethod method accepts a callback which receives the job and the container. Within the callback, you are free to invoke the handle method however you wish. Typically, you should call this method from a service provider: use App\\Jobs\\ProcessPodcast; $this->app->bindMethod(ProcessPodcast::class.'@handle', function ($job, $app) { return $job->handle($app->make(AudioProcessor::class)); }); Binary data, such as raw image contents, should be passed through the base64_encode function before being passed to a queued job. Otherwise, the job may not properly serialize to JSON when being placed on the queue. Dispatching Jobs Once you have written your job class, you may dispatch it using the dispatch method on the job itself. The arguments passed to the dispatch method will be given to the job's constructor: namespace App\\Http\\Controllers; use App\\Jobs\\ProcessPodcast; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatch($podcast); } } Delayed Dispatching If you would like to delay the execution of a queued job, you may use the delay method when dispatching a job. For example, let's specify that a job should not be available for processing until 10 minutes after it has been dispatched: namespace App\\Http\\Controllers; use App\\Jobs\\ProcessPodcast; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatch($podcast) ->delay(now()->addMinutes(10)); } } The Amazon SQS queue service has a maximum delay time of 15 minutes. Synchronous Dispatching If you would like to dispatch a job immediately (synchronously), you may use the dispatchNow method. When using this method, the job will not be queued and will be run immediately within the current process: namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Jobs\\ProcessPodcast; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatchNow($podcast); } } Job Chaining Job chaining allows you to specify a list of queued jobs that should be run in sequence. If one job in the sequence fails, the rest of the jobs will not be run. To execute a queued job chain, you may use the withChain method on any of your dispatchable jobs: ProcessPodcast::withChain([ new OptimizePodcast, new ReleasePodcast ])->dispatch(); Deleting jobs using the $this->delete() method will not prevent chained jobs from being processed. The chain will only stop executing if a job in the chain fails. Chain Connection & Queue If you would like to specify the default connection and queue that should be used for the chained jobs, you may use the allOnConnection and allOnQueue methods. These methods specify the queue connection and queue name that should be used unless the queued job is explicitly assigned a different connection / queue: ProcessPodcast::withChain([ new OptimizePodcast, new ReleasePodcast ])->dispatch()->allOnConnection('redis')->allOnQueue('podcasts'); Customizing The Queue & Connection Dispatching To A Particular Queue By pushing jobs to different queues, you may \"categorize\" your queued jobs and even prioritize how many workers you assign to various queues. Keep in mind, this does not push jobs to different queue \"connections\" as defined by your queue configuration file, but only to specific queues within a single connection. To specify the queue, use the onQueue method when dispatching the job: namespace App\\Http\\Controllers; use App\\Jobs\\ProcessPodcast; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatch($podcast)->onQueue('processing'); } } Dispatching To A Particular Connection If you are working with multiple queue connections, you may specify which connection to push a job to. To specify the connection, use the onConnection method when dispatching the job: namespace App\\Http\\Controllers; use App\\Jobs\\ProcessPodcast; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PodcastController extends Controller { /* * Store a new podcast. * * @param Request $request * @return Response / public function store(Request $request) { // Create podcast... ProcessPodcast::dispatch($podcast)->onConnection('sqs'); } } You may chain the onConnection and onQueue methods to specify the connection and the queue for a job: ProcessPodcast::dispatch($podcast) ->onConnection('sqs') ->onQueue('processing'); Alternatively, you may specify the connection as a property on the job class: namespace App\\Jobs; class ProcessPodcast implements ShouldQueue { /* * The queue connection that should handle the job. * * @var string / public $connection = 'sqs'; } Specifying Max Job Attempts / Timeout Values Max Attempts One approach to specifying the maximum number of times a job may be attempted is via the --tries switch on the Artisan command line: php artisan queue:work --tries=3 However, you may take a more granular approach by defining the maximum number of attempts on the job class itself. If the maximum number of attempts is specified on the job, it will take precedence over the value provided on the command line: namespace App\\Jobs; class ProcessPodcast implements ShouldQueue { /* * The number of times the job may be attempted. * * @var int / public $tries = 5; } Time Based Attempts As an alternative to defining how many times a job may be attempted before it fails, you may define a time at which the job should timeout. This allows a job to be attempted any number of times within a given time frame. To define the time at which a job should timeout, add a retryUntil method to your job class: /* * Determine the time at which the job should timeout. * * @return \\DateTime / public function retryUntil() { return now()->addSeconds(5); } You may also define a retryUntil method on your queued event listeners. Timeout The timeout feature is optimized for PHP 7.1+ and the pcntl PHP extension. Likewise, the maximum number of seconds that jobs can run may be specified using the --timeout switch on the Artisan command line: php artisan queue:work --timeout=30 However, you may also define the maximum number of seconds a job should be allowed to run on the job class itself. If the timeout is specified on the job, it will take precedence over any timeout specified on the command line: namespace App\\Jobs; class ProcessPodcast implements ShouldQueue { /* * The number of seconds the job can run before timing out. * * @var int / public $timeout = 120; } Rate Limiting This feature requires that your application can interact with a Redis server. If your application interacts with Redis, you may throttle your queued jobs by time or concurrency. This feature can be of assistance when your queued jobs are interacting with APIs that are also rate limited. For example, using the throttle method, you may throttle a given type of job to only run 10 times every 60 seconds. If a lock can not be obtained, you should typically release the job back onto the queue so it can be retried later: Redis::throttle('key')->allow(10)->every(60)->then(function () { // Job logic... }, function () { // Could not obtain lock... return $this->release(10); }); In the example above, the key may be any string that uniquely identifies the type of job you would like to rate limit. For example, you may wish to construct the key based on the class name of the job and the IDs of the Eloquent models it operates on. Releasing a throttled job back onto the queue will still increment the job's total number of attempts. Alternatively, you may specify the maximum number of workers that may simultaneously process a given job. This can be helpful when a queued job is modifying a resource that should only be modified by one job at a time. For example, using the funnel method, you may limit jobs of a given type to only be processed by one worker at a time: Redis::funnel('key')->limit(1)->then(function () { // Job logic... }, function () { // Could not obtain lock... return $this->release(10); }); When using rate limiting, the number of attempts your job will need to run successfully can be hard to determine. Therefore, it is useful to combine rate limiting with time based attempts. Error Handling If an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it may be attempted again. The job will continue to be released until it has been attempted the maximum number of times allowed by your application. The maximum number of attempts is defined by the --tries switch used on the queue:work Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself. More information on running the queue worker can be found below. Queueing Closures Instead of dispatching a job class to the queue, you may also dispatch a Closure. This is great for quick, simple tasks that need to be executed outside of the current request cycle: $podcast = App\\Podcast::find(1); dispatch(function () use ($podcast) { $podcast->publish(); }); When dispatching Closures to the queue, the Closure's code contents is cryptographically signed so it can not be modified in transit. Running The Queue Worker Laravel includes a queue worker that will process new jobs as they are pushed onto the queue. You may run the worker using the queue:work Artisan command. Note that once the queue:work command has started, it will continue to run until it is manually stopped or you close your terminal: php artisan queue:work To keep the queue:work process running permanently in the background, you should use a process monitor such as Supervisor to ensure that the queue worker does not stop running. Remember, queue workers are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to restart your queue workers. Alternatively, you may run the queue:listen command. When using the queue:listen command, you don't have to manually restart the worker after your code is changed; however, this command is not as efficient as queue:work: php artisan queue:listen Specifying The Connection & Queue You may also specify which queue connection the worker should utilize. The connection name passed to the work command should correspond to one of the connections defined in your config/queue.php configuration file: php artisan queue:work redis You may customize your queue worker even further by only processing particular queues for a given connection. For example, if all of your emails are processed in an emails queue on your redis queue connection, you may issue the following command to start a worker that only processes only that queue: php artisan queue:work redis --queue=emails Processing A Single Job The --once option may be used to instruct the worker to only process a single job from the queue: php artisan queue:work --once Processing All Queued Jobs & Then Exiting The --stop-when-empty option may be used to instruct the worker to process all jobs and then exit gracefully. This option can be useful when working Laravel queues within a Docker container if you wish to shutdown the container after the queue is empty: php artisan queue:work --stop-when-empty Resource Considerations Daemon queue workers do not \"reboot\" the framework before processing each job. Therefore, you should free any heavy resources after each job completes. For example, if you are doing image manipulation with the GD library, you should free the memory with imagedestroy when you are done. Queue Priorities Sometimes you may wish to prioritize how your queues are processed. For example, in your config/queue.php you may set the default queue for your redis connection to low. However, occasionally you may wish to push a job to a high priority queue like so: dispatch((new Job)->onQueue('high')); To start a worker that verifies that all of the high queue jobs are processed before continuing to any jobs on the low queue, pass a comma-delimited list of queue names to the work command: php artisan queue:work --queue=high,low Queue Workers & Deployment Since queue workers are long-lived processes, they will not pick up changes to your code without being restarted. So, the simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You may gracefully restart all of the workers by issuing the queue:restart command: php artisan queue:restart This command will instruct all queue workers to gracefully \"die\" after they finish processing their current job so that no existing jobs are lost. Since the queue workers will die when the queue:restart command is executed, you should be running a process manager such as Supervisor to automatically restart the queue workers. The queue uses the cache to store restart signals, so you should verify a cache driver is properly configured for your application before using this feature. Job Expirations & Timeouts Job Expiration In your config/queue.php configuration file, each queue connection defines a retry_after option. This option specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example, if the value of retry_after is set to 90, the job will be released back onto the queue if it has been processing for 90 seconds without being deleted. Typically, you should set the retry_after value to the maximum number of seconds your jobs should reasonably take to complete processing. The only queue connection which does not contain a retry_after value is Amazon SQS. SQS will retry the job based on the Default Visibility Timeout which is managed within the AWS console. Worker Timeouts The queue:work Artisan command exposes a --timeout option. The --timeout option specifies how long the Laravel queue master process will wait before killing off a child queue worker that is processing a job. Sometimes a child queue process can become \"frozen\" for various reasons, such as an external HTTP call that is not responding. The --timeout option removes frozen processes that have exceeded that specified time limit: php artisan queue:work --timeout=60 The retry_after configuration option and the --timeout CLI option are different, but work together to ensure that jobs are not lost and that jobs are only successfully processed once. The --timeout value should always be at least several seconds shorter than your retry_after configuration value. This will ensure that a worker processing a given job is always killed before the job is retried. If your --timeout option is longer than your retry_after configuration value, your jobs may be processed twice. Worker Sleep Duration When jobs are available on the queue, the worker will keep processing jobs with no delay in between them. However, the sleep option determines how long (in seconds) the worker will \"sleep\" if there are no new jobs available. While sleeping, the worker will not process any new jobs - the jobs will be processed after the worker wakes up again. php artisan queue:work --sleep=3 Supervisor Configuration Installing Supervisor Supervisor is a process monitor for the Linux operating system, and will automatically restart your queue:work process if it fails. To install Supervisor on Ubuntu, you may use the following command: sudo apt-get install supervisor If configuring Supervisor yourself sounds overwhelming, consider using Laravel Forge, which will automatically install and configure Supervisor for your Laravel projects. Configuring Supervisor Supervisor configuration files are typically stored in the /etc/supervisor/conf.d directory. Within this directory, you may create any number of configuration files that instruct supervisor how your processes should be monitored. For example, let's create a laravel-worker.conf file that starts and monitors a queue:work process: [program:laravel-worker] process_name=%(program_name)s_%(process_num)02d command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 autostart=true autorestart=true user=forge numprocs=8 redirect_stderr=true stdout_logfile=/home/forge/app.com/worker.log In this example, the numprocs directive will instruct Supervisor to run 8 queue:work processes and monitor all of them, automatically restarting them if they fail. You should change the queue:work sqs portion of the command directive to reflect your desired queue connection. Starting Supervisor Once the configuration file has been created, you may update the Supervisor configuration and start the processes using the following commands: sudo supervisorctl reread sudo supervisorctl update sudo supervisorctl start laravel-worker:* For more information on Supervisor, consult the Supervisor documentation. Dealing With Failed Jobs Sometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to specify the maximum number of times a job should be attempted. After a job has exceeded this amount of attempts, it will be inserted into the failed_jobs database table. To create a migration for the failed_jobs table, you may use the queue:failed-table command: php artisan queue:failed-table php artisan migrate Then, when running your queue worker, you should specify the maximum number of times a job should be attempted using the --tries switch on the queue:work command. If you do not specify a value for the --tries option, jobs will be attempted indefinitely: php artisan queue:work redis --tries=3 In addition, you may specify how many seconds Laravel should wait before retrying a job that has failed using the --delay option. By default, a job is retried immediately: php artisan queue:work redis --tries=3 --delay=3 If you would like to configure the failed job retry delay on a per-job basis, you may do so by defining a retryAfter property on your queued job class: /* * The number of seconds to wait before retrying the job. * * @var int / public $retryAfter = 3; Cleaning Up After Failed Jobs You may define a failed method directly on your job class, allowing you to perform job specific clean-up when a failure occurs. This is the perfect location to send an alert to your users or revert any actions performed by the job. The Exception that caused the job to fail will be passed to the failed method: namespace App\\Jobs; use Exception; use App\\Podcast; use App\\AudioProcessor; use Illuminate\\Bus\\Queueable; use Illuminate\\Queue\\SerializesModels; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Contracts\\Queue\\ShouldQueue; class ProcessPodcast implements ShouldQueue { use InteractsWithQueue, Queueable, SerializesModels; protected $podcast; /** * Create a new job instance. * * @param Podcast $podcast * @return void */ public function __construct(Podcast $podcast) { $this->podcast = $podcast; } /** * Execute the job. * * @param AudioProcessor $processor * @return void */ public function handle(AudioProcessor $processor) { // Process uploaded podcast... } /** * The job failed to process. * * @param Exception $exception * @return void */ public function failed(Exception $exception) { // Send user notification of failure, etc... } } Failed Job Events If you would like to register an event that will be called when a job fails, you may use the Queue::failing method. This event is a great opportunity to notify your team via email or Slack. For example, we may attach a callback to this event from the AppServiceProvider that is included with Laravel: namespace App\\Providers; use Illuminate\\Support\\Facades\\Queue; use Illuminate\\Queue\\Events\\JobFailed; use Illuminate\\Support\\ServiceProvider; class AppServiceProvider extends ServiceProvider { /* * Register any application services. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { Queue::failing(function (JobFailed $event) { // $event->connectionName // $event->job // $event->exception }); } } Retrying Failed Jobs To view all of your failed jobs that have been inserted into your failed_jobs database table, you may use the queue:failed Artisan command: php artisan queue:failed The queue:failed command will list the job ID, connection, queue, and failure time. The job ID may be used to retry the failed job. For instance, to retry a failed job that has an ID of 5, issue the following command: php artisan queue:retry 5 To retry all of your failed jobs, execute the queue:retry command and pass all as the ID: php artisan queue:retry all If you would like to delete a failed job, you may use the queue:forget command: php artisan queue:forget 5 To delete all of your failed jobs, you may use the queue:flush command: php artisan queue:flush Ignoring Missing Models When injecting an Eloquent model into a job, it is automatically serialized before being placed on the queue and restored when the job is processed. However, if the model has been deleted while the job was waiting to be processed by a worker, your job may fail with a ModelNotFoundException. For convenience, you may choose to automatically delete jobs with missing models by setting your job's deleteWhenMissingModels property to true: /* * Delete the job if its models no longer exist. * * @var bool / public $deleteWhenMissingModels = true; Job Events Using the before and after methods on the Queue facade, you may specify callbacks to be executed before or after a queued job is processed. These callbacks are a great opportunity to perform additional logging or increment statistics for a dashboard. Typically, you should call these methods from a service provider. For example, we may use the AppServiceProvider that is included with Laravel: namespace App\\Providers; use Illuminate\\Support\\Facades\\Queue; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Queue\\Events\\JobProcessed; use Illuminate\\Queue\\Events\\JobProcessing; class AppServiceProvider extends ServiceProvider { /* * Register any application services. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { Queue::before(function (JobProcessing $event) { // $event->connectionName // $event->job // $event->job->payload() }); Queue::after(function (JobProcessed $event) { // $event->connectionName // $event->job // $event->job->payload() }); } } Using the looping method on the Queue facade, you may specify callbacks that execute before the worker attempts to fetch a job from a queue. For example, you might register a Closure to rollback any transactions that were left open by a previously failed job: Queue::looping(function () { while (DB::transactionLevel() > 0) { DB::rollBack(); } });","title":"Queue"},{"location":"developerdoc/laravel_routing/","text":"Laravel Routing Basic Routing Route paling dasar di Laravel adalah menerima URI dan sebuah closure, contoh: Route::get('foo', function () { return 'Hello World'; }); File Default Route Semua route Laravel didefinisikan dalam file-file route, yang terletak di folder routes . File-file ini dimuat secara otomatis oleh framework. File routes/web.php berisi definisi route untuk web interface. Route ini diset untuk menggunakan web middleware group , yang menyediakan fungsi seperti session state dan CSRF protection . Route di dalam routes/api.php bersifat stateless dan menggunakan api middleware group . Kebanyakan aplikasi, dimulai dengan mendefinisikan route di dalam routes/web.php . Route yang didefinisikan di dalam routes/web.php dapat diakses dengan browser pada URLroute tersebut. contoh, Anda dapat mengakses route berikut dengan mengarahkan browser Anda ke http://your-app.test/user : Route::get('/user', 'UserController@index'); Route yang didefinisikan di dalam routes/api.php akan ditambah prefix URI /api . Prefix dapat diedit dalam class RouteServiceProvider . Available Router Methods Router mengijinkan Anda untuk mendaftarkan route Anda yang merespon HTTP verb berikut ini, Route::get($uri, $callback); Route::post($uri, $callback); Route::put($uri, $callback); Route::patch($uri, $callback); Route::delete($uri, $callback); Route::options($uri, $callback); Jika Anda ingin mendefinisikan satu route untuk beberapa HTTP verb, gunakan seperti contoh di bawah ini, Route::match(['get', 'post'], '/', function () { // }); Route::any('/', function () { // }); CSRF Protection Setiap form HTML yang mengirimkan request ke route dengan HTTP verb POST, PUT, or DELETE yang diedfinisikan dalam file routes/web.php harus menyertakan CSRF token dalam request-nya. Kalau tidak menyertakan, request akan ditolak. <form method=\"POST\" action=\"/profile\"> @csrf ... </form> Redirect Routes Jika Anda mendefinisikan route yang mengalihkan request ke URI lain, Anda dapat menggunakan Route::redirect . Cara ini menyediakan pintasan yang memudahkan Anda agar tidak perlu mendefinisikan secara lengkap route atau controller untuk redirect yang sederhana: Route::redirect('/here', '/there'); Secara default, Route::redirect mengembalikan kode status 302. Anda dapat mengubahn kode status dengan parameter ketiga (optional): Route::redirect('/here', '/there', 301); Anda dapat menggunakan Route::permanentRedirect untuk mengembalikan kode status 301: Route::permanentRedirect('/here', '/there'); View Routes Jika Anda menggunakan route yang hanya mengembalikan view , Anda dapat menggunakan Route::view . Contoh: Route::view('/welcome', 'welcome'); Route::view('/welcome', 'welcome', ['name' => 'Taylor']); Route Parameters Required Parameters Kadang Anda perlu menangkap bagian dari URI dalam route Anda. Anda dapat mendefinisikan route Anda untuk menerima parameter. Route::get('user/{id}', function ($id) { return 'User '.$id; }); Anda dapat mendefinisikan parameter route sebagai keharusan yang harus dipenuhi dari request yang diterima: Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) { // }); Parameter route selalu diapit dengan tanda kurung kurawal {} dan terdiri dari karakter alpanumerik, dan tidak boleh berisi karakter dash - . Anda dapat menggunakan karakter underscore _ . Parameter route akan dimasukkan ke route callbacks / controller berdasarkan urutan mereka - nama-nama pada argument fungsi callback / controller tidak berpengaruh. Optional Parameters Parameter route dapat bersifat opsional, kalau ada digunakan, kalau tidak ada juga dijalankan dengan nilai parameter null. Route::get('user/{name?}', function ($name = null) { return $name; }); Route::get('user/{name?}', function ($name = 'John') { return $name; }); Regular Expression Constraints Anda dapat menentukan format parameter yang dianggap valid dengan regular expression : Route::get('user/{name}', function ($name) { // })->where('name', '[A-Za-z]+'); Route::get('user/{id}', function ($id) { // })->where('id', '[0-9]+'); Route::get('user/{id}/{name}', function ($id, $name) { // })->where(['id' => '[0-9]+', 'name' => '[a-z]+']); Global Constraints Jika Anda ingin suatu nama parameter selalu divalidasi formatnya dengan regular expression , Anda dapat mendefinisikan secara global di RouteServiceProvider : /** * Define your route model bindings, pattern filters, etc. * * @return void */ public function boot() { Route::pattern('id', '[0-9]+'); parent::boot(); } Format yang didefinisikan di atas akan selalu digunakan untuk validasi format parameter route dengan nama tersebut: Route::get('user/{id}', function ($id) { // Only executed if {id} is numeric... }); Encoded Forward Slashes Komponen route Laravel mengijinkan pemakaian semua karakter selain garis miring ( / ). Jika Anda menggunakannya, Anda harus secara eksplisit mengijinkan karakter ( / ) dengan regular expression berikut: Route::get('search/{search}', function ($search) { return $search; })->where('search', '.*'); Encoded forward slashes hanya didukung untuk bagian terakhir dari route. Named Routes Route yang diberi nama mengijinkan pembentukan URL atau pengalihan menggunakan nama tersebut. Route::get('user/profile', function () { // })->name('profile'); Anda juga dapat memberi nama route untuk controller actions: Route::get('user/profile', 'UserProfileController@show')->name('profile'); Generating URLs To Named Routes Untuk menuju route yang memiliki nama, Anda dapat menggunakan fungsi berikut: // Generating URLs... $url = route('profile'); // Generating Redirects... return redirect()->route('profile'); Jika route yang diberi nama mengandung parameter, Anda dapat memanggilnya dengan memasukkan parameter sebagai parameter kedua di fungsi redirect ataupun pembentukan URL: Route::get('user/{id}/profile', function ($id) { // })->name('profile'); $url = route('profile', ['id' => 1]); Inspecting The Current Route Jika Anda ingin mengetahui apakah route yang digunakan untuk request saat ini menggunakan route dengan nama tertentu, Anda dapat menggunakan method name dari instansi route saat ini: /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($request->route()->named('profile')) { // } return $next($request); } Route Groups Route group memudahkan Anda untuk berbagi atribut dari route, misal middleware atau namespace, ke banyak route tanpa perlu mendefinisikan satu persatu pada masing-masing route. Atribut yang dibagi didefinisikan dengan format array di parameter pertama dari method Route::group . Group dapat berisi group lain, dan akan secara otomatis merge atribut yang dipunyainya. Middleware dan kondisi where di-merge, tetapi name, namespace, dan prefix di-append (ditambahkan dibelakangnya). Delimiter namespace dan garis miring di URI prefix secara otomatis ditambahkan sesuai proporsinya. Middleware Untuk memasang middleware ke semua route dalam group, Anda dapat menggunakanmethod middleware sebelum mendefinisikan group. Middleware dijalankan sesuai urutan dalam array tersebut: Route::middleware(['first', 'second'])->group(function () { Route::get('/', function () { // Uses first & second Middleware }); Route::get('user/profile', function () { // Uses first & second Middleware }); }); Namespaces Route group juga dapat digunakan untuk memasang namespace ke kelompok controller dengan method namespace : Route::namespace('Admin')->group(function () { // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace }); Ingat, secara default, RouteServiceProvider memasukkan file-file route dalam sebuah namespace group, sehingga Anda dapat mendaftarkan route controller tanpa menuliskan lengkap prefix dari controller App\\Http\\Controllers . Jadi Anda cukup menuliskan bagian namespace setelah namespace App\\Http\\Controllers . Sub-Domain Routing Route group juga dapat digunakan untuk menangani sub-domain routing. Sub-domain dapat dipasangkan sebagai parameter seperti URI route lain, sehingga Anda dapat membaca nilai bagian sub-domain untuk digunakan pada route atau controller Anda. Route::domain('{account}.myapp.com')->group(function () { Route::get('user/{id}', function ($account, $id) { // }); }); Untuk memastikan route sub-domain dapat diakses, Anda harus mendaftarkan route sub-domain sebelum route root domain . Agar definisinya tidak ditimpa route dari root domain yang mempunyai URI path yang sama. Route Prefixes Method prefix dapat digunakan untuk menambah prefiks setiap URI route dalam group. Route::prefix('admin')->group(function () { Route::get('users', function () { // Matches The \"/admin/users\" URL }); }); Route Name Prefixes Method name dapat digunakan untuk menambahkan prefiks setiap nama route dalam group. Route::name('admin.')->group(function () { Route::get('users', function () { // Route assigned name \"admin.users\"... })->name('users'); }); Route Model Binding Ketika memasukkan sebuah ID model ke sebuah route atau controller action, Anda akan berulang kali menjalankan query untuk mendapatkan model sesuai ID tersebut. Dengan Laravel route model binding, Anda dapat memasukkan instansi model tersebut ke route Anda, sehingga Anda hanya perlu melakukan query di awal saja. Implicit Binding Laravel secara otomatis mengenali Eloquent model yang didefinisikan di dalam route atau controller action dengan petunjuk nama variable sesuai nama segmen route. contoh: Route::get('api/users/{user}', function (App\\User $user) { return $user->email; }); Karena variable $user mengacu App\\User Eloquent model dan nama variable sesuai {user} URI segment , Laravel secara otomatis akan memasukkan (inject) instansi model tersebut yang mempunyai ID sesuai nilai yang diperoleh dari request URI. Jika instansi model yang sesuai tidak ditemukan dalam database, akan dikembalikan 404 HTTP response ke client browser. Customizing The Key Name Jika Anda ingin menggunakan kolom lain selain ID, Anda dapat melakukan override method getRouteKeyName pada Eloquent model: /** * Get the route key for the model. * * @return string */ public function getRouteKeyName() { return 'slug'; } Explicit Binding Untuk mendaftarkan binding secara eksplisit, gunakan method model dari router. Ini didefinisikan dalam method boot pada class RouteServiceProvider : public function boot() { parent::boot(); Route::model('user', App\\User::class); } Selanjutnya, definisikan sebuah route yang berisi parameter {user}: Route::get('profile/{user}', function (App\\User $user) { // }); Karena kita mengikatkan semua parameter {user} ke model App\\User , instansi User akan dimasukkan ke dalam route. Jadi, sebagai contoh, request ke profile/1 akan memasukkan instansi User dari database yang mempunyai ID = 1. Customizing The Resolution Logic Jika Anda ingin menggunakan logika resolusi Anda sendiri, Anda dapat menggunakan method Route::bind. Closure yang Anda lewatkan pada method bind akan menerima nilai dari segmen URI dan harus mengembalikan instansi dari class yang harus dimasukkan ke dalam route: /** * Bootstrap any application services. * * @return void */ public function boot() { parent::boot(); Route::bind('user', function ($value) { return App\\User::where('name', $value)->first() ?? abort(404); }); } Sebagai alternatif, Anda dapat meng-overrride method resolveRouteBinding pada Eloquent model Anda. Method ini akan menerima nilai dari segmen URI dan harus mengembalikan instansi dari class yang harus dimasukkan ke dalam route: /** * Retrieve the model for a bound value. * * @param mixed $value * @return \\Illuminate\\Database\\Eloquent\\Model|null */ public function resolveRouteBinding($value) { return $this->where('name', $value)->first() ?? abort(404); } Fallback Routes Menggunakan method Route::fallback , Anda dapat mendefinisikan sebuah route yang akan dijalankan ketika tidak ada route yang lain yang sesuai dengan request masuk. Umumnya, request yang tidak ditangani akan secara otomatis mengembalikan halaman \"404\" via exception handler aplikasi Anda. Meskipun demikian, karena Anda boleh mendefinisikan route fallback dalam routes/web.php , maka semua middleware dalam web middleware group akan dijalankan untuk route tersebut. Anda bebas menambahkan middleware tambahan pada route tersebut jika dibutuhkan: Route::fallback(function () { // }); Route fallback harus selalu menjadi route terakhir yang didaftarkan. Rate Limiting Laravel menyertakan sebuah middleware untuk membatasi jumlah akses ke route-route dalam aplikasi Anda. Untuk mencobanya, pasangkan throttle middleware ke sebuah route atau sebuah group route. Throttle middleware mempunyai 2 parameter yang menentukan maksimum jumlah request yang dapat diterima dalam sejumlah menit. Contoh, suatu group didefinisikan boleh menerima request dari user yang terauthentikasi maksimum 60x request per menit: Route::middleware('auth:api', 'throttle:60,1')->group(function () { Route::get('/user', function () { // }); }); Dynamic Rate Limiting Anda juga dapat mendefinisikan nilai maksimum akses secara dinamis Sebagai contoh jika User model mempunyai atribut rate_limit, Route::middleware('auth:api', 'throttle:rate_limit,1')->group(function () { Route::get('/user', function () { // }); }); Form Method Spoofing HTML form tidak mendukung action: PUT, PATCH atau DELETE. Maka, ketika mendefinisikan route PUT, PATCH atau DELETE yang dipanggil dari HTML form, Anda perlu menambahkan hidden _method field ke dalam form. Nilai yang dikirimkan dengan field _method akan digunakan sebagai HTTP request method : <form action=\"/foo/bar\" method=\"POST\"> <input type=\"hidden\" name=\"_method\" value=\"PUT\"> <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\"> </form> Anda dapat menggunakan @method pada Blade untuk membentuk field _method : <form action=\"/foo/bar\" method=\"POST\"> @method('PUT') @csrf </form> Accessing The Current Route Anda dapat mengetahui route saat ini yang digunakan dengan method current , currentRouteName , dan currentRouteAction pada Route facade : $route = Route::current(); $name = Route::currentRouteName(); $action = Route::currentRouteAction(); Laravel Middleware Middleware provide a convenient mechanism for filtering HTTP requests entering your application. For example, Laravel includes a middleware that verifies the user of your application is authenticated. If the user is not authenticated, the middleware will redirect the user to the login screen. However, if the user is authenticated, the middleware will allow the request to proceed further into the application. Additional middleware can be written to perform a variety of tasks besides authentication. A CORS middleware might be responsible for adding the proper headers to all responses leaving your application. A logging middleware might log all incoming requests to your application. There are several middleware included in the Laravel framework, including middleware for authentication and CSRF protection. All of these middleware are located in the app/Http/Middleware directory. Defining Middleware To create a new middleware, use the make:middleware Artisan command: php artisan make:middleware CheckAge This command will place a new CheckAge class within your app/Http/Middleware directory. In this middleware, we will only allow access to the route if the supplied age is greater than 200. Otherwise, we will redirect the users back to the home URI: <?php namespace App\\Http\\Middleware; use Closure; class CheckAge { /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($request->age <= 200) { return redirect('home'); } return $next($request); } } As you can see, if the given age is less than or equal to 200, the middleware will return an HTTP redirect to the client; otherwise, the request will be passed further into the application. To pass the request deeper into the application (allowing the middleware to \"pass\"), call the $next callback with the $request. It's best to envision middleware as a series of \"layers\" HTTP requests must pass through before they hit your application. Each layer can examine the request and even reject it entirely. All middleware are resolved via the service container, so you may type-hint any dependencies you need within a middleware's constructor. Before & After Middleware Whether a middleware runs before or after a request depends on the middleware itself. For example, the following middleware would perform some task before the request is handled by the application: <?php namespace App\\Http\\Middleware; use Closure; class BeforeMiddleware { public function handle($request, Closure $next) { // Perform action return $next($request); } } However, this middleware would perform its task after the request is handled by the application: <?php namespace App\\Http\\Middleware; use Closure; class AfterMiddleware { public function handle($request, Closure $next) { $response = $next($request); // Perform action return $response; } } Registering Middleware Global Middleware If you want a middleware to run during every HTTP request to your application, list the middleware class in the $middleware property of your app/Http/Kernel.php class. Assigning Middleware To Routes If you would like to assign middleware to specific routes, you should first assign the middleware a key in your app/Http/Kernel.php file. By default, the $routeMiddleware property of this class contains entries for the middleware included with Laravel. To add your own, append it to this list and assign it a key of your choosing: // Within App\\Http\\Kernel Class... protected $routeMiddleware = [ 'auth' => \\App\\Http\\Middleware\\Authenticate::class, 'auth.basic' => \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, 'bindings' => \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 'cache.headers' => \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class, 'can' => \\Illuminate\\Auth\\Middleware\\Authorize::class, 'guest' => \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, 'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, 'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, 'verified' => \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class, ]; Once the middleware has been defined in the HTTP kernel, you may use the middleware method to assign middleware to a route: Route::get('admin/profile', function () { // })->middleware('auth'); You may also assign multiple middleware to the route: Route::get('/', function () { // })->middleware('first', 'second'); When assigning middleware, you may also pass the fully qualified class name: use App\\Http\\Middleware\\CheckAge; Route::get('admin/profile', function () { // })->middleware(CheckAge::class); Middleware Groups Sometimes you may want to group several middleware under a single key to make them easier to assign to routes. You may do this using the $middlewareGroups property of your HTTP kernel. Out of the box, Laravel comes with web and api middleware groups that contain common middleware you may want to apply to your web UI and API routes: /** * The application's route middleware groups. * * @var array */ protected $middlewareGroups = [ 'web' => [ \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], 'api' => [ 'throttle:60,1', 'auth:api', ], ]; Middleware groups may be assigned to routes and controller actions using the same syntax as individual middleware. Again, middleware groups make it more convenient to assign many middleware to a route at once: Route::get('/', function () { // })->middleware('web'); Route::group(['middleware' => ['web']], function () { // }); Out of the box, the web middleware group is automatically applied to your routes/web.php file by the RouteServiceProvider. Sorting Middleware Rarely, you may need your middleware to execute in a specific order but not have control over their order when they are assigned to the route. In this case, you may specify your middleware priority using the $middlewarePriority property of your app/Http/Kernel.php file: /** * The priority-sorted list of middleware. * * This forces non-global middleware to always be in the given order. * * @var array */ protected $middlewarePriority = [ \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\Authenticate::class, \\Illuminate\\Session\\Middleware\\AuthenticateSession::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, \\Illuminate\\Auth\\Middleware\\Authorize::class, ]; Middleware Parameters Middleware can also receive additional parameters. For example, if your application needs to verify that the authenticated user has a given \"role\" before performing a given action, you could create a CheckRole middleware that receives a role name as an additional argument. Additional middleware parameters will be passed to the middleware after the $next argument: <?php namespace App\\Http\\Middleware; use Closure; class CheckRole { /** * Handle the incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string $role * @return mixed */ public function handle($request, Closure $next, $role) { if (! $request->user()->hasRole($role)) { // Redirect... } return $next($request); } } Middleware parameters may be specified when defining the route by separating the middleware name and parameters with a :. Multiple parameters should be delimited by commas: Route::put('post/{id}', function ($id) { // })->middleware('role:editor'); Terminable Middleware Sometimes a middleware may need to do some work after the HTTP response has been sent to the browser. For example, the \"session\" middleware included with Laravel writes the session data to storage after the response has been sent to the browser. If you define a terminate method on your middleware and your web server is using FastCGI, the terminate method will automatically be called after the response is sent to the browser. <?php namespace Illuminate\\Session\\Middleware; use Closure; class StartSession { public function handle($request, Closure $next) { return $next($request); } public function terminate($request, $response) { // Store the session data... } } The terminate method should receive both the request and the response. Once you have defined a terminable middleware, you should add it to the list of route or global middleware in the app/Http/Kernel.php file. When calling the terminate method on your middleware, Laravel will resolve a fresh instance of the middleware from the service container. If you would like to use the same middleware instance when the handle and terminate methods are called, register the middleware with the container using the container's singleton method. CSRF Protection Introduction Laravel makes it easy to protect your application from cross-site request forgery (CSRF) attacks. Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user. Laravel automatically generates a CSRF \"token\" for each active user session managed by the application. This token is used to verify that the authenticated user is the one actually making the requests to the application. Anytime you define an HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field: <form method=\"POST\" action=\"/profile\"> @csrf ... </form> The VerifyCsrfToken middleware, which is included in the web middleware group, will automatically verify that the token in the request input matches the token stored in the session. CSRF Tokens & JavaScript When building JavaScript driven applications, it is convenient to have your JavaScript HTTP library automatically attach the CSRF token to every outgoing request. By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application. Excluding URIs From CSRF Protection Sometimes you may wish to exclude a set of URIs from CSRF protection. For example, if you are using Stripe to process payments and are utilizing their webhook system, you will need to exclude your Stripe webhook handler route from CSRF protection since Stripe will not know what CSRF token to send to your routes. Typically, you should place these kinds of routes outside of the web middleware group that the RouteServiceProvider applies to all routes in the routes/web.php file. However, you may also exclude the routes by adding their URIs to the $except property of the VerifyCsrfToken middleware: <?php namespace App\\Http\\Middleware; use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware; class VerifyCsrfToken extends Middleware { /** * The URIs that should be excluded from CSRF verification. * * @var array */ protected $except = [ 'stripe/*', 'http://example.com/foo/bar', 'http://example.com/foo/*', ]; } The CSRF middleware is automatically disabled when running tests. X-CSRF-TOKEN In addition to checking for the CSRF token as a POST parameter, the VerifyCsrfToken middleware will also check for the X-CSRF-TOKEN request header. You could, for example, store the token in an HTML meta tag: <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\"> Then, once you have created the meta tag, you can instruct a library like jQuery to automatically add the token to all request headers. This provides simple, convenient CSRF protection for your AJAX based applications: $.ajaxSetup({ headers: { 'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content') } }); By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application. X-XSRF-TOKEN Laravel stores the current CSRF token in a XSRF-TOKEN cookie that is included with each response generated by the framework. You can use the cookie value to set the X-XSRF-TOKEN request header. This cookie is primarily sent as a convenience since some JavaScript frameworks and libraries, like Angular and Axios, automatically place its value in the X-XSRF-TOKEN header. Laravel Controller Instead of defining all of your request handling logic as Closures in route files, you may wish to organize this behavior using Controller classes. Controllers can group related request handling logic into a single class. Controllers are stored in the app/Http/Controllers directory. Basic Controllers Defining Controllers Below is an example of a basic controller class. Note that the controller extends the base controller class included with Laravel. The base class provides a few convenience methods such as the middleware method, which may be used to attach middleware to controller actions: <?php namespace App\\Http\\Controllers; use App\\User; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show the profile for the given user. * * @param int $id * @return View */ public function show($id) { return view('user.profile', ['user' => User::findOrFail($id)]); } } You can define a route to this controller action like so: Route::get('user/{id}', 'UserController@show'); Now, when a request matches the specified route URI, the show method on the UserController class will be executed. The route parameters will also be passed to the method. Controllers are not required to extend a base class. However, you will not have access to convenience features such as the middleware, validate, and dispatch methods. Controllers & Namespaces It is very important to note that we did not need to specify the full controller namespace when defining the controller route. Since the RouteServiceProvider loads your route files within a route group that contains the namespace, we only specified the portion of the class name that comes after the App\\Http\\Controllers portion of the namespace. If you choose to nest your controllers deeper into the App\\Http\\Controllers directory, use the specific class name relative to the App\\Http\\Controllers root namespace. So, if your full controller class is App\\Http\\Controllers\\Photos\\AdminController, you should register routes to the controller like so: Route::get('foo', 'Photos\\AdminController@method'); Single Action Controllers If you would like to define a controller that only handles a single action, you may place a single __invoke method on the controller: <?php namespace App\\Http\\Controllers; use App\\User; use App\\Http\\Controllers\\Controller; class ShowProfile extends Controller { /** * Show the profile for the given user. * * @param int $id * @return View */ public function __invoke($id) { return view('user.profile', ['user' => User::findOrFail($id)]); } } When registering routes for single action controllers, you do not need to specify a method: Route::get('user/{id}', 'ShowProfile'); You may generate an invokable controller by using the --invokable option of the make:controller Artisan command: php artisan make:controller ShowProfile --invokable Controller Middleware Middleware may be assigned to the controller's routes in your route files: Route::get('profile', 'UserController@show')->middleware('auth'); However, it is more convenient to specify middleware within your controller's constructor. Using the middleware method from your controller's constructor, you may easily assign middleware to the controller's action. You may even restrict the middleware to only certain methods on the controller class: class UserController extends Controller { /** * Instantiate a new controller instance. * * @return void */ public function __construct() { $this->middleware('auth'); $this->middleware('log')->only('index'); $this->middleware('subscribed')->except('store'); } } Controllers also allow you to register middleware using a Closure. This provides a convenient way to define a middleware for a single controller without defining an entire middleware class: $this->middleware(function ($request, $next) { // ... return $next($request); }); You may assign middleware to a subset of controller actions; however, it may indicate your controller is growing too large. Instead, consider breaking your controller into multiple, smaller controllers. Resource Controllers Laravel resource routing assigns the typical \"CRUD\" routes to a controller with a single line of code. For example, you may wish to create a controller that handles all HTTP requests for \"photos\" stored by your application. Using the make:controller Artisan command, we can quickly create such a controller: php artisan make:controller PhotoController --resource This command will generate a controller at app/Http/Controllers/PhotoController.php. The controller will contain a method for each of the available resource operations. Next, you may register a resourceful route to the controller: Route::resource('photos', 'PhotoController'); This single route declaration creates multiple routes to handle a variety of actions on the resource. The generated controller will already have methods stubbed for each of these actions, including notes informing you of the HTTP verbs and URIs they handle. You may register many resource controllers at once by passing an array to the resources method: Route::resources([ 'photos' => 'PhotoController', 'posts' => 'PostController' ]); Actions Handled By Resource Controller Verb URI Action Route Name GET /photos index photos.index GET /photos/create create photos.create POST /photos store photos.store GET /photos/{photo} show photos.show GET /photos/{photo}/edit edit photos.edit PUT/PATCH /photos/{photo} update photos.update DELETE /photos/{photo} destroy photos.destroy Specifying The Resource Model If you are using route model binding and would like the resource controller's methods to type-hint a model instance, you may use the --model option when generating the controller: php artisan make:controller PhotoController --resource --model=Photo Spoofing Form Methods Since HTML forms can't make PUT, PATCH, or DELETE requests, you will need to add a hidden _method field to spoof these HTTP verbs. The @method Blade directive can create this field for you: <form action=\"/foo/bar\" method=\"POST\"> @method('PUT') </form> Partial Resource Routes When declaring a resource route, you may specify a subset of actions the controller should handle instead of the full set of default actions: Route::resource('photos', 'PhotoController')->only([ 'index', 'show' ]); Route::resource('photos', 'PhotoController')->except([ 'create', 'store', 'update', 'destroy' ]); API Resource Routes When declaring resource routes that will be consumed by APIs, you will commonly want to exclude routes that present HTML templates such as create and edit. For convenience, you may use the apiResource method to automatically exclude these two routes: Route::apiResource('photos', 'PhotoController'); You may register many API resource controllers at once by passing an array to the apiResources method: Route::apiResources([ 'photos' => 'PhotoController', 'posts' => 'PostController' ]); To quickly generate an API resource controller that does not include the create or edit methods, use the --api switch when executing the make:controller command: php artisan make:controller API/PhotoController --api Naming Resource Routes By default, all resource controller actions have a route name; however, you can override these names by passing a names array with your options: Route::resource('photos', 'PhotoController')->names([ 'create' => 'photos.build' ]); Naming Resource Route Parameters By default, Route::resource will create the route parameters for your resource routes based on the \"singularized\" version of the resource name. You can easily override this on a per resource basis by using the parameters method. The array passed into the parameters method should be an associative array of resource names and parameter names: Route::resource('users', 'AdminUserController')->parameters([ 'users' => 'admin_user' ]); The example above generates the following URIs for the resource's show route: /users/{admin_user} Localizing Resource URIs By default, Route::resource will create resource URIs using English verbs. If you need to localize the create and edit action verbs, you may use the Route::resourceVerbs method. This may be done in the boot method of your AppServiceProvider: use Illuminate\\Support\\Facades\\Route; /** * Bootstrap any application services. * * @return void */ public function boot() { Route::resourceVerbs([ 'create' => 'crear', 'edit' => 'editar', ]); } Once the verbs have been customized, a resource route registration such as Route::resource('fotos', 'PhotoController') will produce the following URIs: /fotos/crear /fotos/{foto}/editar Supplementing Resource Controllers If you need to add additional routes to a resource controller beyond the default set of resource routes, you should define those routes before your call to Route::resource; otherwise, the routes defined by the resource method may unintentionally take precedence over your supplemental routes: Route::get('photos/popular', 'PhotoController@method'); Route::resource('photos', 'PhotoController'); Remember to keep your controllers focused. If you find yourself routinely needing methods outside of the typical set of resource actions, consider splitting your controller into two, smaller controllers. Dependency Injection & Controllers Constructor Injection The Laravel service container is used to resolve all Laravel controllers. As a result, you are able to type-hint any dependencies your controller may need in its constructor. The declared dependencies will automatically be resolved and injected into the controller instance: <?php namespace App\\Http\\Controllers; use App\\Repositories\\UserRepository; class UserController extends Controller { /** * The user repository instance. */ protected $users; /** * Create a new controller instance. * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) { $this->users = $users; } } You may also type-hint any Laravel contract. If the container can resolve it, you can type-hint it. Depending on your application, injecting your dependencies into your controller may provide better testability. Method Injection In addition to constructor injection, you may also type-hint dependencies on your controller's methods. A common use-case for method injection is injecting the Illuminate\\Http\\Request instance into your controller methods: <?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Store a new user. * * @param Request $request * @return Response */ public function store(Request $request) { $name = $request->name; // } } If your controller method is also expecting input from a route parameter, list your route arguments after your other dependencies. For example, if your route is defined like so: Route::put('user/{id}', 'UserController@update'); You may still type-hint the Illuminate\\Http\\Request and access your id parameter by defining your controller method as follows: <?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Update the given user. * * @param Request $request * @param string $id * @return Response */ public function update(Request $request, $id) { // } } Route Caching Closure based routes cannot be cached. To use route caching, you must convert any Closure routes to controller classes. If your application is exclusively using controller based routes, you should take advantage of Laravel's route cache. Using the route cache will drastically decrease the amount of time it takes to register all of your application's routes. In some cases, your route registration may even be up to 100x faster. To generate a route cache, just execute the route:cache Artisan command: php artisan route:cache After running this command, your cached routes file will be loaded on every request. Remember, if you add any new routes you will need to generate a fresh route cache. Because of this, you should only run the route:cache command during your project's deployment. You may use the route:clear command to clear the route cache: php artisan route:clear Request Accessing The Request To obtain an instance of the current HTTP request via dependency injection, you should type-hint the Illuminate\\Http\\Request class on your controller method. The incoming request instance will automatically be injected by the service container: <?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Store a new user. * * @param Request $request * @return Response */ public function store(Request $request) { $name = $request->input('name'); // } } Dependency Injection & Route Parameters If your controller method is also expecting input from a route parameter you should list your route parameters after your other dependencies. For example, if your route is defined like so: Route::put('user/{id}', 'UserController@update'); You may still type-hint the Illuminate\\Http\\Request and access your route parameter id by defining your controller method as follows: <?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Update the specified user. * * @param Request $request * @param string $id * @return Response */ public function update(Request $request, $id) { // } } Accessing The Request Via Route Closures You may also type-hint the Illuminate\\Http\\Request class on a route Closure. The service container will automatically inject the incoming request into the Closure when it is executed: use Illuminate\\Http\\Request; Route::get('/', function (Request $request) { // }); Request Path & Method The Illuminate\\Http\\Request instance provides a variety of methods for examining the HTTP request for your application and extends the Symfony\\Component\\HttpFoundation\\Request class. We will discuss a few of the most important methods below. Retrieving The Request Path The path method returns the request's path information. So, if the incoming request is targeted at http://domain.com/foo/bar, the path method will return foo/bar: $uri = $request->path(); The is method allows you to verify that the incoming request path matches a given pattern. You may use the * character as a wildcard when utilizing this method: if ($request->is('admin/*')) { // } Retrieving The Request URL To retrieve the full URL for the incoming request you may use the url or fullUrl methods. The url method will return the URL without the query string, while the fullUrl method includes the query string: // Without Query String... $url = $request->url(); // With Query String... $url = $request->fullUrl(); Retrieving The Request Method The method method will return the HTTP verb for the request. You may use the isMethod method to verify that the HTTP verb matches a given string: $method = $request->method(); if ($request->isMethod('post')) { // } PSR-7 Requests The PSR-7 standard specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain an instance of a PSR-7 request instead of a Laravel request, you will first need to install a few libraries. Laravel uses the Symfony HTTP Message Bridge component to convert typical Laravel requests and responses into PSR-7 compatible implementations: composer require symfony/psr-http-message-bridge composer require zendframework/zend-diactoros Once you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your route Closure or controller method: use Psr\\Http\\Message\\ServerRequestInterface; Route::get('/', function (ServerRequestInterface $request) { // }); If you return a PSR-7 response instance from a route or controller, it will automatically be converted back to a Laravel response instance and be displayed by the framework. Input Trimming & Normalization By default, Laravel includes the TrimStrings and ConvertEmptyStringsToNull middleware in your application's global middleware stack. These middleware are listed in the stack by the App\\Http\\Kernel class. These middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to null. This allows you to not have to worry about these normalization concerns in your routes and controllers. If you would like to disable this behavior, you may remove the two middleware from your application's middleware stack by removing them from the $middleware property of your App\\Http\\Kernel class. Retrieving Input Retrieving All Input Data You may also retrieve all of the input data as an array using the all method: $input = $request->all(); Retrieving An Input Value Using a few simple methods, you may access all of the user input from your Illuminate\\Http\\Request instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the input method may be used to retrieve user input: $name = $request->input('name'); You may pass a default value as the second argument to the input method. This value will be returned if the requested input value is not present on the request: $name = $request->input('name', 'Sally'); When working with forms that contain array inputs, use \"dot\" notation to access the arrays: $name = $request->input('products.0.name'); $names = $request->input('products.*.name'); You may call the input method without any arguments in order to retrieve all of the input values as an associative array: $input = $request->input(); Retrieving Input From The Query String While the input method retrieves values from entire request payload (including the query string), the query method will only retrieve values from the query string: $name = $request->query('name'); If the requested query string value data is not present, the second argument to this method will be returned: $name = $request->query('name', 'Helen'); You may call the query method without any arguments in order to retrieve all of the query string values as an associative array: $query = $request->query(); Retrieving Input Via Dynamic Properties You may also access user input using dynamic properties on the Illuminate\\Http\\Request instance. For example, if one of your application's forms contains a name field, you may access the value of the field like so: $name = $request->name; When using dynamic properties, Laravel will first look for the parameter's value in the request payload. If it is not present, Laravel will search for the field in the route parameters. Retrieving JSON Input Values When sending JSON requests to your application, you may access the JSON data via the input method as long as the Content-Type header of the request is properly set to application/json. You may even use \"dot\" syntax to dig into JSON arrays: $name = $request->input('user.name'); Retrieving A Portion Of The Input Data If you need to retrieve a subset of the input data, you may use the only and except methods. Both of these methods accept a single array or a dynamic list of arguments: $input = $request->only(['username', 'password']); $input = $request->only('username', 'password'); $input = $request->except(['credit_card']); $input = $request->except('credit_card'); The only method returns all of the key / value pairs that you request; however, it will not return key / value pairs that are not present on the request. Determining If An Input Value Is Present You should use the has method to determine if a value is present on the request. The has method returns true if the value is present on the request: if ($request->has('name')) { // } When given an array, the has method will determine if all of the specified values are present: if ($request->has(['name', 'email'])) { // } If you would like to determine if a value is present on the request and is not empty, you may use the filled method: if ($request->filled('name')) { // } Old Input Laravel allows you to keep input from one request during the next request. This feature is particularly useful for re-populating forms after detecting validation errors. However, if you are using Laravel's included validation features, it is unlikely you will need to manually use these methods, as some of Laravel's built-in validation facilities will call them automatically. Flashing Input To The Session The flash method on the Illuminate\\Http\\Request class will flash the current input to the session so that it is available during the user's next request to the application: $request->flash(); You may also use the flashOnly and flashExcept methods to flash a subset of the request data to the session. These methods are useful for keeping sensitive information such as passwords out of the session: $request->flashOnly(['username', 'email']); $request->flashExcept('password'); Flashing Input Then Redirecting Since you often will want to flash input to the session and then redirect to the previous page, you may easily chain input flashing onto a redirect using the withInput method: return redirect('form')->withInput(); return redirect('form')->withInput( $request->except('password') ); Retrieving Old Input To retrieve flashed input from the previous request, use the old method on the Request instance. The old method will pull the previously flashed input data from the session: $username = $request->old('username'); Laravel also provides a global old helper. If you are displaying old input within a Blade template, it is more convenient to use the old helper. If no old input exists for the given field, null will be returned: <input type=\"text\" name=\"username\" value=\"{{ old('username') }}\"> Cookies Retrieving Cookies From Requests All cookies created by the Laravel framework are encrypted and signed with an authentication code, meaning they will be considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the cookie method on a Illuminate\\Http\\Request instance: $value = $request->cookie('name'); Alternatively, you may use the Cookie facade to access cookie values: $value = Cookie::get('name'); Attaching Cookies To Responses You may attach a cookie to an outgoing Illuminate\\Http\\Response instance using the cookie method. You should pass the name, value, and number of minutes the cookie should be considered valid to this method: return response('Hello World')->cookie( 'name', 'value', $minutes ); The cookie method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native setcookie method: return response('Hello World')->cookie( 'name', 'value', $minutes, $path, $domain, $secure, $httpOnly ); Alternatively, you can use the Cookie facade to \"queue\" cookies for attachment to the outgoing response from your application. The queue method accepts a Cookie instance or the arguments needed to create a Cookie instance. These cookies will be attached to the outgoing response before it is sent to the browser: Cookie::queue(Cookie::make('name', 'value', $minutes)); Cookie::queue('name', 'value', $minutes); Generating Cookie Instances If you would like to generate a Symfony\\Component\\HttpFoundation\\Cookie instance that can be given to a response instance at a later time, you may use the global cookie helper. This cookie will not be sent back to the client unless it is attached to a response instance: $cookie = cookie('name', 'value', $minutes); return response('Hello World')->cookie($cookie); Files Retrieving Uploaded Files You may access uploaded files from a Illuminate\\Http\\Request instance using the file method or using dynamic properties. The file method returns an instance of the Illuminate\\Http\\UploadedFile class, which extends the PHP SplFileInfo class and provides a variety of methods for interacting with the file: $file = $request->file('photo'); $file = $request->photo; You may determine if a file is present on the request using the hasFile method: if ($request->hasFile('photo')) { // } Validating Successful Uploads In addition to checking if the file is present, you may verify that there were no problems uploading the file via the isValid method: if ($request->file('photo')->isValid()) { // } File Paths & Extensions The UploadedFile class also contains methods for accessing the file's fully-qualified path and its extension. The extension method will attempt to guess the file's extension based on its contents. This extension may be different from the extension that was supplied by the client: $path = $request->photo->path(); $extension = $request->photo->extension(); Other File Methods There are a variety of other methods available on UploadedFile instances. Check out the API documentation for the class for more information regarding these methods. Storing Uploaded Files To store an uploaded file, you will typically use one of your configured filesystems. The UploadedFile class has a store method which will move an uploaded file to one of your disks, which may be a location on your local filesystem or even a cloud storage location like Amazon S3. The store method accepts the path where the file should be stored relative to the filesystem's configured root directory. This path should not contain a file name, since a unique ID will automatically be generated to serve as the file name. The store method also accepts an optional second argument for the name of the disk that should be used to store the file. The method will return the path of the file relative to the disk's root: $path = $request->photo->store('images'); $path = $request->photo->store('images', 's3'); If you do not want a file name to be automatically generated, you may use the storeAs method, which accepts the path, file name, and disk name as its arguments: $path = $request->photo->storeAs('images', 'filename.jpg'); $path = $request->photo->storeAs('images', 'filename.jpg', 's3'); Configuring Trusted Proxies When running your applications behind a load balancer that terminates TLS / SSL certificates, you may notice your application sometimes does not generate HTTPS links. Typically this is because your application is being forwarded traffic from your load balancer on port 80 and does not know it should generate secure links. To solve this, you may use the App\\Http\\Middleware\\TrustProxies middleware that is included in your Laravel application, which allows you to quickly customize the load balancers or proxies that should be trusted by your application. Your trusted proxies should be listed as an array on the $proxies property of this middleware. In addition to configuring the trusted proxies, you may configure the proxy $headers that should be trusted: <?php namespace App\\Http\\Middleware; use Illuminate\\Http\\Request; use Fideloper\\Proxy\\TrustProxies as Middleware; class TrustProxies extends Middleware { /** * The trusted proxies for this application. * * @var array */ protected $proxies = [ '192.168.1.1', '192.168.1.2', ]; /** * The headers that should be used to detect proxies. * * @var string */ protected $headers = Request::HEADER_X_FORWARDED_ALL; } If you are using AWS Elastic Load Balancing, your $headers value should be Request::HEADER_X_FORWARDED_AWS_ELB. For more information on the constants that may be used in the $headers property, check out Symfony's documentation on trusting proxies. Trusting All Proxies If you are using Amazon AWS or another \"cloud\" load balancer provider, you may not know the IP addresses of your actual balancers. In this case, you may use * to trust all proxies: /** * The trusted proxies for this application. * * @var array */ protected $proxies = '*'; Response Creating Responses Strings & Arrays All routes and controllers should return a response to be sent back to the user's browser. Laravel provides several different ways to return responses. The most basic response is returning a string from a route or controller. The framework will automatically convert the string into a full HTTP response: Route::get('/', function () { return 'Hello World'; }); In addition to returning strings from your routes and controllers, you may also return arrays. The framework will automatically convert the array into a JSON response: Route::get('/', function () { return [1, 2, 3]; }); Did you know you can also return Eloquent collections from your routes or controllers? They will automatically be converted to JSON. Give it a shot! Response Objects Typically, you won't just be returning simple strings or arrays from your route actions. Instead, you will be returning full Illuminate\\Http\\Response instances or views. Returning a full Response instance allows you to customize the response's HTTP status code and headers. A Response instance inherits from the Symfony\\Component\\HttpFoundation\\Response class, which provides a variety of methods for building HTTP responses: Route::get('home', function () { return response('Hello World', 200) ->header('Content-Type', 'text/plain'); }); Attaching Headers To Responses Keep in mind that most response methods are chainable, allowing for the fluent construction of response instances. For example, you may use the header method to add a series of headers to the response before sending it back to the user: return response($content) ->header('Content-Type', $type) ->header('X-Header-One', 'Header Value') ->header('X-Header-Two', 'Header Value'); Or, you may use the withHeaders method to specify an array of headers to be added to the response: return response($content) ->withHeaders([ 'Content-Type' => $type, 'X-Header-One' => 'Header Value', 'X-Header-Two' => 'Header Value', ]); Cache Control Middleware Laravel includes a cache.headers middleware, which may be used to quickly set the Cache-Control header for a group of routes. If etag is specified in the list of directives, an MD5 hash of the response content will automatically be set as the ETag identifier: Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function() { Route::get('privacy', function () { // ... }); Route::get('terms', function () { // ... }); }); Attaching Cookies To Responses The cookie method on response instances allows you to easily attach cookies to the response. For example, you may use the cookie method to generate a cookie and fluently attach it to the response instance like so: return response($content) ->header('Content-Type', $type) ->cookie('name', 'value', $minutes); The cookie method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native setcookie method: ->cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly) Alternatively, you can use the Cookie facade to \"queue\" cookies for attachment to the outgoing response from your application. The queue method accepts a Cookie instance or the arguments needed to create a Cookie instance. These cookies will be attached to the outgoing response before it is sent to the browser: Cookie::queue(Cookie::make('name', 'value', $minutes)); Cookie::queue('name', 'value', $minutes); Cookies & Encryption By default, all cookies generated by Laravel are encrypted and signed so that they can't be modified or read by the client. If you would like to disable encryption for a subset of cookies generated by your application, you may use the $except property of the App\\Http\\Middleware\\EncryptCookies middleware, which is located in the app/Http/Middleware directory: /* * The names of the cookies that should not be encrypted. * * @var array / protected $except = [ 'cookie_name', ]; Redirects Redirect responses are instances of the Illuminate\\Http\\RedirectResponse class, and contain the proper headers needed to redirect the user to another URL. There are several ways to generate a RedirectResponse instance. The simplest method is to use the global redirect helper: Route::get('dashboard', function () { return redirect('home/dashboard'); }); Sometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid. You may do so by using the global back helper function. Since this feature utilizes the session, make sure the route calling the back function is using the web middleware group or has all of the session middleware applied: Route::post('user/profile', function () { // Validate the request... return back()->withInput(); }); Redirecting To Named Routes When you call the redirect helper with no parameters, an instance of Illuminate\\Routing\\Redirector is returned, allowing you to call any method on the Redirector instance. For example, to generate a RedirectResponse to a named route, you may use the route method: return redirect()->route('login'); If your route has parameters, you may pass them as the second argument to the route method: // For a route with the following URI: profile/{id} return redirect()->route('profile', ['id' => 1]); Populating Parameters Via Eloquent Models If you are redirecting to a route with an \"ID\" parameter that is being populated from an Eloquent model, you may pass the model itself. The ID will be extracted automatically: // For a route with the following URI: profile/{id} return redirect()->route('profile', [$user]); If you would like to customize the value that is placed in the route parameter, you should override the getRouteKey method on your Eloquent model: /* * Get the value of the model's route key. * * @return mixed / public function getRouteKey() { return $this->slug; } Redirecting To Controller Actions You may also generate redirects to controller actions. To do so, pass the controller and action name to the action method. Remember, you do not need to specify the full namespace to the controller since Laravel's RouteServiceProvider will automatically set the base controller namespace: return redirect()->action('HomeController@index'); If your controller route requires parameters, you may pass them as the second argument to the action method: return redirect()->action( 'UserController@profile', ['id' => 1] ); Redirecting To External Domains Sometimes you may need to redirect to a domain outside of your application. You may do so by calling the away method, which creates a RedirectResponse without any additional URL encoding, validation, or verification: return redirect()->away('https://www.google.com'); Redirecting With Flashed Session Data Redirecting to a new URL and flashing data to the session are usually done at the same time. Typically, this is done after successfully performing an action when you flash a success message to the session. For convenience, you may create a RedirectResponse instance and flash data to the session in a single, fluent method chain: Route::post('user/profile', function () { // Update the user's profile... return redirect('dashboard')->with('status', 'Profile updated!'); }); After the user is redirected, you may display the flashed message from the session. For example, using Blade syntax: @if (session('status')) {{ session('status') }} @endif Other Response Types The response helper may be used to generate other types of response instances. When the response helper is called without arguments, an implementation of the Illuminate\\Contracts\\Routing\\ResponseFactory contract is returned. This contract provides several helpful methods for generating responses. View Responses If you need control over the response's status and headers but also need to return a view as the response's content, you should use the view method: return response() ->view('hello', $data, 200) ->header('Content-Type', $type); Of course, if you do not need to pass a custom HTTP status code or custom headers, you should use the global view helper function. JSON Responses The json method will automatically set the Content-Type header to application/json, as well as convert the given array to JSON using the json_encode PHP function: return response()->json([ 'name' => 'Abigail', 'state' => 'CA' ]); If you would like to create a JSONP response, you may use the json method in combination with the withCallback method: return response() ->json(['name' => 'Abigail', 'state' => 'CA']) ->withCallback($request->input('callback')); File Downloads The download method may be used to generate a response that forces the user's browser to download the file at the given path. The download method accepts a file name as the second argument to the method, which will determine the file name that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third argument to the method: return response()->download($pathToFile); return response()->download($pathToFile, $name, $headers); return response()->download($pathToFile)->deleteFileAfterSend(); Symfony HttpFoundation, which manages file downloads, requires the file being downloaded to have an ASCII file name. Streamed Downloads Sometimes you may wish to turn the string response of a given operation into a downloadable response without having to write the contents of the operation to disk. You may use the streamDownload method in this scenario. This method accepts a callback, file name, and an optional array of headers as its arguments: return response()->streamDownload(function () { echo GitHub::api('repo') ->contents() ->readme('laravel', 'laravel')['contents']; }, 'laravel-readme.md'); File Responses The file method may be used to display a file, such as an image or PDF, directly in the user's browser instead of initiating a download. This method accepts the path to the file as its first argument and an array of headers as its second argument: return response()->file($pathToFile); return response()->file($pathToFile, $headers); Response Macros If you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use the macro method on the Response facade. For example, from a service provider's boot method: namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Support\\Facades\\Response; class ResponseMacroServiceProvider extends ServiceProvider { /* * Register the application's response macros. * * @return void / public function boot() { Response::macro('caps', function ($value) { return Response::make(strtoupper($value)); }); } } The macro function accepts a name as its first argument, and a Closure as its second. The macro's Closure will be executed when calling the macro name from a ResponseFactory implementation or the response helper: return response()->caps('foo'); View Creating Views Looking for more information on how to write Blade templates? Check out the full Blade documentation to get started. Views contain the HTML served by your application and separate your controller / application logic from your presentation logic. Views are stored in the resources/views directory. A simple view might look something like this: Hello, {{ $name }} Since this view is stored at resources/views/greeting.blade.php, we may return it using the global view helper like so: Route::get('/', function () { return view('greeting', ['name' => 'James']); }); As you can see, the first argument passed to the view helper corresponds to the name of the view file in the resources/views directory. The second argument is an array of data that should be made available to the view. In this case, we are passing the name variable, which is displayed in the view using Blade syntax. Views may also be nested within sub-directories of the resources/views directory. \"Dot\" notation may be used to reference nested views. For example, if your view is stored at resources/views/admin/profile.blade.php, you may reference it like so: return view('admin.profile', $data); Determining If A View Exists If you need to determine if a view exists, you may use the View facade. The exists method will return true if the view exists: use Illuminate\\Support\\Facades\\View; if (View::exists('emails.customer')) { // } Creating The First Available View Using the first method, you may create the first view that exists in a given array of views. This is useful if your application or package allows views to be customized or overwritten: return view()->first(['custom.admin', 'admin'], $data); You may also call this method via the View facade: use Illuminate\\Support\\Facades\\View; return View::first(['custom.admin', 'admin'], $data); Passing Data To Views As you saw in the previous examples, you may pass an array of data to views: return view('greetings', ['name' => 'Victoria']); When passing information in this manner, the data should be an array with key / value pairs. Inside your view, you can then access each value using its corresponding key, such as <?php echo $key; ?>. As an alternative to passing a complete array of data to the view helper function, you may use the with method to add individual pieces of data to the view: return view('greeting')->with('name', 'Victoria'); Sharing Data With All Views Occasionally, you may need to share a piece of data with all views that are rendered by your application. You may do so using the view facade's share method. Typically, you should place calls to share within a service provider's boot method. You are free to add them to the AppServiceProvider or generate a separate service provider to house them: namespace App\\Providers; use Illuminate\\Support\\Facades\\View; class AppServiceProvider extends ServiceProvider { /* * Register any application services. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { View::share('key', 'value'); } } View Composers View composers are callbacks or class methods that are called when a view is rendered. If you have data that you want to be bound to a view each time that view is rendered, a view composer can help you organize that logic into a single location. For this example, let's register the view composers within a service provider. We'll use the View facade to access the underlying Illuminate\\Contracts\\View\\Factory contract implementation. Remember, Laravel does not include a default directory for view composers. You are free to organize them however you wish. For example, you could create an app/Http/View/Composers directory: namespace App\\Providers; use Illuminate\\Support\\Facades\\View; use Illuminate\\Support\\ServiceProvider; class ViewServiceProvider extends ServiceProvider { /* * Register any application services. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { // Using class based composers... View::composer( 'profile', 'App\\Http\\View\\Composers\\ProfileComposer' ); // Using Closure based composers... View::composer('dashboard', function ($view) { // }); } } Remember, if you create a new service provider to contain your view composer registrations, you will need to add the service provider to the providers array in the config/app.php configuration file. Now that we have registered the composer, the ProfileComposer@compose method will be executed each time the profile view is being rendered. So, let's define the composer class: namespace App\\Http\\View\\Composers; use Illuminate\\View\\View; use App\\Repositories\\UserRepository; class ProfileComposer { /* * The user repository implementation. * * @var UserRepository / protected $users; /** * Create a new profile composer. * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) { // Dependencies automatically resolved by service container... $this->users = $users; } /** * Bind data to the view. * * @param View $view * @return void */ public function compose(View $view) { $view->with('count', $this->users->count()); } } Just before the view is rendered, the composer's compose method is called with the Illuminate\\View\\View instance. You may use the with method to bind data to the view. All view composers are resolved via the service container, so you may type-hint any dependencies you need within a composer's constructor. Attaching A Composer To Multiple Views You may attach a view composer to multiple views at once by passing an array of views as the first argument to the composer method: View::composer( ['profile', 'dashboard'], 'App\\Http\\View\\Composers\\MyViewComposer' ); The composer method also accepts the * character as a wildcard, allowing you to attach a composer to all views: View::composer('*', function ($view) { // }); View Creators View creators are very similar to view composers; however, they are executed immediately after the view is instantiated instead of waiting until the view is about to render. To register a view creator, use the creator method: View::creator('profile', 'App\\Http\\View\\Creators\\ProfileCreator'); Url Generation Introduction Laravel provides several helpers to assist you in generating URLs for your application. These are mainly helpful when building links in your templates and API responses, or when generating redirect responses to another part of your application. The Basics Generating Basic URLs The url helper may be used to generate arbitrary URLs for your application. The generated URL will automatically use the scheme (HTTP or HTTPS) and host from the current request: $post = App\\Post::find(1); echo url(\"/posts/{$post->id}\"); // http://example.com/posts/1 Accessing The Current URL If no path is provided to the url helper, a Illuminate\\Routing\\UrlGenerator instance is returned, allowing you to access information about the current URL: // Get the current URL without the query string... echo url()->current(); // Get the current URL including the query string... echo url()->full(); // Get the full URL for the previous request... echo url()->previous(); Each of these methods may also be accessed via the URL facade: use Illuminate\\Support\\Facades\\URL; echo URL::current(); URLs For Named Routes The route helper may be used to generate URLs to named routes. Named routes allow you to generate URLs without being coupled to the actual URL defined on the route. Therefore, if the route's URL changes, no changes need to be made to your route function calls. For example, imagine your application contains a route defined like the following: Route::get('/post/{post}', function () { // })->name('post.show'); To generate a URL to this route, you may use the route helper like so: echo route('post.show', ['post' => 1]); // http://example.com/post/1 You will often be generating URLs using the primary key of Eloquent models. For this reason, you may pass Eloquent models as parameter values. The route helper will automatically extract the model's primary key: echo route('post.show', ['post' => $post]); The route helper may also be used to generate URLs for routes with multiple parameters: Route::get('/post/{post}/comment/{comment}', function () { // })->name('comment.show'); echo route('comment.show', ['post' => 1, 'comment' => 3]); // http://example.com/post/1/comment/3 Signed URLs Laravel allows you to easily create \"signed\" URLs to named routes. These URLs have a \"signature\" hash appended to the query string which allows Laravel to verify that the URL has not been modified since it was created. Signed URLs are especially useful for routes that are publicly accessible yet need a layer of protection against URL manipulation. For example, you might use signed URLs to implement a public \"unsubscribe\" link that is emailed to your customers. To create a signed URL to a named route, use the signedRoute method of the URL facade: use Illuminate\\Support\\Facades\\URL; return URL::signedRoute('unsubscribe', ['user' => 1]); If you would like to generate a temporary signed route URL that expires, you may use the temporarySignedRoute method: use Illuminate\\Support\\Facades\\URL; return URL::temporarySignedRoute( 'unsubscribe', now()->addMinutes(30), ['user' => 1] ); Validating Signed Route Requests To verify that an incoming request has a valid signature, you should call the hasValidSignature method on the incoming Request: use Illuminate\\Http\\Request; Route::get('/unsubscribe/{user}', function (Request $request) { if (! $request->hasValidSignature()) { abort(401); } // ... })->name('unsubscribe'); Alternatively, you may assign the Illuminate\\Routing\\Middleware\\ValidateSignature middleware to the route. If it is not already present, you should assign this middleware a key in your HTTP kernel's routeMiddleware array: /* * The application's route middleware. * * These middleware may be assigned to groups or used individually. * * @var array / protected $routeMiddleware = [ 'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, ]; Once you have registered the middleware in your kernel, you may attach it to a route. If the incoming request does not have a valid signature, the middleware will automatically return a 403 error response: Route::post('/unsubscribe/{user}', function (Request $request) { // ... })->name('unsubscribe')->middleware('signed'); URLs For Controller Actions The action function generates a URL for the given controller action. You do not need to pass the full namespace of the controller. Instead, pass the controller class name relative to the App\\Http\\Controllers namespace: $url = action('HomeController@index'); You may also reference actions with a \"callable\" array syntax: use App\\Http\\Controllers\\HomeController; $url = action([HomeController::class, 'index']); If the controller method accepts route parameters, you may pass them as the second argument to the function: $url = action('UserController@profile', ['id' => 1]); Default Values For some applications, you may wish to specify request-wide default values for certain URL parameters. For example, imagine many of your routes define a {locale} parameter: Route::get('/{locale}/posts', function () { // })->name('post.index'); It is cumbersome to always pass the locale every time you call the route helper. So, you may use the URL::defaults method to define a default value for this parameter that will always be applied during the current request. You may wish to call this method from a route middleware so that you have access to the current request: namespace App\\Http\\Middleware; use Closure; use Illuminate\\Support\\Facades\\URL; class SetDefaultLocaleForUrls { public function handle($request, Closure $next) { URL::defaults(['locale' => $request->user()->locale]); return $next($request); } } Once the default value for the locale parameter has been set, you are no longer required to pass its value when generating URLs via the route helper. Session Introduction Since HTTP driven applications are stateless, sessions provide a way to store information about the user across multiple requests. Laravel ships with a variety of session backends that are accessed through an expressive, unified API. Support for popular backends such as Memcached, Redis, and databases is included out of the box. Configuration The session configuration file is stored at config/session.php. Be sure to review the options available to you in this file. By default, Laravel is configured to use the file session driver, which will work well for many applications. In production applications, you may consider using the memcached or redis drivers for even faster session performance. The session driver configuration option defines where session data will be stored for each request. Laravel ships with several great drivers out of the box: file - sessions are stored in storage/framework/sessions. cookie - sessions are stored in secure, encrypted cookies. database - sessions are stored in a relational database. memcached / redis - sessions are stored in one of these fast, cache based stores. array - sessions are stored in a PHP array and will not be persisted. The array driver is used during testing and prevents the data stored in the session from being persisted. Driver Prerequisites Database When using the database session driver, you will need to create a table to contain the session items. Below is an example Schema declaration for the table: Schema::create('sessions', function ($table) { $table->string('id')->unique(); $table->unsignedInteger('user_id')->nullable(); $table->string('ip_address', 45)->nullable(); $table->text('user_agent')->nullable(); $table->text('payload'); $table->integer('last_activity'); }); You may use the session:table Artisan command to generate this migration: php artisan session:table php artisan migrate Redis Before using Redis sessions with Laravel, you will need to install the predis/predis package (~1.0) via Composer. You may configure your Redis connections in the database configuration file. In the session configuration file, the connection option may be used to specify which Redis connection is used by the session. Using The Session Retrieving Data There are two primary ways of working with session data in Laravel: the global session helper and via a Request instance. First, let's look at accessing the session via a Request instance, which can be type-hinted on a controller method. Remember, controller method dependencies are automatically injected via the Laravel service container: namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /* * Show the profile for the given user. * * @param Request $request * @param int $id * @return Response / public function show(Request $request, $id) { $value = $request->session()->get('key'); // } } When you retrieve an item from the session, you may also pass a default value as the second argument to the get method. This default value will be returned if the specified key does not exist in the session. If you pass a Closure as the default value to the get method and the requested key does not exist, the Closure will be executed and its result returned: $value = $request->session()->get('key', 'default'); $value = $request->session()->get('key', function () { return 'default'; }); The Global Session Helper You may also use the global session PHP function to retrieve and store data in the session. When the session helper is called with a single, string argument, it will return the value of that session key. When the helper is called with an array of key / value pairs, those values will be stored in the session: Route::get('home', function () { // Retrieve a piece of data from the session... $value = session('key'); // Specifying a default value... $value = session('key', 'default'); // Store a piece of data in the session... session(['key' => 'value']); }); There is little practical difference between using the session via an HTTP request instance versus using the global session helper. Both methods are testable via the assertSessionHas method which is available in all of your test cases. Retrieving All Session Data If you would like to retrieve all the data in the session, you may use the all method: $data = $request->session()->all(); Determining If An Item Exists In The Session To determine if an item is present in the session, you may use the has method. The has method returns true if the item is present and is not null: if ($request->session()->has('users')) { // } To determine if an item is present in the session, even if its value is null, you may use the exists method. The exists method returns true if the item is present: if ($request->session()->exists('users')) { // } Storing Data To store data in the session, you will typically use the put method or the session helper: // Via a request instance... $request->session()->put('key', 'value'); // Via the global helper... session(['key' => 'value']); Pushing To Array Session Values The push method may be used to push a new value onto a session value that is an array. For example, if the user.teams key contains an array of team names, you may push a new value onto the array like so: $request->session()->push('user.teams', 'developers'); Retrieving & Deleting An Item The pull method will retrieve and delete an item from the session in a single statement: $value = $request->session()->pull('key', 'default'); Flash Data Sometimes you may wish to store items in the session only for the next request. You may do so using the flash method. Data stored in the session using this method will only be available during the subsequent HTTP request, and then will be deleted. Flash data is primarily useful for short-lived status messages: $request->session()->flash('status', 'Task was successful!'); If you need to keep your flash data around for several requests, you may use the reflash method, which will keep all of the flash data for an additional request. If you only need to keep specific flash data, you may use the keep method: $request->session()->reflash(); $request->session()->keep(['username', 'email']); Deleting Data The forget method will remove a piece of data from the session. If you would like to remove all data from the session, you may use the flush method: // Forget a single key... $request->session()->forget('key'); // Forget multiple keys... $request->session()->forget(['key1', 'key2']); $request->session()->flush(); Regenerating The Session ID Regenerating the session ID is often done in order to prevent malicious users from exploiting a session fixation attack on your application. Laravel automatically regenerates the session ID during authentication if you are using the built-in LoginController; however, if you need to manually regenerate the session ID, you may use the regenerate method. $request->session()->regenerate(); Adding Custom Session Drivers Implementing The Driver Your custom session driver should implement the SessionHandlerInterface. This interface contains just a few simple methods we need to implement. A stubbed MongoDB implementation looks something like this: namespace App\\Extensions; class MongoSessionHandler implements \\SessionHandlerInterface { public function open($savePath, $sessionName) {} public function close() {} public function read($sessionId) {} public function write($sessionId, $data) {} public function destroy($sessionId) {} public function gc($lifetime) {} } Laravel does not ship with a directory to contain your extensions. You are free to place them anywhere you like. In this example, we have created an Extensions directory to house the MongoSessionHandler. Since the purpose of these methods is not readily understandable, let's quickly cover what each of the methods do: The open method would typically be used in file based session store systems. Since Laravel ships with a file session driver, you will almost never need to put anything in this method. You can leave it as an empty stub. It is a fact of poor interface design (which we'll discuss later) that PHP requires us to implement this method. The close method, like the open method, can also usually be disregarded. For most drivers, it is not needed. The read method should return the string version of the session data associated with the given $sessionId. There is no need to do any serialization or other encoding when retrieving or storing session data in your driver, as Laravel will perform the serialization for you. The write method should write the given $data string associated with the $sessionId to some persistent storage system, such as MongoDB, Dynamo, etc. Again, you should not perform any serialization - Laravel will have already handled that for you. The destroy method should remove the data associated with the $sessionId from persistent storage. The gc method should destroy all session data that is older than the given $lifetime, which is a UNIX timestamp. For self-expiring systems like Memcached and Redis, this method may be left empty. Registering The Driver Once your driver has been implemented, you are ready to register it with the framework. To add additional drivers to Laravel's session backend, you may use the extend method on the Session facade. You should call the extend method from the boot method of a service provider. You may do this from the existing AppServiceProvider or create an entirely new provider: namespace App\\Providers; use App\\Extensions\\MongoSessionHandler; use Illuminate\\Support\\Facades\\Session; use Illuminate\\Support\\ServiceProvider; class SessionServiceProvider extends ServiceProvider { /* * Register bindings in the container. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { Session::extend('mongo', function ($app) { // Return implementation of SessionHandlerInterface... return new MongoSessionHandler; }); } } Once the session driver has been registered, you may use the mongo driver in your config/session.php configuration file. Validation Introduction Laravel provides several different approaches to validate your application's incoming data. By default, Laravel's base controller class uses a ValidatesRequests trait which provides a convenient method to validate incoming HTTP request with a variety of powerful validation rules. Validation Quickstart To learn about Laravel's powerful validation features, let's look at a complete example of validating a form and displaying the error messages back to the user. Defining The Routes First, let's assume we have the following routes defined in our routes/web.php file: Route::get('post/create', 'PostController@create'); Route::post('post', 'PostController@store'); The GET route will display a form for the user to create a new blog post, while the POST route will store the new blog post in the database. Creating The Controller Next, let's take a look at a simple controller that handles these routes. We'll leave the store method empty for now: namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PostController extends Controller { /* * Show the form to create a new blog post. * * @return Response / public function create() { return view('post.create'); } /** * Store a new blog post. * * @param Request $request * @return Response */ public function store(Request $request) { // Validate and store the blog post... } } Writing The Validation Logic Now we are ready to fill in our store method with the logic to validate the new blog post. To do this, we will use the validate method provided by the Illuminate\\Http\\Request object. If the validation rules pass, your code will keep executing normally; however, if validation fails, an exception will be thrown and the proper error response will automatically be sent back to the user. In the case of a traditional HTTP request, a redirect response will be generated, while a JSON response will be sent for AJAX requests. To get a better understanding of the validate method, let's jump back into the store method: /* * Store a new blog post. * * @param Request $request * @return Response / public function store(Request $request) { $validatedData = $request->validate([ 'title' => 'required|unique:posts|max:255', 'body' => 'required', ]); // The blog post is valid... } As you can see, we pass the desired validation rules into the validate method. Again, if the validation fails, the proper response will automatically be generated. If the validation passes, our controller will continue executing normally. Stopping On First Validation Failure Sometimes you may wish to stop running validation rules on an attribute after the first validation failure. To do so, assign the bail rule to the attribute: $request->validate([ 'title' => 'bail|required|unique:posts|max:255', 'body' => 'required', ]); In this example, if the unique rule on the title attribute fails, the max rule will not be checked. Rules will be validated in the order they are assigned. A Note On Nested Attributes If your HTTP request contains \"nested\" parameters, you may specify them in your validation rules using \"dot\" syntax: $request->validate([ 'title' => 'required|unique:posts|max:255', 'author.name' => 'required', 'author.description' => 'required', ]); Displaying The Validation Errors So, what if the incoming request parameters do not pass the given validation rules? As mentioned previously, Laravel will automatically redirect the user back to their previous location. In addition, all of the validation errors will automatically be flashed to the session. Again, notice that we did not have to explicitly bind the error messages to the view in our GET route. This is because Laravel will check for errors in the session data, and automatically bind them to the view if they are available. The $errors variable will be an instance of Illuminate\\Support\\MessageBag. For more information on working with this object, check out its documentation. The $errors variable is bound to the view by the Illuminate\\View\\Middleware\\ShareErrorsFromSession middleware, which is provided by the web middleware group. When this middleware is applied an $errors variable will always be available in your views, allowing you to conveniently assume the $errors variable is always defined and can be safely used. So, in our example, the user will be redirected to our controller's create method when validation fails, allowing us to display the error messages in the view: Create Post @if ($errors->any()) @foreach ($errors->all() as $error) {{ $error }} @endforeach @endif The @error Directive You may also use the @error Blade directive to quickly check if validation error messages exist for a given attribute. Within an @error directive, you may echo the $message variable to display the error message: Post Title @error('title') {{ $message }} @enderror A Note On Optional Fields By default, Laravel includes the TrimStrings and ConvertEmptyStringsToNull middleware in your application's global middleware stack. These middleware are listed in the stack by the App\\Http\\Kernel class. Because of this, you will often need to mark your \"optional\" request fields as nullable if you do not want the validator to consider null values as invalid. For example: $request->validate([ 'title' => 'required|unique:posts|max:255', 'body' => 'required', 'publish_at' => 'nullable|date', ]); In this example, we are specifying that the publish_at field may be either null or a valid date representation. If the nullable modifier is not added to the rule definition, the validator would consider null an invalid date. AJAX Requests & Validation In this example, we used a traditional form to send data to the application. However, many applications use AJAX requests. When using the validate method during an AJAX request, Laravel will not generate a redirect response. Instead, Laravel generates a JSON response containing all of the validation errors. This JSON response will be sent with a 422 HTTP status code. Form Request Validation Creating Form Requests For more complex validation scenarios, you may wish to create a \"form request\". Form requests are custom request classes that contain validation logic. To create a form request class, use the make:request Artisan CLI command: php artisan make:request StoreBlogPost The generated class will be placed in the app/Http/Requests directory. If this directory does not exist, it will be created when you run the make:request command. Let's add a few validation rules to the rules method: /* * Get the validation rules that apply to the request. * * @return array / public function rules() { return [ 'title' => 'required|unique:posts|max:255', 'body' => 'required', ]; } You may type-hint any dependencies you need within the rules method's signature. They will automatically be resolved via the Laravel service container. So, how are the validation rules evaluated? All you need to do is type-hint the request on your controller method. The incoming form request is validated before the controller method is called, meaning you do not need to clutter your controller with any validation logic: /* * Store the incoming blog post. * * @param StoreBlogPost $request * @return Response / public function store(StoreBlogPost $request) { // The incoming request is valid... // Retrieve the validated input data... $validated = $request->validated(); } If validation fails, a redirect response will be generated to send the user back to their previous location. The errors will also be flashed to the session so they are available for display. If the request was an AJAX request, a HTTP response with a 422 status code will be returned to the user including a JSON representation of the validation errors. Adding After Hooks To Form Requests If you would like to add an \"after\" hook to a form request, you may use the withValidator method. This method receives the fully constructed validator, allowing you to call any of its methods before the validation rules are actually evaluated: /* * Configure the validator instance. * * @param \\Illuminate\\Validation\\Validator $validator * @return void / public function withValidator($validator) { $validator->after(function ($validator) { if ($this->somethingElseIsInvalid()) { $validator->errors()->add('field', 'Something is wrong with this field!'); } }); } Authorizing Form Requests The form request class also contains an authorize method. Within this method, you may check if the authenticated user actually has the authority to update a given resource. For example, you may determine if a user actually owns a blog comment they are attempting to update: /* * Determine if the user is authorized to make this request. * * @return bool / public function authorize() { $comment = Comment::find($this->route('comment')); return $comment && $this->user()->can('update', $comment); } Since all form requests extend the base Laravel request class, we may use the user method to access the currently authenticated user. Also note the call to the route method in the example above. This method grants you access to the URI parameters defined on the route being called, such as the {comment} parameter in the example below: Route::post('comment/{comment}'); If the authorize method returns false, a HTTP response with a 403 status code will automatically be returned and your controller method will not execute. If you plan to have authorization logic in another part of your application, return true from the authorize method: /* * Determine if the user is authorized to make this request. * * @return bool / public function authorize() { return true; } You may type-hint any dependencies you need within the authorize method's signature. They will automatically be resolved via the Laravel service container. Customizing The Error Messages You may customize the error messages used by the form request by overriding the messages method. This method should return an array of attribute / rule pairs and their corresponding error messages: /* * Get the error messages for the defined validation rules. * * @return array / public function messages() { return [ 'title.required' => 'A title is required', 'body.required' => 'A message is required', ]; } Customizing The Validation Attributes If you would like the :attribute portion of your validation message to be replaced with a custom attribute name, you may specify the custom names by overriding the attributes method. This method should return an array of attribute / name pairs: /* * Get custom attributes for validator errors. * * @return array / public function attributes() { return [ 'email' => 'email address', ]; } Manually Creating Validators If you do not want to use the validate method on the request, you may create a validator instance manually using the Validator facade. The make method on the facade generates a new validator instance: namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; use Illuminate\\Support\\Facades\\Validator; class PostController extends Controller { /* * Store a new blog post. * * @param Request $request * @return Response / public function store(Request $request) { $validator = Validator::make($request->all(), [ 'title' => 'required|unique:posts|max:255', 'body' => 'required', ]); if ($validator->fails()) { return redirect('post/create') ->withErrors($validator) ->withInput(); } // Store the blog post... } } The first argument passed to the make method is the data under validation. The second argument is the validation rules that should be applied to the data. After checking if the request validation failed, you may use the withErrors method to flash the error messages to the session. When using this method, the $errors variable will automatically be shared with your views after redirection, allowing you to easily display them back to the user. The withErrors method accepts a validator, a MessageBag, or a PHP array. Automatic Redirection If you would like to create a validator instance manually but still take advantage of the automatic redirection offered by the requests's validate method, you may call the validate method on an existing validator instance. If validation fails, the user will automatically be redirected or, in the case of an AJAX request, a JSON response will be returned: Validator::make($request->all(), [ 'title' => 'required|unique:posts|max:255', 'body' => 'required', ])->validate(); Named Error Bags If you have multiple forms on a single page, you may wish to name the MessageBag of errors, allowing you to retrieve the error messages for a specific form. Pass a name as the second argument to withErrors: return redirect('register') ->withErrors($validator, 'login'); You may then access the named MessageBag instance from the $errors variable: {{ $errors->login->first('email') }} After Validation Hook The validator also allows you to attach callbacks to be run after validation is completed. This allows you to easily perform further validation and even add more error messages to the message collection. To get started, use the after method on a validator instance: $validator = Validator::make(...); $validator->after(function ($validator) { if ($this->somethingElseIsInvalid()) { $validator->errors()->add('field', 'Something is wrong with this field!'); } }); if ($validator->fails()) { // } Working With Error Messages After calling the errors method on a Validator instance, you will receive an Illuminate\\Support\\MessageBag instance, which has a variety of convenient methods for working with error messages. The $errors variable that is automatically made available to all views is also an instance of the MessageBag class. Retrieving The First Error Message For A Field To retrieve the first error message for a given field, use the first method: $errors = $validator->errors(); echo $errors->first('email'); Retrieving All Error Messages For A Field If you need to retrieve an array of all the messages for a given field, use the get method: foreach ($errors->get('email') as $message) { // } If you are validating an array form field, you may retrieve all of the messages for each of the array elements using the * character: foreach ($errors->get('attachments.*') as $message) { // } Retrieving All Error Messages For All Fields To retrieve an array of all messages for all fields, use the all method: foreach ($errors->all() as $message) { // } Determining If Messages Exist For A Field The has method may be used to determine if any error messages exist for a given field: if ($errors->has('email')) { // } Custom Error Messages If needed, you may use custom error messages for validation instead of the defaults. There are several ways to specify custom messages. First, you may pass the custom messages as the third argument to the Validator::make method: $messages = [ 'required' => 'The :attribute field is required.', ]; $validator = Validator::make($input, $rules, $messages); In this example, the :attribute placeholder will be replaced by the actual name of the field under validation. You may also utilize other placeholders in validation messages. For example: $messages = [ 'same' => 'The :attribute and :other must match.', 'size' => 'The :attribute must be exactly :size.', 'between' => 'The :attribute value :input is not between :min - :max.', 'in' => 'The :attribute must be one of the following types: :values', ]; Specifying A Custom Message For A Given Attribute Sometimes you may wish to specify a custom error message only for a specific field. You may do so using \"dot\" notation. Specify the attribute's name first, followed by the rule: $messages = [ 'email.required' => 'We need to know your e-mail address!', ]; Specifying Custom Messages In Language Files In most cases, you will probably specify your custom messages in a language file instead of passing them directly to the Validator. To do so, add your messages to custom array in the resources/lang/xx/validation.php language file. 'custom' => [ 'email' => [ 'required' => 'We need to know your e-mail address!', ], ], Specifying Custom Attributes In Language Files If you would like the :attribute portion of your validation message to be replaced with a custom attribute name, you may specify the custom name in the attributes array of your resources/lang/xx/validation.php language file: 'attributes' => [ 'email' => 'email address', ], Specifying Custom Values In Language Files Sometimes you may need the :value portion of your validation message to be replaced with a custom representation of the value. For example, consider the following rule that specifies that a credit card number is required if the payment_type has a value of cc: $request->validate([ 'credit_card_number' => 'required_if:payment_type,cc' ]); If this validation rule fails, it will produce the following error message: The credit card number field is required when payment type is cc. Instead of displaying cc as the payment type value, you may specify a custom value representation in your validation language file by defining a values array: 'values' => [ 'payment_type' => [ 'cc' => 'credit card' ], ], Now if the validation rule fails it will produce the following message: The credit card number field is required when payment type is credit card. Available Validation Rules Below is a list of all available validation rules and their function: Accepted Active URL After (Date) After Or Equal (Date) Alpha Alpha Dash Alpha Numeric Array Bail Before (Date) Before Or Equal (Date) Between Boolean Confirmed Date Date Equals Date Format Different Digits Digits Between Dimensions (Image Files) Distinct E-Mail Ends With Exists (Database) File Filled Greater Than Greater Than Or Equal Image (File) In In Array Integer IP Address JSON Less Than Less Than Or Equal Max MIME Types MIME Type By File Extension Min Not In Not Regex Nullable Numeric Present Regular Expression Required Required If Required Unless Required With Required With All Required Without Required Without All Same Size Sometimes Starts With String Timezone Unique (Database) URL UUID accepted The field under validation must be yes, on, 1, or true. This is useful for validating \"Terms of Service\" acceptance. active_url The field under validation must have a valid A or AAAA record according to the dns_get_record PHP function. after:date The field under validation must be a value after a given date. The dates will be passed into the strtotime PHP function: 'start_date' => 'required|date|after:tomorrow' Instead of passing a date string to be evaluated by strtotime, you may specify another field to compare against the date: 'finish_date' => 'required|date|after:start_date' after_or_equal:date The field under validation must be a value after or equal to the given date. For more information, see the after rule. alpha The field under validation must be entirely alphabetic characters. alpha_dash The field under validation may have alpha-numeric characters, as well as dashes and underscores. alpha_num The field under validation must be entirely alpha-numeric characters. array The field under validation must be a PHP array. bail Stop running validation rules after the first validation failure. before:date The field under validation must be a value preceding the given date. The dates will be passed into the PHP strtotime function. In addition, like the after rule, the name of another field under validation may be supplied as the value of date. before_or_equal:date The field under validation must be a value preceding or equal to the given date. The dates will be passed into the PHP strtotime function. In addition, like the after rule, the name of another field under validation may be supplied as the value of date. between:min,max The field under validation must have a size between the given min and max. Strings, numerics, arrays, and files are evaluated in the same fashion as the size rule. boolean The field under validation must be able to be cast as a boolean. Accepted input are true, false, 1, 0, \"1\", and \"0\". confirmed The field under validation must have a matching field of foo_confirmation. For example, if the field under validation is password, a matching password_confirmation field must be present in the input. date The field under validation must be a valid, non-relative date according to the strtotime PHP function. date_equals:date The field under validation must be equal to the given date. The dates will be passed into the PHP strtotime function. date_format:format The field under validation must match the given format. You should use either date or date_format when validating a field, not both. different:field The field under validation must have a different value than field. digits:value The field under validation must be numeric and must have an exact length of value. digits_between:min,max The field under validation must have a length between the given min and max. dimensions The file under validation must be an image meeting the dimension constraints as specified by the rule's parameters: 'avatar' => 'dimensions:min_width=100,min_height=200' Available constraints are: min_width, max_width, min_height, max_height, width, height, ratio. A ratio constraint should be represented as width divided by height. This can be specified either by a statement like 3/2 or a float like 1.5: 'avatar' => 'dimensions:ratio=3/2' Since this rule requires several arguments, you may use the Rule::dimensions method to fluently construct the rule: use Illuminate\\Validation\\Rule; Validator::make($data, [ 'avatar' => [ 'required', Rule::dimensions()->maxWidth(1000)->maxHeight(500)->ratio(3 / 2), ], ]); distinct When working with arrays, the field under validation must not have any duplicate values. 'foo.*.id' => 'distinct' email The field under validation must be formatted as an e-mail address. ends_with:foo,bar,... The field under validation must end with one of the given values. exists:table,column The field under validation must exist on a given database table. Basic Usage Of Exists Rule 'state' => 'exists:states' If the column option is not specified, the field name will be used. Specifying A Custom Column Name 'state' => 'exists:states,abbreviation' Occasionally, you may need to specify a specific database connection to be used for the exists query. You can accomplish this by prepending the connection name to the table name using \"dot\" syntax: 'email' => 'exists:connection.staff,email' If you would like to customize the query executed by the validation rule, you may use the Rule class to fluently define the rule. In this example, we'll also specify the validation rules as an array instead of using the | character to delimit them: use Illuminate\\Validation\\Rule; Validator::make($data, [ 'email' => [ 'required', Rule::exists('staff')->where(function ($query) { $query->where('account_id', 1); }), ], ]); file The field under validation must be a successfully uploaded file. filled The field under validation must not be empty when it is present. gt:field The field under validation must be greater than the given field. The two fields must be of the same type. Strings, numerics, arrays, and files are evaluated using the same conventions as the size rule. gte:field The field under validation must be greater than or equal to the given field. The two fields must be of the same type. Strings, numerics, arrays, and files are evaluated using the same conventions as the size rule. image The file under validation must be an image (jpeg, png, bmp, gif, or svg) in:foo,bar,... The field under validation must be included in the given list of values. Since this rule often requires you to implode an array, the Rule::in method may be used to fluently construct the rule: use Illuminate\\Validation\\Rule; Validator::make($data, [ 'zones' => [ 'required', Rule::in(['first-zone', 'second-zone']), ], ]); in_array:anotherfield.* The field under validation must exist in anotherfield's values. integer The field under validation must be an integer. ip The field under validation must be an IP address. ipv4 The field under validation must be an IPv4 address. ipv6 The field under validation must be an IPv6 address. json The field under validation must be a valid JSON string. lt:field The field under validation must be less than the given field. The two fields must be of the same type. Strings, numerics, arrays, and files are evaluated using the same conventions as the size rule. lte:field The field under validation must be less than or equal to the given field. The two fields must be of the same type. Strings, numerics, arrays, and files are evaluated using the same conventions as the size rule. max:value The field under validation must be less than or equal to a maximum value. Strings, numerics, arrays, and files are evaluated in the same fashion as the size rule. mimetypes:text/plain,... The file under validation must match one of the given MIME types: 'video' => 'mimetypes:video/avi,video/mpeg,video/quicktime' To determine the MIME type of the uploaded file, the file's contents will be read and the framework will attempt to guess the MIME type, which may be different from the client provided MIME type. mimes:foo,bar,... The file under validation must have a MIME type corresponding to one of the listed extensions. Basic Usage Of MIME Rule 'photo' => 'mimes:jpeg,bmp,png' Even though you only need to specify the extensions, this rule actually validates against the MIME type of the file by reading the file's contents and guessing its MIME type. A full listing of MIME types and their corresponding extensions may be found at the following location: https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types min:value The field under validation must have a minimum value. Strings, numerics, arrays, and files are evaluated in the same fashion as the size rule. not_in:foo,bar,... The field under validation must not be included in the given list of values. The Rule::notIn method may be used to fluently construct the rule: use Illuminate\\Validation\\Rule; Validator::make($data, [ 'toppings' => [ 'required', Rule::notIn(['sprinkles', 'cherries']), ], ]); not_regex:pattern The field under validation must not match the given regular expression. Internally, this rule uses the PHP preg_match function. The pattern specified should obey the same formatting required by preg_match and thus also include valid delimiters. For example: 'email' => 'not_regex:/^.+$/i'. Note: When using the regex / not_regex patterns, it may be necessary to specify rules in an array instead of using pipe delimiters, especially if the regular expression contains a pipe character. nullable The field under validation may be null. This is particularly useful when validating primitive such as strings and integers that can contain null values. numeric The field under validation must be numeric. present The field under validation must be present in the input data but can be empty. regex:pattern The field under validation must match the given regular expression. Internally, this rule uses the PHP preg_match function. The pattern specified should obey the same formatting required by preg_match and thus also include valid delimiters. For example: 'email' => 'regex:/^.+@.+$/i'. Note: When using the regex / not_regex patterns, it may be necessary to specify rules in an array instead of using pipe delimiters, especially if the regular expression contains a pipe character. required The field under validation must be present in the input data and not empty. A field is considered \"empty\" if one of the following conditions are true: The value is null. The value is an empty string. The value is an empty array or empty Countable object. The value is an uploaded file with no path. required_if:anotherfield,value,... The field under validation must be present and not empty if the anotherfield field is equal to any value. If you would like to construct a more complex condition for the required_if rule, you may use the Rule::requiredIf method. This methods accepts a boolean or a Closure. When passed a Closure, the Closure should return true or false to indicate if the field under validation is required: use Illuminate\\Validation\\Rule; Validator::make($request->all(), [ 'role_id' => Rule::requiredIf($request->user()->is_admin), ]); Validator::make($request->all(), [ 'role_id' => Rule::requiredIf(function () use ($request) { return $request->user()->is_admin; }), ]); required_unless:anotherfield,value,... The field under validation must be present and not empty unless the anotherfield field is equal to any value. required_with:foo,bar,... The field under validation must be present and not empty only if any of the other specified fields are present. required_with_all:foo,bar,... The field under validation must be present and not empty only if all of the other specified fields are present. required_without:foo,bar,... The field under validation must be present and not empty only when any of the other specified fields are not present. required_without_all:foo,bar,... The field under validation must be present and not empty only when all of the other specified fields are not present. same:field The given field must match the field under validation. size:value The field under validation must have a size matching the given value. For string data, value corresponds to the number of characters. For numeric data, value corresponds to a given integer value. For an array, size corresponds to the count of the array. For files, size corresponds to the file size in kilobytes. starts_with:foo,bar,... The field under validation must start with one of the given values. string The field under validation must be a string. If you would like to allow the field to also be null, you should assign the nullable rule to the field. timezone The field under validation must be a valid timezone identifier according to the timezone_identifiers_list PHP function. unique:table,column,except,idColumn The field under validation must not exist within the given database table. Specifying A Custom Column Name: The column option may be used to specify the field's corresponding database column. If the column option is not specified, the field name will be used. 'email' => 'unique:users,email_address' Custom Database Connection Occasionally, you may need to set a custom connection for database queries made by the Validator. As seen above, setting unique:users as a validation rule will use the default database connection to query the database. To override this, specify the connection and the table name using \"dot\" syntax: 'email' => 'unique:connection.users,email_address' Forcing A Unique Rule To Ignore A Given ID: Sometimes, you may wish to ignore a given ID during the unique check. For example, consider an \"update profile\" screen that includes the user's name, e-mail address, and location. You will probably want to verify that the e-mail address is unique. However, if the user only changes the name field and not the e-mail field, you do not want a validation error to be thrown because the user is already the owner of the e-mail address. To instruct the validator to ignore the user's ID, we'll use the Rule class to fluently define the rule. In this example, we'll also specify the validation rules as an array instead of using the | character to delimit the rules: use Illuminate\\Validation\\Rule; Validator::make($data, [ 'email' => [ 'required', Rule::unique('users')->ignore($user->id), ], ]); You should never pass any user controlled request input into the ignore method. Instead, you should only pass a system generated unique ID such as an auto-incrementing ID or UUID from an Eloquent model instance. Otherwise, your application will be vulnerable to an SQL injection attack. Instead of passing the model key's value to the ignore method, you may pass the entire model instance. Laravel will automatically extract the key from the model: Rule::unique('users')->ignore($user) If your table uses a primary key column name other than id, you may specify the name of the column when calling the ignore method: Rule::unique('users')->ignore($user->id, 'user_id') By default, the unique rule will check the uniqueness of the column matching the name of the attribute being validated. However, you may pass a different column name as the second argument to the unique method: Rule::unique('users', 'email_address')->ignore($user->id), Adding Additional Where Clauses: You may also specify additional query constraints by customizing the query using the where method. For example, let's add a constraint that verifies the account_id is 1: 'email' => Rule::unique('users')->where(function ($query) { return $query->where('account_id', 1); }) url The field under validation must be a valid URL. uuid The field under validation must be a valid RFC 4122 (version 1, 3, 4, or 5) universally unique identifier (UUID). Conditionally Adding Rules Validating When Present In some situations, you may wish to run validation checks against a field only if that field is present in the input array. To quickly accomplish this, add the sometimes rule to your rule list: $v = Validator::make($data, [ 'email' => 'sometimes|required|email', ]); In the example above, the email field will only be validated if it is present in the $data array. If you are attempting to validate a field that should always be present but may be empty, check out this note on optional fields Complex Conditional Validation Sometimes you may wish to add validation rules based on more complex conditional logic. For example, you may wish to require a given field only if another field has a greater value than 100. Or, you may need two fields to have a given value only when another field is present. Adding these validation rules doesn't have to be a pain. First, create a Validator instance with your static rules that never change: $v = Validator::make($data, [ 'email' => 'required|email', 'games' => 'required|numeric', ]); Let's assume our web application is for game collectors. If a game collector registers with our application and they own more than 100 games, we want them to explain why they own so many games. For example, perhaps they run a game resale shop, or maybe they just enjoy collecting. To conditionally add this requirement, we can use the sometimes method on the Validator instance. $v->sometimes('reason', 'required|max:500', function ($input) { return $input->games >= 100; }); The first argument passed to the sometimes method is the name of the field we are conditionally validating. The second argument is the rules we want to add. If the Closure passed as the third argument returns true, the rules will be added. This method makes it a breeze to build complex conditional validations. You may even add conditional validations for several fields at once: $v->sometimes(['reason', 'cost'], 'required', function ($input) { return $input->games >= 100; }); The $input parameter passed to your Closure will be an instance of Illuminate\\Support\\Fluent and may be used to access your input and files. Validating Arrays Validating array based form input fields doesn't have to be a pain. You may use \"dot notation\" to validate attributes within an array. For example, if the incoming HTTP request contains a photos[profile] field, you may validate it like so: $validator = Validator::make($request->all(), [ 'photos.profile' => 'required|image', ]); You may also validate each element of an array. For example, to validate that each e-mail in a given array input field is unique, you may do the following: $validator = Validator::make($request->all(), [ 'person. .email' => 'email|unique:users', 'person. .first_name' => 'required_with:person.*.last_name', ]); Likewise, you may use the * character when specifying your validation messages in your language files, making it a breeze to use a single validation message for array based fields: 'custom' => [ 'person.*.email' => [ 'unique' => 'Each person must have a unique e-mail address', ] ], Custom Validation Rules Using Rule Objects Laravel provides a variety of helpful validation rules; however, you may wish to specify some of your own. One method of registering custom validation rules is using rule objects. To generate a new rule object, you may use the make:rule Artisan command. Let's use this command to generate a rule that verifies a string is uppercase. Laravel will place the new rule in the app/Rules directory: php artisan make:rule Uppercase Once the rule has been created, we are ready to define its behavior. A rule object contains two methods: passes and message. The passes method receives the attribute value and name, and should return true or false depending on whether the attribute value is valid or not. The message method should return the validation error message that should be used when validation fails: namespace App\\Rules; use Illuminate\\Contracts\\Validation\\Rule; class Uppercase implements Rule { /* * Determine if the validation rule passes. * * @param string $attribute * @param mixed $value * @return bool / public function passes($attribute, $value) { return strtoupper($value) === $value; } /** * Get the validation error message. * * @return string */ public function message() { return 'The :attribute must be uppercase.'; } } You may call the trans helper from your message method if you would like to return an error message from your translation files: /* * Get the validation error message. * * @return string / public function message() { return trans('validation.uppercase'); } Once the rule has been defined, you may attach it to a validator by passing an instance of the rule object with your other validation rules: use App\\Rules\\Uppercase; $request->validate([ 'name' => ['required', 'string', new Uppercase], ]); Using Closures If you only need the functionality of a custom rule once throughout your application, you may use a Closure instead of a rule object. The Closure receives the attribute's name, the attribute's value, and a $fail callback that should be called if validation fails: $validator = Validator::make($request->all(), [ 'title' => [ 'required', 'max:255', function ($attribute, $value, $fail) { if ($value === 'foo') { $fail($attribute.' is invalid.'); } }, ], ]); Using Extensions Another method of registering custom validation rules is using the extend method on the Validator facade. Let's use this method within a service provider to register a custom validation rule: namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Support\\Facades\\Validator; class AppServiceProvider extends ServiceProvider { /* * Register any application services. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { Validator::extend('foo', function ($attribute, $value, $parameters, $validator) { return $value == 'foo'; }); } } The custom validator Closure receives four arguments: the name of the $attribute being validated, the $value of the attribute, an array of $parameters passed to the rule, and the Validator instance. You may also pass a class and method to the extend method instead of a Closure: Validator::extend('foo', 'FooValidator@validate'); Defining The Error Message You will also need to define an error message for your custom rule. You can do so either using an inline custom message array or by adding an entry in the validation language file. This message should be placed in the first level of the array, not within the custom array, which is only for attribute-specific error messages: \"foo\" => \"Your input was invalid!\", \"accepted\" => \"The :attribute must be accepted.\", // The rest of the validation error messages... When creating a custom validation rule, you may sometimes need to define custom placeholder replacements for error messages. You may do so by creating a custom Validator as described above then making a call to the replacer method on the Validator facade. You may do this within the boot method of a service provider: /* * Bootstrap any application services. * * @return void / public function boot() { Validator::extend(...); Validator::replacer('foo', function ($message, $attribute, $rule, $parameters) { return str_replace(...); }); } Implicit Extensions By default, when an attribute being validated is not present or contains an empty string, normal validation rules, including custom extensions, are not run. For example, the unique rule will not be run against an empty string: $rules = ['name' => 'unique:users,name']; $input = ['name' => '']; Validator::make($input, $rules)->passes(); // true For a rule to run even when an attribute is empty, the rule must imply that the attribute is required. To create such an \"implicit\" extension, use the Validator::extendImplicit() method: Validator::extendImplicit('foo', function ($attribute, $value, $parameters, $validator) { return $value == 'foo'; }); An \"implicit\" extension only implies that the attribute is required. Whether it actually invalidates a missing or empty attribute is up to you. Implicit Rule Objects If you would like a rule object to run when an attribute is empty, you should implement the Illuminate\\Contracts\\Validation\\ImplicitRule interface. This interface serves as a \"marker interface\" for the validator; therefore, it does not contain any methods you need to implement. Error Handling Introduction When you start a new Laravel project, error and exception handling is already configured for you. The App\\Exceptions\\Handler class is where all exceptions triggered by your application are logged and then rendered back to the user. We'll dive deeper into this class throughout this documentation. Configuration The debug option in your config/app.php configuration file determines how much information about an error is actually displayed to the user. By default, this option is set to respect the value of the APP_DEBUG environment variable, which is stored in your .env file. For local development, you should set the APP_DEBUG environment variable to true. In your production environment, this value should always be false. If the value is set to true in production, you risk exposing sensitive configuration values to your application's end users. The Exception Handler The Report Method All exceptions are handled by the App\\Exceptions\\Handler class. This class contains two methods: report and render. We'll examine each of these methods in detail. The report method is used to log exceptions or send them to an external service like Bugsnag or Sentry. By default, the report method passes the exception to the base class where the exception is logged. However, you are free to log exceptions however you wish. For example, if you need to report different types of exceptions in different ways, you may use the PHP instanceof comparison operator: /* * Report or log an exception. * * This is a great spot to send exceptions to Sentry, Bugsnag, etc. * * @param \\Exception $exception * @return void / public function report(Exception $exception) { if ($exception instanceof CustomException) { // } parent::report($exception); } Instead of making a lot of instanceof checks in your report method, consider using reportable exceptions Global Log Context If available, Laravel automatically adds the current user's ID to every exception's log message as contextual data. You may define your own global contextual data by overriding the context method of your application's App\\Exceptions\\Handler class. This information will be included in every exception's log message written by your application: /* * Get the default context variables for logging. * * @return array / protected function context() { return array_merge(parent::context(), [ 'foo' => 'bar', ]); } The report Helper Sometimes you may need to report an exception but continue handling the current request. The report helper function allows you to quickly report an exception using your exception handler's report method without rendering an error page: public function isValid($value) { try { // Validate the value... } catch (Exception $e) { report($e); return false; } } Ignoring Exceptions By Type The $dontReport property of the exception handler contains an array of exception types that will not be logged. For example, exceptions resulting from 404 errors, as well as several other types of errors, are not written to your log files. You may add other exception types to this array as needed: /* * A list of the exception types that should not be reported. * * @var array / protected $dontReport = [ \\Illuminate\\Auth\\AuthenticationException::class, \\Illuminate\\Auth\\Access\\AuthorizationException::class, \\Symfony\\Component\\HttpKernel\\Exception\\HttpException::class, \\Illuminate\\Database\\Eloquent\\ModelNotFoundException::class, \\Illuminate\\Validation\\ValidationException::class, ]; The Render Method The render method is responsible for converting a given exception into an HTTP response that should be sent back to the browser. By default, the exception is passed to the base class which generates a response for you. However, you are free to check the exception type or return your own custom response: /* * Render an exception into an HTTP response. * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $exception * @return \\Illuminate\\Http\\Response / public function render($request, Exception $exception) { if ($exception instanceof CustomException) { return response()->view('errors.custom', [], 500); } return parent::render($request, $exception); } Reportable & Renderable Exceptions Instead of type-checking exceptions in the exception handler's report and render methods, you may define report and render methods directly on your custom exception. When these methods exist, they will be called automatically by the framework: namespace App\\Exceptions; use Exception; class RenderException extends Exception { /* * Report the exception. * * @return void / public function report() { // } /** * Render the exception into an HTTP response. * * @param \\Illuminate\\Http\\Request * @return \\Illuminate\\Http\\Response */ public function render($request) { return response(...); } } You may type-hint any required dependencies of the report method and they will automatically be injected into the method by Laravel's service container. HTTP Exceptions Some exceptions describe HTTP error codes from the server. For example, this may be a \"page not found\" error (404), an \"unauthorized error\" (401) or even a developer generated 500 error. In order to generate such a response from anywhere in your application, you may use the abort helper: abort(404); The abort helper will immediately raise an exception which will be rendered by the exception handler. Optionally, you may provide the response text: abort(403, 'Unauthorized action.'); Custom HTTP Error Pages Laravel makes it easy to display custom error pages for various HTTP status codes. For example, if you wish to customize the error page for 404 HTTP status codes, create a resources/views/errors/404.blade.php. This file will be served on all 404 errors generated by your application. The views within this directory should be named to match the HTTP status code they correspond to. The HttpException instance raised by the abort function will be passed to the view as an $exception variable: {{ $exception->getMessage() }} You may publish Laravel's error page templates using the vendor:publish Artisan command. Once the templates have been published, you may customize them to your liking: php artisan vendor:publish --tag=laravel-errors Logging Introduction To help you learn more about what's happening within your application, Laravel provides robust logging services that allow you to log messages to files, the system error log, and even to Slack to notify your entire team. Under the hood, Laravel utilizes the Monolog library, which provides support for a variety of powerful log handlers. Laravel makes it a cinch to configure these handlers, allowing you to mix and match them to customize your application's log handling. Configuration All of the configuration for your application's logging system is housed in the config/logging.php configuration file. This file allows you to configure your application's log channels, so be sure to review each of the available channels and their options. We'll review a few common options below. By default, Laravel will use the stack channel when logging messages. The stack channel is used to aggregate multiple log channels into a single channel. For more information on building stacks, check out the documentation below. Configuring The Channel Name By default, Monolog is instantiated with a \"channel name\" that matches the current environment, such as production or local. To change this value, add a name option to your channel's configuration: 'stack' => [ 'driver' => 'stack', 'name' => 'channel-name', 'channels' => ['single', 'slack'], ], Available Channel Drivers Name Description stack A wrapper to facilitate creating \"multi-channel\" channels single A single file or path based logger channel (StreamHandler) daily A RotatingFileHandler based Monolog driver which rotates daily slack A SlackWebhookHandler based Monolog driver papertrail A SyslogUdpHandler based Monolog driver syslog A SyslogHandler based Monolog driver errorlog A ErrorLogHandler based Monolog driver monolog A Monolog factory driver that may use any supported Monolog handler custom A driver that calls a specified factory to create a channel Check out the documentation on advanced channel customization to learn more about the monolog and custom drivers. Configuring The Single and Daily Channels The single and daily channels have three optional configuration options: bubble, permission, and locking. Name Description Default bubble Indicates if messages should bubble up to other channels after being handled true permission The log file's permissions 0644 locking Attempt to lock the log file before writing to it false Configuring The Papertrail Channel The papertrail channel requires the url and port configuration options. You can obtain these values from Papertrail. Configuring The Slack Channel The slack channel requires a url configuration option. This URL should match a URL for an incoming webhook that you have configured for your Slack team. Building Log Stacks As previously mentioned, the stack driver allows you to combine multiple channels into a single log channel. To illustrate how to use log stacks, let's take a look at an example configuration that you might see in a production application: 'channels' => [ 'stack' => [ 'driver' => 'stack', 'channels' => ['syslog', 'slack'], ], 'syslog' => [ 'driver' => 'syslog', 'level' => 'debug', ], 'slack' => [ 'driver' => 'slack', 'url' => env('LOG_SLACK_WEBHOOK_URL'), 'username' => 'Laravel Log', 'emoji' => ':boom:', 'level' => 'critical', ], ], Let's dissect this configuration. First, notice our stack channel aggregates two other channels via its channels option: syslog and slack. So, when logging messages, both of these channels will have the opportunity to log the message. Log Levels Take note of the level configuration option present on the syslog and slack channel configurations in the example above. This option determines the minimum \"level\" a message must be in order to be logged by the channel. Monolog, which powers Laravel's logging services, offers all of the log levels defined in the RFC 5424 specification: emergency, alert, critical, error, warning, notice, info, and debug. So, imagine we log a message using the debug method: Log::debug('An informational message.'); Given our configuration, the syslog channel will write the message to the system log; however, since the error message is not critical or above, it will not be sent to Slack. However, if we log an emergency message, it will be sent to both the system log and Slack since the emergency level is above our minimum level threshold for both channels: Log::emergency('The system is down!'); Writing Log Messages You may write information to the logs using the Log facade. As previously mentioned, the logger provides the eight logging levels defined in the RFC 5424 specification: emergency, alert, critical, error, warning, notice, info and debug: Log::emergency($message); Log::alert($message); Log::critical($message); Log::error($message); Log::warning($message); Log::notice($message); Log::info($message); Log::debug($message); So, you may call any of these methods to log a message for the corresponding level. By default, the message will be written to the default log channel as configured by your config/logging.php configuration file: namespace App\\Http\\Controllers; use App\\User; use Illuminate\\Support\\Facades\\Log; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /* * Show the profile for the given user. * * @param int $id * @return Response / public function showProfile($id) { Log::info('Showing user profile for user: '.$id); return view('user.profile', ['user' => User::findOrFail($id)]); } } Contextual Information An array of contextual data may also be passed to the log methods. This contextual data will be formatted and displayed with the log message: Log::info('User failed to login.', ['id' => $user->id]); Writing To Specific Channels Sometimes you may wish to log a message to a channel other than your application's default channel. You may use the channel method on the Log facade to retrieve and log to any channel defined in your configuration file: Log::channel('slack')->info('Something happened!'); If you would like to create an on-demand logging stack consisting of multiple channels, you may use the stack method: Log::stack(['single', 'slack'])->info('Something happened!'); Advanced Monolog Channel Customization Customizing Monolog For Channels Sometimes you may need complete control over how Monolog is configured for an existing channel. For example, you may want to configure a custom Monolog FormatterInterface implementation for a given channel's handlers. To get started, define a tap array on the channel's configuration. The tap array should contain a list of classes that should have an opportunity to customize (or \"tap\" into) the Monolog instance after it is created: 'single' => [ 'driver' => 'single', 'tap' => [App\\Logging\\CustomizeFormatter::class], 'path' => storage_path('logs/laravel.log'), 'level' => 'debug', ], Once you have configured the tap option on your channel, you're ready to define the class that will customize your Monolog instance. This class only needs a single method: __invoke, which receives an Illuminate\\Log\\Logger instance. The Illuminate\\Log\\Logger instance proxies all method calls to the underlying Monolog instance: namespace App\\Logging; class CustomizeFormatter { /* * Customize the given logger instance. * * @param \\Illuminate\\Log\\Logger $logger * @return void / public function __invoke($logger) { foreach ($logger->getHandlers() as $handler) { $handler->setFormatter(...); } } } All of your \"tap\" classes are resolved by the service container, so any constructor dependencies they require will automatically be injected. Creating Monolog Handler Channels Monolog has a variety of available handlers. In some cases, the type of logger you wish to create is merely a Monolog driver with an instance of a specific handler. These channels can be created using the monolog driver. When using the monolog driver, the handler configuration option is used to specify which handler will be instantiated. Optionally, any constructor parameters the handler needs may be specified using the with configuration option: 'logentries' => [ 'driver' => 'monolog', 'handler' => Monolog\\Handler\\SyslogUdpHandler::class, 'with' => [ 'host' => 'my.logentries.internal.datahubhost.company.com', 'port' => '10000', ], ], Monolog Formatters When using the monolog driver, the Monolog LineFormatter will be used as the default formatter. However, you may customize the type of formatter passed to the handler using the formatter and formatter_with configuration options: 'browser' => [ 'driver' => 'monolog', 'handler' => Monolog\\Handler\\BrowserConsoleHandler::class, 'formatter' => Monolog\\Formatter\\HtmlFormatter::class, 'formatter_with' => [ 'dateFormat' => 'Y-m-d', ], ], If you are using a Monolog handler that is capable of providing its own formatter, you may set the value of the formatter configuration option to default: 'newrelic' => [ 'driver' => 'monolog', 'handler' => Monolog\\Handler\\NewRelicHandler::class, 'formatter' => 'default', ], Creating Channels Via Factories If you would like to define an entirely custom channel in which you have full control over Monolog's instantiation and configuration, you may specify a custom driver type in your config/logging.php configuration file. Your configuration should include a via option to point to the factory class which will be invoked to create the Monolog instance: 'channels' => [ 'custom' => [ 'driver' => 'custom', 'via' => App\\Logging\\CreateCustomLogger::class, ], ], Once you have configured the custom channel, you're ready to define the class that will create your Monolog instance. This class only needs a single method: __invoke, which should return the Monolog instance: namespace App\\Logging; use Monolog\\Logger; class CreateCustomLogger { /* * Create a custom Monolog instance. * * @param array $config * @return \\Monolog\\Logger / public function __invoke(array $config) { return new Logger(...); } }","title":"Laravel Routing"},{"location":"developerdoc/laravel_routing/#laravel-routing","text":"","title":"Laravel Routing"},{"location":"developerdoc/laravel_routing/#basic-routing","text":"Route paling dasar di Laravel adalah menerima URI dan sebuah closure, contoh: Route::get('foo', function () { return 'Hello World'; });","title":"Basic Routing"},{"location":"developerdoc/laravel_routing/#file-default-route","text":"Semua route Laravel didefinisikan dalam file-file route, yang terletak di folder routes . File-file ini dimuat secara otomatis oleh framework. File routes/web.php berisi definisi route untuk web interface. Route ini diset untuk menggunakan web middleware group , yang menyediakan fungsi seperti session state dan CSRF protection . Route di dalam routes/api.php bersifat stateless dan menggunakan api middleware group . Kebanyakan aplikasi, dimulai dengan mendefinisikan route di dalam routes/web.php . Route yang didefinisikan di dalam routes/web.php dapat diakses dengan browser pada URLroute tersebut. contoh, Anda dapat mengakses route berikut dengan mengarahkan browser Anda ke http://your-app.test/user : Route::get('/user', 'UserController@index'); Route yang didefinisikan di dalam routes/api.php akan ditambah prefix URI /api . Prefix dapat diedit dalam class RouteServiceProvider .","title":"File Default Route"},{"location":"developerdoc/laravel_routing/#available-router-methods","text":"Router mengijinkan Anda untuk mendaftarkan route Anda yang merespon HTTP verb berikut ini, Route::get($uri, $callback); Route::post($uri, $callback); Route::put($uri, $callback); Route::patch($uri, $callback); Route::delete($uri, $callback); Route::options($uri, $callback); Jika Anda ingin mendefinisikan satu route untuk beberapa HTTP verb, gunakan seperti contoh di bawah ini, Route::match(['get', 'post'], '/', function () { // }); Route::any('/', function () { // });","title":"Available Router Methods"},{"location":"developerdoc/laravel_routing/#csrf-protection","text":"Setiap form HTML yang mengirimkan request ke route dengan HTTP verb POST, PUT, or DELETE yang diedfinisikan dalam file routes/web.php harus menyertakan CSRF token dalam request-nya. Kalau tidak menyertakan, request akan ditolak. <form method=\"POST\" action=\"/profile\"> @csrf ... </form>","title":"CSRF Protection"},{"location":"developerdoc/laravel_routing/#redirect-routes","text":"Jika Anda mendefinisikan route yang mengalihkan request ke URI lain, Anda dapat menggunakan Route::redirect . Cara ini menyediakan pintasan yang memudahkan Anda agar tidak perlu mendefinisikan secara lengkap route atau controller untuk redirect yang sederhana: Route::redirect('/here', '/there'); Secara default, Route::redirect mengembalikan kode status 302. Anda dapat mengubahn kode status dengan parameter ketiga (optional): Route::redirect('/here', '/there', 301); Anda dapat menggunakan Route::permanentRedirect untuk mengembalikan kode status 301: Route::permanentRedirect('/here', '/there');","title":"Redirect Routes"},{"location":"developerdoc/laravel_routing/#view-routes","text":"Jika Anda menggunakan route yang hanya mengembalikan view , Anda dapat menggunakan Route::view . Contoh: Route::view('/welcome', 'welcome'); Route::view('/welcome', 'welcome', ['name' => 'Taylor']);","title":"View Routes"},{"location":"developerdoc/laravel_routing/#route-parameters","text":"","title":"Route Parameters"},{"location":"developerdoc/laravel_routing/#required-parameters","text":"Kadang Anda perlu menangkap bagian dari URI dalam route Anda. Anda dapat mendefinisikan route Anda untuk menerima parameter. Route::get('user/{id}', function ($id) { return 'User '.$id; }); Anda dapat mendefinisikan parameter route sebagai keharusan yang harus dipenuhi dari request yang diterima: Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) { // }); Parameter route selalu diapit dengan tanda kurung kurawal {} dan terdiri dari karakter alpanumerik, dan tidak boleh berisi karakter dash - . Anda dapat menggunakan karakter underscore _ . Parameter route akan dimasukkan ke route callbacks / controller berdasarkan urutan mereka - nama-nama pada argument fungsi callback / controller tidak berpengaruh.","title":"Required Parameters"},{"location":"developerdoc/laravel_routing/#optional-parameters","text":"Parameter route dapat bersifat opsional, kalau ada digunakan, kalau tidak ada juga dijalankan dengan nilai parameter null. Route::get('user/{name?}', function ($name = null) { return $name; }); Route::get('user/{name?}', function ($name = 'John') { return $name; });","title":"Optional Parameters"},{"location":"developerdoc/laravel_routing/#regular-expression-constraints","text":"Anda dapat menentukan format parameter yang dianggap valid dengan regular expression : Route::get('user/{name}', function ($name) { // })->where('name', '[A-Za-z]+'); Route::get('user/{id}', function ($id) { // })->where('id', '[0-9]+'); Route::get('user/{id}/{name}', function ($id, $name) { // })->where(['id' => '[0-9]+', 'name' => '[a-z]+']);","title":"Regular Expression Constraints"},{"location":"developerdoc/laravel_routing/#global-constraints","text":"Jika Anda ingin suatu nama parameter selalu divalidasi formatnya dengan regular expression , Anda dapat mendefinisikan secara global di RouteServiceProvider : /** * Define your route model bindings, pattern filters, etc. * * @return void */ public function boot() { Route::pattern('id', '[0-9]+'); parent::boot(); } Format yang didefinisikan di atas akan selalu digunakan untuk validasi format parameter route dengan nama tersebut: Route::get('user/{id}', function ($id) { // Only executed if {id} is numeric... });","title":"Global Constraints"},{"location":"developerdoc/laravel_routing/#encoded-forward-slashes","text":"Komponen route Laravel mengijinkan pemakaian semua karakter selain garis miring ( / ). Jika Anda menggunakannya, Anda harus secara eksplisit mengijinkan karakter ( / ) dengan regular expression berikut: Route::get('search/{search}', function ($search) { return $search; })->where('search', '.*'); Encoded forward slashes hanya didukung untuk bagian terakhir dari route.","title":"Encoded Forward Slashes"},{"location":"developerdoc/laravel_routing/#named-routes","text":"Route yang diberi nama mengijinkan pembentukan URL atau pengalihan menggunakan nama tersebut. Route::get('user/profile', function () { // })->name('profile'); Anda juga dapat memberi nama route untuk controller actions: Route::get('user/profile', 'UserProfileController@show')->name('profile');","title":"Named Routes"},{"location":"developerdoc/laravel_routing/#generating-urls-to-named-routes","text":"Untuk menuju route yang memiliki nama, Anda dapat menggunakan fungsi berikut: // Generating URLs... $url = route('profile'); // Generating Redirects... return redirect()->route('profile'); Jika route yang diberi nama mengandung parameter, Anda dapat memanggilnya dengan memasukkan parameter sebagai parameter kedua di fungsi redirect ataupun pembentukan URL: Route::get('user/{id}/profile', function ($id) { // })->name('profile'); $url = route('profile', ['id' => 1]);","title":"Generating URLs To Named Routes"},{"location":"developerdoc/laravel_routing/#inspecting-the-current-route","text":"Jika Anda ingin mengetahui apakah route yang digunakan untuk request saat ini menggunakan route dengan nama tertentu, Anda dapat menggunakan method name dari instansi route saat ini: /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($request->route()->named('profile')) { // } return $next($request); }","title":"Inspecting The Current Route"},{"location":"developerdoc/laravel_routing/#route-groups","text":"Route group memudahkan Anda untuk berbagi atribut dari route, misal middleware atau namespace, ke banyak route tanpa perlu mendefinisikan satu persatu pada masing-masing route. Atribut yang dibagi didefinisikan dengan format array di parameter pertama dari method Route::group . Group dapat berisi group lain, dan akan secara otomatis merge atribut yang dipunyainya. Middleware dan kondisi where di-merge, tetapi name, namespace, dan prefix di-append (ditambahkan dibelakangnya). Delimiter namespace dan garis miring di URI prefix secara otomatis ditambahkan sesuai proporsinya.","title":"Route Groups"},{"location":"developerdoc/laravel_routing/#middleware","text":"Untuk memasang middleware ke semua route dalam group, Anda dapat menggunakanmethod middleware sebelum mendefinisikan group. Middleware dijalankan sesuai urutan dalam array tersebut: Route::middleware(['first', 'second'])->group(function () { Route::get('/', function () { // Uses first & second Middleware }); Route::get('user/profile', function () { // Uses first & second Middleware }); });","title":"Middleware"},{"location":"developerdoc/laravel_routing/#namespaces","text":"Route group juga dapat digunakan untuk memasang namespace ke kelompok controller dengan method namespace : Route::namespace('Admin')->group(function () { // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace }); Ingat, secara default, RouteServiceProvider memasukkan file-file route dalam sebuah namespace group, sehingga Anda dapat mendaftarkan route controller tanpa menuliskan lengkap prefix dari controller App\\Http\\Controllers . Jadi Anda cukup menuliskan bagian namespace setelah namespace App\\Http\\Controllers .","title":"Namespaces"},{"location":"developerdoc/laravel_routing/#sub-domain-routing","text":"Route group juga dapat digunakan untuk menangani sub-domain routing. Sub-domain dapat dipasangkan sebagai parameter seperti URI route lain, sehingga Anda dapat membaca nilai bagian sub-domain untuk digunakan pada route atau controller Anda. Route::domain('{account}.myapp.com')->group(function () { Route::get('user/{id}', function ($account, $id) { // }); }); Untuk memastikan route sub-domain dapat diakses, Anda harus mendaftarkan route sub-domain sebelum route root domain . Agar definisinya tidak ditimpa route dari root domain yang mempunyai URI path yang sama.","title":"Sub-Domain Routing"},{"location":"developerdoc/laravel_routing/#route-prefixes","text":"Method prefix dapat digunakan untuk menambah prefiks setiap URI route dalam group. Route::prefix('admin')->group(function () { Route::get('users', function () { // Matches The \"/admin/users\" URL }); });","title":"Route Prefixes"},{"location":"developerdoc/laravel_routing/#route-name-prefixes","text":"Method name dapat digunakan untuk menambahkan prefiks setiap nama route dalam group. Route::name('admin.')->group(function () { Route::get('users', function () { // Route assigned name \"admin.users\"... })->name('users'); });","title":"Route Name Prefixes"},{"location":"developerdoc/laravel_routing/#route-model-binding","text":"Ketika memasukkan sebuah ID model ke sebuah route atau controller action, Anda akan berulang kali menjalankan query untuk mendapatkan model sesuai ID tersebut. Dengan Laravel route model binding, Anda dapat memasukkan instansi model tersebut ke route Anda, sehingga Anda hanya perlu melakukan query di awal saja.","title":"Route Model Binding"},{"location":"developerdoc/laravel_routing/#implicit-binding","text":"Laravel secara otomatis mengenali Eloquent model yang didefinisikan di dalam route atau controller action dengan petunjuk nama variable sesuai nama segmen route. contoh: Route::get('api/users/{user}', function (App\\User $user) { return $user->email; }); Karena variable $user mengacu App\\User Eloquent model dan nama variable sesuai {user} URI segment , Laravel secara otomatis akan memasukkan (inject) instansi model tersebut yang mempunyai ID sesuai nilai yang diperoleh dari request URI. Jika instansi model yang sesuai tidak ditemukan dalam database, akan dikembalikan 404 HTTP response ke client browser.","title":"Implicit Binding"},{"location":"developerdoc/laravel_routing/#customizing-the-key-name","text":"Jika Anda ingin menggunakan kolom lain selain ID, Anda dapat melakukan override method getRouteKeyName pada Eloquent model: /** * Get the route key for the model. * * @return string */ public function getRouteKeyName() { return 'slug'; }","title":"Customizing The Key Name"},{"location":"developerdoc/laravel_routing/#explicit-binding","text":"Untuk mendaftarkan binding secara eksplisit, gunakan method model dari router. Ini didefinisikan dalam method boot pada class RouteServiceProvider : public function boot() { parent::boot(); Route::model('user', App\\User::class); } Selanjutnya, definisikan sebuah route yang berisi parameter {user}: Route::get('profile/{user}', function (App\\User $user) { // }); Karena kita mengikatkan semua parameter {user} ke model App\\User , instansi User akan dimasukkan ke dalam route. Jadi, sebagai contoh, request ke profile/1 akan memasukkan instansi User dari database yang mempunyai ID = 1.","title":"Explicit Binding"},{"location":"developerdoc/laravel_routing/#customizing-the-resolution-logic","text":"Jika Anda ingin menggunakan logika resolusi Anda sendiri, Anda dapat menggunakan method Route::bind. Closure yang Anda lewatkan pada method bind akan menerima nilai dari segmen URI dan harus mengembalikan instansi dari class yang harus dimasukkan ke dalam route: /** * Bootstrap any application services. * * @return void */ public function boot() { parent::boot(); Route::bind('user', function ($value) { return App\\User::where('name', $value)->first() ?? abort(404); }); } Sebagai alternatif, Anda dapat meng-overrride method resolveRouteBinding pada Eloquent model Anda. Method ini akan menerima nilai dari segmen URI dan harus mengembalikan instansi dari class yang harus dimasukkan ke dalam route: /** * Retrieve the model for a bound value. * * @param mixed $value * @return \\Illuminate\\Database\\Eloquent\\Model|null */ public function resolveRouteBinding($value) { return $this->where('name', $value)->first() ?? abort(404); }","title":"Customizing The Resolution Logic"},{"location":"developerdoc/laravel_routing/#fallback-routes","text":"Menggunakan method Route::fallback , Anda dapat mendefinisikan sebuah route yang akan dijalankan ketika tidak ada route yang lain yang sesuai dengan request masuk. Umumnya, request yang tidak ditangani akan secara otomatis mengembalikan halaman \"404\" via exception handler aplikasi Anda. Meskipun demikian, karena Anda boleh mendefinisikan route fallback dalam routes/web.php , maka semua middleware dalam web middleware group akan dijalankan untuk route tersebut. Anda bebas menambahkan middleware tambahan pada route tersebut jika dibutuhkan: Route::fallback(function () { // }); Route fallback harus selalu menjadi route terakhir yang didaftarkan.","title":"Fallback Routes"},{"location":"developerdoc/laravel_routing/#rate-limiting","text":"Laravel menyertakan sebuah middleware untuk membatasi jumlah akses ke route-route dalam aplikasi Anda. Untuk mencobanya, pasangkan throttle middleware ke sebuah route atau sebuah group route. Throttle middleware mempunyai 2 parameter yang menentukan maksimum jumlah request yang dapat diterima dalam sejumlah menit. Contoh, suatu group didefinisikan boleh menerima request dari user yang terauthentikasi maksimum 60x request per menit: Route::middleware('auth:api', 'throttle:60,1')->group(function () { Route::get('/user', function () { // }); });","title":"Rate Limiting"},{"location":"developerdoc/laravel_routing/#dynamic-rate-limiting","text":"Anda juga dapat mendefinisikan nilai maksimum akses secara dinamis Sebagai contoh jika User model mempunyai atribut rate_limit, Route::middleware('auth:api', 'throttle:rate_limit,1')->group(function () { Route::get('/user', function () { // }); });","title":"Dynamic Rate Limiting"},{"location":"developerdoc/laravel_routing/#form-method-spoofing","text":"HTML form tidak mendukung action: PUT, PATCH atau DELETE. Maka, ketika mendefinisikan route PUT, PATCH atau DELETE yang dipanggil dari HTML form, Anda perlu menambahkan hidden _method field ke dalam form. Nilai yang dikirimkan dengan field _method akan digunakan sebagai HTTP request method : <form action=\"/foo/bar\" method=\"POST\"> <input type=\"hidden\" name=\"_method\" value=\"PUT\"> <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\"> </form> Anda dapat menggunakan @method pada Blade untuk membentuk field _method : <form action=\"/foo/bar\" method=\"POST\"> @method('PUT') @csrf </form>","title":"Form Method Spoofing"},{"location":"developerdoc/laravel_routing/#accessing-the-current-route","text":"Anda dapat mengetahui route saat ini yang digunakan dengan method current , currentRouteName , dan currentRouteAction pada Route facade : $route = Route::current(); $name = Route::currentRouteName(); $action = Route::currentRouteAction();","title":"Accessing The Current Route"},{"location":"developerdoc/laravel_routing/#laravel-middleware","text":"Middleware provide a convenient mechanism for filtering HTTP requests entering your application. For example, Laravel includes a middleware that verifies the user of your application is authenticated. If the user is not authenticated, the middleware will redirect the user to the login screen. However, if the user is authenticated, the middleware will allow the request to proceed further into the application. Additional middleware can be written to perform a variety of tasks besides authentication. A CORS middleware might be responsible for adding the proper headers to all responses leaving your application. A logging middleware might log all incoming requests to your application. There are several middleware included in the Laravel framework, including middleware for authentication and CSRF protection. All of these middleware are located in the app/Http/Middleware directory. Defining Middleware To create a new middleware, use the make:middleware Artisan command: php artisan make:middleware CheckAge This command will place a new CheckAge class within your app/Http/Middleware directory. In this middleware, we will only allow access to the route if the supplied age is greater than 200. Otherwise, we will redirect the users back to the home URI: <?php namespace App\\Http\\Middleware; use Closure; class CheckAge { /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($request->age <= 200) { return redirect('home'); } return $next($request); } } As you can see, if the given age is less than or equal to 200, the middleware will return an HTTP redirect to the client; otherwise, the request will be passed further into the application. To pass the request deeper into the application (allowing the middleware to \"pass\"), call the $next callback with the $request. It's best to envision middleware as a series of \"layers\" HTTP requests must pass through before they hit your application. Each layer can examine the request and even reject it entirely. All middleware are resolved via the service container, so you may type-hint any dependencies you need within a middleware's constructor. Before & After Middleware Whether a middleware runs before or after a request depends on the middleware itself. For example, the following middleware would perform some task before the request is handled by the application: <?php namespace App\\Http\\Middleware; use Closure; class BeforeMiddleware { public function handle($request, Closure $next) { // Perform action return $next($request); } } However, this middleware would perform its task after the request is handled by the application: <?php namespace App\\Http\\Middleware; use Closure; class AfterMiddleware { public function handle($request, Closure $next) { $response = $next($request); // Perform action return $response; } }","title":"Laravel Middleware"},{"location":"developerdoc/laravel_routing/#registering-middleware","text":"Global Middleware If you want a middleware to run during every HTTP request to your application, list the middleware class in the $middleware property of your app/Http/Kernel.php class.","title":"Registering Middleware"},{"location":"developerdoc/laravel_routing/#assigning-middleware-to-routes","text":"If you would like to assign middleware to specific routes, you should first assign the middleware a key in your app/Http/Kernel.php file. By default, the $routeMiddleware property of this class contains entries for the middleware included with Laravel. To add your own, append it to this list and assign it a key of your choosing: // Within App\\Http\\Kernel Class... protected $routeMiddleware = [ 'auth' => \\App\\Http\\Middleware\\Authenticate::class, 'auth.basic' => \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, 'bindings' => \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 'cache.headers' => \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class, 'can' => \\Illuminate\\Auth\\Middleware\\Authorize::class, 'guest' => \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, 'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, 'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, 'verified' => \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class, ]; Once the middleware has been defined in the HTTP kernel, you may use the middleware method to assign middleware to a route: Route::get('admin/profile', function () { // })->middleware('auth'); You may also assign multiple middleware to the route: Route::get('/', function () { // })->middleware('first', 'second'); When assigning middleware, you may also pass the fully qualified class name: use App\\Http\\Middleware\\CheckAge; Route::get('admin/profile', function () { // })->middleware(CheckAge::class);","title":"Assigning Middleware To Routes"},{"location":"developerdoc/laravel_routing/#middleware-groups","text":"Sometimes you may want to group several middleware under a single key to make them easier to assign to routes. You may do this using the $middlewareGroups property of your HTTP kernel. Out of the box, Laravel comes with web and api middleware groups that contain common middleware you may want to apply to your web UI and API routes: /** * The application's route middleware groups. * * @var array */ protected $middlewareGroups = [ 'web' => [ \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], 'api' => [ 'throttle:60,1', 'auth:api', ], ]; Middleware groups may be assigned to routes and controller actions using the same syntax as individual middleware. Again, middleware groups make it more convenient to assign many middleware to a route at once: Route::get('/', function () { // })->middleware('web'); Route::group(['middleware' => ['web']], function () { // }); Out of the box, the web middleware group is automatically applied to your routes/web.php file by the RouteServiceProvider.","title":"Middleware Groups"},{"location":"developerdoc/laravel_routing/#sorting-middleware","text":"Rarely, you may need your middleware to execute in a specific order but not have control over their order when they are assigned to the route. In this case, you may specify your middleware priority using the $middlewarePriority property of your app/Http/Kernel.php file: /** * The priority-sorted list of middleware. * * This forces non-global middleware to always be in the given order. * * @var array */ protected $middlewarePriority = [ \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\Authenticate::class, \\Illuminate\\Session\\Middleware\\AuthenticateSession::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, \\Illuminate\\Auth\\Middleware\\Authorize::class, ];","title":"Sorting Middleware"},{"location":"developerdoc/laravel_routing/#middleware-parameters","text":"Middleware can also receive additional parameters. For example, if your application needs to verify that the authenticated user has a given \"role\" before performing a given action, you could create a CheckRole middleware that receives a role name as an additional argument. Additional middleware parameters will be passed to the middleware after the $next argument: <?php namespace App\\Http\\Middleware; use Closure; class CheckRole { /** * Handle the incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string $role * @return mixed */ public function handle($request, Closure $next, $role) { if (! $request->user()->hasRole($role)) { // Redirect... } return $next($request); } } Middleware parameters may be specified when defining the route by separating the middleware name and parameters with a :. Multiple parameters should be delimited by commas: Route::put('post/{id}', function ($id) { // })->middleware('role:editor');","title":"Middleware Parameters"},{"location":"developerdoc/laravel_routing/#terminable-middleware","text":"Sometimes a middleware may need to do some work after the HTTP response has been sent to the browser. For example, the \"session\" middleware included with Laravel writes the session data to storage after the response has been sent to the browser. If you define a terminate method on your middleware and your web server is using FastCGI, the terminate method will automatically be called after the response is sent to the browser. <?php namespace Illuminate\\Session\\Middleware; use Closure; class StartSession { public function handle($request, Closure $next) { return $next($request); } public function terminate($request, $response) { // Store the session data... } } The terminate method should receive both the request and the response. Once you have defined a terminable middleware, you should add it to the list of route or global middleware in the app/Http/Kernel.php file. When calling the terminate method on your middleware, Laravel will resolve a fresh instance of the middleware from the service container. If you would like to use the same middleware instance when the handle and terminate methods are called, register the middleware with the container using the container's singleton method.","title":"Terminable Middleware"},{"location":"developerdoc/laravel_routing/#csrf-protection_1","text":"Introduction Laravel makes it easy to protect your application from cross-site request forgery (CSRF) attacks. Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user. Laravel automatically generates a CSRF \"token\" for each active user session managed by the application. This token is used to verify that the authenticated user is the one actually making the requests to the application. Anytime you define an HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field: <form method=\"POST\" action=\"/profile\"> @csrf ... </form> The VerifyCsrfToken middleware, which is included in the web middleware group, will automatically verify that the token in the request input matches the token stored in the session.","title":"CSRF Protection"},{"location":"developerdoc/laravel_routing/#csrf-tokens-javascript","text":"When building JavaScript driven applications, it is convenient to have your JavaScript HTTP library automatically attach the CSRF token to every outgoing request. By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application. Excluding URIs From CSRF Protection Sometimes you may wish to exclude a set of URIs from CSRF protection. For example, if you are using Stripe to process payments and are utilizing their webhook system, you will need to exclude your Stripe webhook handler route from CSRF protection since Stripe will not know what CSRF token to send to your routes. Typically, you should place these kinds of routes outside of the web middleware group that the RouteServiceProvider applies to all routes in the routes/web.php file. However, you may also exclude the routes by adding their URIs to the $except property of the VerifyCsrfToken middleware: <?php namespace App\\Http\\Middleware; use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware; class VerifyCsrfToken extends Middleware { /** * The URIs that should be excluded from CSRF verification. * * @var array */ protected $except = [ 'stripe/*', 'http://example.com/foo/bar', 'http://example.com/foo/*', ]; } The CSRF middleware is automatically disabled when running tests.","title":"CSRF Tokens &amp; JavaScript"},{"location":"developerdoc/laravel_routing/#x-csrf-token","text":"In addition to checking for the CSRF token as a POST parameter, the VerifyCsrfToken middleware will also check for the X-CSRF-TOKEN request header. You could, for example, store the token in an HTML meta tag: <meta name=\"csrf-token\" content=\"{{ csrf_token() }}\"> Then, once you have created the meta tag, you can instruct a library like jQuery to automatically add the token to all request headers. This provides simple, convenient CSRF protection for your AJAX based applications: $.ajaxSetup({ headers: { 'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content') } }); By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application.","title":"X-CSRF-TOKEN"},{"location":"developerdoc/laravel_routing/#x-xsrf-token","text":"Laravel stores the current CSRF token in a XSRF-TOKEN cookie that is included with each response generated by the framework. You can use the cookie value to set the X-XSRF-TOKEN request header. This cookie is primarily sent as a convenience since some JavaScript frameworks and libraries, like Angular and Axios, automatically place its value in the X-XSRF-TOKEN header.","title":"X-XSRF-TOKEN"},{"location":"developerdoc/laravel_routing/#laravel-controller","text":"Instead of defining all of your request handling logic as Closures in route files, you may wish to organize this behavior using Controller classes. Controllers can group related request handling logic into a single class. Controllers are stored in the app/Http/Controllers directory.","title":"Laravel Controller"},{"location":"developerdoc/laravel_routing/#basic-controllers","text":"Defining Controllers Below is an example of a basic controller class. Note that the controller extends the base controller class included with Laravel. The base class provides a few convenience methods such as the middleware method, which may be used to attach middleware to controller actions: <?php namespace App\\Http\\Controllers; use App\\User; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show the profile for the given user. * * @param int $id * @return View */ public function show($id) { return view('user.profile', ['user' => User::findOrFail($id)]); } } You can define a route to this controller action like so: Route::get('user/{id}', 'UserController@show'); Now, when a request matches the specified route URI, the show method on the UserController class will be executed. The route parameters will also be passed to the method. Controllers are not required to extend a base class. However, you will not have access to convenience features such as the middleware, validate, and dispatch methods.","title":"Basic Controllers"},{"location":"developerdoc/laravel_routing/#controllers-namespaces","text":"It is very important to note that we did not need to specify the full controller namespace when defining the controller route. Since the RouteServiceProvider loads your route files within a route group that contains the namespace, we only specified the portion of the class name that comes after the App\\Http\\Controllers portion of the namespace. If you choose to nest your controllers deeper into the App\\Http\\Controllers directory, use the specific class name relative to the App\\Http\\Controllers root namespace. So, if your full controller class is App\\Http\\Controllers\\Photos\\AdminController, you should register routes to the controller like so: Route::get('foo', 'Photos\\AdminController@method'); Single Action Controllers If you would like to define a controller that only handles a single action, you may place a single __invoke method on the controller: <?php namespace App\\Http\\Controllers; use App\\User; use App\\Http\\Controllers\\Controller; class ShowProfile extends Controller { /** * Show the profile for the given user. * * @param int $id * @return View */ public function __invoke($id) { return view('user.profile', ['user' => User::findOrFail($id)]); } } When registering routes for single action controllers, you do not need to specify a method: Route::get('user/{id}', 'ShowProfile'); You may generate an invokable controller by using the --invokable option of the make:controller Artisan command: php artisan make:controller ShowProfile --invokable","title":"Controllers &amp; Namespaces"},{"location":"developerdoc/laravel_routing/#controller-middleware","text":"Middleware may be assigned to the controller's routes in your route files: Route::get('profile', 'UserController@show')->middleware('auth'); However, it is more convenient to specify middleware within your controller's constructor. Using the middleware method from your controller's constructor, you may easily assign middleware to the controller's action. You may even restrict the middleware to only certain methods on the controller class: class UserController extends Controller { /** * Instantiate a new controller instance. * * @return void */ public function __construct() { $this->middleware('auth'); $this->middleware('log')->only('index'); $this->middleware('subscribed')->except('store'); } } Controllers also allow you to register middleware using a Closure. This provides a convenient way to define a middleware for a single controller without defining an entire middleware class: $this->middleware(function ($request, $next) { // ... return $next($request); }); You may assign middleware to a subset of controller actions; however, it may indicate your controller is growing too large. Instead, consider breaking your controller into multiple, smaller controllers.","title":"Controller Middleware"},{"location":"developerdoc/laravel_routing/#resource-controllers","text":"Laravel resource routing assigns the typical \"CRUD\" routes to a controller with a single line of code. For example, you may wish to create a controller that handles all HTTP requests for \"photos\" stored by your application. Using the make:controller Artisan command, we can quickly create such a controller: php artisan make:controller PhotoController --resource This command will generate a controller at app/Http/Controllers/PhotoController.php. The controller will contain a method for each of the available resource operations. Next, you may register a resourceful route to the controller: Route::resource('photos', 'PhotoController'); This single route declaration creates multiple routes to handle a variety of actions on the resource. The generated controller will already have methods stubbed for each of these actions, including notes informing you of the HTTP verbs and URIs they handle. You may register many resource controllers at once by passing an array to the resources method: Route::resources([ 'photos' => 'PhotoController', 'posts' => 'PostController' ]); Actions Handled By Resource Controller Verb URI Action Route Name GET /photos index photos.index GET /photos/create create photos.create POST /photos store photos.store GET /photos/{photo} show photos.show GET /photos/{photo}/edit edit photos.edit PUT/PATCH /photos/{photo} update photos.update DELETE /photos/{photo} destroy photos.destroy","title":"Resource Controllers"},{"location":"developerdoc/laravel_routing/#specifying-the-resource-model","text":"If you are using route model binding and would like the resource controller's methods to type-hint a model instance, you may use the --model option when generating the controller: php artisan make:controller PhotoController --resource --model=Photo Spoofing Form Methods Since HTML forms can't make PUT, PATCH, or DELETE requests, you will need to add a hidden _method field to spoof these HTTP verbs. The @method Blade directive can create this field for you: <form action=\"/foo/bar\" method=\"POST\"> @method('PUT') </form>","title":"Specifying The Resource Model"},{"location":"developerdoc/laravel_routing/#partial-resource-routes","text":"When declaring a resource route, you may specify a subset of actions the controller should handle instead of the full set of default actions: Route::resource('photos', 'PhotoController')->only([ 'index', 'show' ]); Route::resource('photos', 'PhotoController')->except([ 'create', 'store', 'update', 'destroy' ]);","title":"Partial Resource Routes"},{"location":"developerdoc/laravel_routing/#api-resource-routes","text":"When declaring resource routes that will be consumed by APIs, you will commonly want to exclude routes that present HTML templates such as create and edit. For convenience, you may use the apiResource method to automatically exclude these two routes: Route::apiResource('photos', 'PhotoController'); You may register many API resource controllers at once by passing an array to the apiResources method: Route::apiResources([ 'photos' => 'PhotoController', 'posts' => 'PostController' ]); To quickly generate an API resource controller that does not include the create or edit methods, use the --api switch when executing the make:controller command: php artisan make:controller API/PhotoController --api","title":"API Resource Routes"},{"location":"developerdoc/laravel_routing/#naming-resource-routes","text":"By default, all resource controller actions have a route name; however, you can override these names by passing a names array with your options: Route::resource('photos', 'PhotoController')->names([ 'create' => 'photos.build' ]);","title":"Naming Resource Routes"},{"location":"developerdoc/laravel_routing/#naming-resource-route-parameters","text":"By default, Route::resource will create the route parameters for your resource routes based on the \"singularized\" version of the resource name. You can easily override this on a per resource basis by using the parameters method. The array passed into the parameters method should be an associative array of resource names and parameter names: Route::resource('users', 'AdminUserController')->parameters([ 'users' => 'admin_user' ]); The example above generates the following URIs for the resource's show route: /users/{admin_user}","title":"Naming Resource Route Parameters"},{"location":"developerdoc/laravel_routing/#localizing-resource-uris","text":"By default, Route::resource will create resource URIs using English verbs. If you need to localize the create and edit action verbs, you may use the Route::resourceVerbs method. This may be done in the boot method of your AppServiceProvider: use Illuminate\\Support\\Facades\\Route; /** * Bootstrap any application services. * * @return void */ public function boot() { Route::resourceVerbs([ 'create' => 'crear', 'edit' => 'editar', ]); } Once the verbs have been customized, a resource route registration such as Route::resource('fotos', 'PhotoController') will produce the following URIs: /fotos/crear /fotos/{foto}/editar","title":"Localizing Resource URIs"},{"location":"developerdoc/laravel_routing/#supplementing-resource-controllers","text":"If you need to add additional routes to a resource controller beyond the default set of resource routes, you should define those routes before your call to Route::resource; otherwise, the routes defined by the resource method may unintentionally take precedence over your supplemental routes: Route::get('photos/popular', 'PhotoController@method'); Route::resource('photos', 'PhotoController'); Remember to keep your controllers focused. If you find yourself routinely needing methods outside of the typical set of resource actions, consider splitting your controller into two, smaller controllers.","title":"Supplementing Resource Controllers"},{"location":"developerdoc/laravel_routing/#dependency-injection-controllers","text":"","title":"Dependency Injection &amp; Controllers"},{"location":"developerdoc/laravel_routing/#constructor-injection","text":"The Laravel service container is used to resolve all Laravel controllers. As a result, you are able to type-hint any dependencies your controller may need in its constructor. The declared dependencies will automatically be resolved and injected into the controller instance: <?php namespace App\\Http\\Controllers; use App\\Repositories\\UserRepository; class UserController extends Controller { /** * The user repository instance. */ protected $users; /** * Create a new controller instance. * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) { $this->users = $users; } } You may also type-hint any Laravel contract. If the container can resolve it, you can type-hint it. Depending on your application, injecting your dependencies into your controller may provide better testability.","title":"Constructor Injection"},{"location":"developerdoc/laravel_routing/#method-injection","text":"In addition to constructor injection, you may also type-hint dependencies on your controller's methods. A common use-case for method injection is injecting the Illuminate\\Http\\Request instance into your controller methods: <?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Store a new user. * * @param Request $request * @return Response */ public function store(Request $request) { $name = $request->name; // } } If your controller method is also expecting input from a route parameter, list your route arguments after your other dependencies. For example, if your route is defined like so: Route::put('user/{id}', 'UserController@update'); You may still type-hint the Illuminate\\Http\\Request and access your id parameter by defining your controller method as follows: <?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Update the given user. * * @param Request $request * @param string $id * @return Response */ public function update(Request $request, $id) { // } }","title":"Method Injection"},{"location":"developerdoc/laravel_routing/#route-caching","text":"Closure based routes cannot be cached. To use route caching, you must convert any Closure routes to controller classes. If your application is exclusively using controller based routes, you should take advantage of Laravel's route cache. Using the route cache will drastically decrease the amount of time it takes to register all of your application's routes. In some cases, your route registration may even be up to 100x faster. To generate a route cache, just execute the route:cache Artisan command: php artisan route:cache After running this command, your cached routes file will be loaded on every request. Remember, if you add any new routes you will need to generate a fresh route cache. Because of this, you should only run the route:cache command during your project's deployment. You may use the route:clear command to clear the route cache: php artisan route:clear","title":"Route Caching"},{"location":"developerdoc/laravel_routing/#request","text":"Accessing The Request To obtain an instance of the current HTTP request via dependency injection, you should type-hint the Illuminate\\Http\\Request class on your controller method. The incoming request instance will automatically be injected by the service container: <?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Store a new user. * * @param Request $request * @return Response */ public function store(Request $request) { $name = $request->input('name'); // } }","title":"Request"},{"location":"developerdoc/laravel_routing/#dependency-injection-route-parameters","text":"If your controller method is also expecting input from a route parameter you should list your route parameters after your other dependencies. For example, if your route is defined like so: Route::put('user/{id}', 'UserController@update'); You may still type-hint the Illuminate\\Http\\Request and access your route parameter id by defining your controller method as follows: <?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Update the specified user. * * @param Request $request * @param string $id * @return Response */ public function update(Request $request, $id) { // } }","title":"Dependency Injection &amp; Route Parameters"},{"location":"developerdoc/laravel_routing/#accessing-the-request-via-route-closures","text":"You may also type-hint the Illuminate\\Http\\Request class on a route Closure. The service container will automatically inject the incoming request into the Closure when it is executed: use Illuminate\\Http\\Request; Route::get('/', function (Request $request) { // });","title":"Accessing The Request Via Route Closures"},{"location":"developerdoc/laravel_routing/#request-path-method","text":"The Illuminate\\Http\\Request instance provides a variety of methods for examining the HTTP request for your application and extends the Symfony\\Component\\HttpFoundation\\Request class. We will discuss a few of the most important methods below.","title":"Request Path &amp; Method"},{"location":"developerdoc/laravel_routing/#retrieving-the-request-path","text":"The path method returns the request's path information. So, if the incoming request is targeted at http://domain.com/foo/bar, the path method will return foo/bar: $uri = $request->path(); The is method allows you to verify that the incoming request path matches a given pattern. You may use the * character as a wildcard when utilizing this method: if ($request->is('admin/*')) { // }","title":"Retrieving The Request Path"},{"location":"developerdoc/laravel_routing/#retrieving-the-request-url","text":"To retrieve the full URL for the incoming request you may use the url or fullUrl methods. The url method will return the URL without the query string, while the fullUrl method includes the query string: // Without Query String... $url = $request->url(); // With Query String... $url = $request->fullUrl();","title":"Retrieving The Request URL"},{"location":"developerdoc/laravel_routing/#retrieving-the-request-method","text":"The method method will return the HTTP verb for the request. You may use the isMethod method to verify that the HTTP verb matches a given string: $method = $request->method(); if ($request->isMethod('post')) { // }","title":"Retrieving The Request Method"},{"location":"developerdoc/laravel_routing/#psr-7-requests","text":"The PSR-7 standard specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain an instance of a PSR-7 request instead of a Laravel request, you will first need to install a few libraries. Laravel uses the Symfony HTTP Message Bridge component to convert typical Laravel requests and responses into PSR-7 compatible implementations: composer require symfony/psr-http-message-bridge composer require zendframework/zend-diactoros Once you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your route Closure or controller method: use Psr\\Http\\Message\\ServerRequestInterface; Route::get('/', function (ServerRequestInterface $request) { // }); If you return a PSR-7 response instance from a route or controller, it will automatically be converted back to a Laravel response instance and be displayed by the framework.","title":"PSR-7 Requests"},{"location":"developerdoc/laravel_routing/#input-trimming-normalization","text":"By default, Laravel includes the TrimStrings and ConvertEmptyStringsToNull middleware in your application's global middleware stack. These middleware are listed in the stack by the App\\Http\\Kernel class. These middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to null. This allows you to not have to worry about these normalization concerns in your routes and controllers. If you would like to disable this behavior, you may remove the two middleware from your application's middleware stack by removing them from the $middleware property of your App\\Http\\Kernel class.","title":"Input Trimming &amp; Normalization"},{"location":"developerdoc/laravel_routing/#retrieving-input","text":"Retrieving All Input Data You may also retrieve all of the input data as an array using the all method: $input = $request->all();","title":"Retrieving Input"},{"location":"developerdoc/laravel_routing/#retrieving-an-input-value","text":"Using a few simple methods, you may access all of the user input from your Illuminate\\Http\\Request instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the input method may be used to retrieve user input: $name = $request->input('name'); You may pass a default value as the second argument to the input method. This value will be returned if the requested input value is not present on the request: $name = $request->input('name', 'Sally'); When working with forms that contain array inputs, use \"dot\" notation to access the arrays: $name = $request->input('products.0.name'); $names = $request->input('products.*.name'); You may call the input method without any arguments in order to retrieve all of the input values as an associative array: $input = $request->input();","title":"Retrieving An Input Value"},{"location":"developerdoc/laravel_routing/#retrieving-input-from-the-query-string","text":"While the input method retrieves values from entire request payload (including the query string), the query method will only retrieve values from the query string: $name = $request->query('name'); If the requested query string value data is not present, the second argument to this method will be returned: $name = $request->query('name', 'Helen'); You may call the query method without any arguments in order to retrieve all of the query string values as an associative array: $query = $request->query();","title":"Retrieving Input From The Query String"},{"location":"developerdoc/laravel_routing/#retrieving-input-via-dynamic-properties","text":"You may also access user input using dynamic properties on the Illuminate\\Http\\Request instance. For example, if one of your application's forms contains a name field, you may access the value of the field like so: $name = $request->name; When using dynamic properties, Laravel will first look for the parameter's value in the request payload. If it is not present, Laravel will search for the field in the route parameters.","title":"Retrieving Input Via Dynamic Properties"},{"location":"developerdoc/laravel_routing/#retrieving-json-input-values","text":"When sending JSON requests to your application, you may access the JSON data via the input method as long as the Content-Type header of the request is properly set to application/json. You may even use \"dot\" syntax to dig into JSON arrays: $name = $request->input('user.name');","title":"Retrieving JSON Input Values"},{"location":"developerdoc/laravel_routing/#retrieving-a-portion-of-the-input-data","text":"If you need to retrieve a subset of the input data, you may use the only and except methods. Both of these methods accept a single array or a dynamic list of arguments: $input = $request->only(['username', 'password']); $input = $request->only('username', 'password'); $input = $request->except(['credit_card']); $input = $request->except('credit_card'); The only method returns all of the key / value pairs that you request; however, it will not return key / value pairs that are not present on the request.","title":"Retrieving A Portion Of The Input Data"},{"location":"developerdoc/laravel_routing/#determining-if-an-input-value-is-present","text":"You should use the has method to determine if a value is present on the request. The has method returns true if the value is present on the request: if ($request->has('name')) { // } When given an array, the has method will determine if all of the specified values are present: if ($request->has(['name', 'email'])) { // } If you would like to determine if a value is present on the request and is not empty, you may use the filled method: if ($request->filled('name')) { // }","title":"Determining If An Input Value Is Present"},{"location":"developerdoc/laravel_routing/#old-input","text":"Laravel allows you to keep input from one request during the next request. This feature is particularly useful for re-populating forms after detecting validation errors. However, if you are using Laravel's included validation features, it is unlikely you will need to manually use these methods, as some of Laravel's built-in validation facilities will call them automatically.","title":"Old Input"},{"location":"developerdoc/laravel_routing/#flashing-input-to-the-session","text":"The flash method on the Illuminate\\Http\\Request class will flash the current input to the session so that it is available during the user's next request to the application: $request->flash(); You may also use the flashOnly and flashExcept methods to flash a subset of the request data to the session. These methods are useful for keeping sensitive information such as passwords out of the session: $request->flashOnly(['username', 'email']); $request->flashExcept('password');","title":"Flashing Input To The Session"},{"location":"developerdoc/laravel_routing/#flashing-input-then-redirecting","text":"Since you often will want to flash input to the session and then redirect to the previous page, you may easily chain input flashing onto a redirect using the withInput method: return redirect('form')->withInput(); return redirect('form')->withInput( $request->except('password') );","title":"Flashing Input Then Redirecting"},{"location":"developerdoc/laravel_routing/#retrieving-old-input","text":"To retrieve flashed input from the previous request, use the old method on the Request instance. The old method will pull the previously flashed input data from the session: $username = $request->old('username'); Laravel also provides a global old helper. If you are displaying old input within a Blade template, it is more convenient to use the old helper. If no old input exists for the given field, null will be returned: <input type=\"text\" name=\"username\" value=\"{{ old('username') }}\">","title":"Retrieving Old Input"},{"location":"developerdoc/laravel_routing/#cookies","text":"Retrieving Cookies From Requests All cookies created by the Laravel framework are encrypted and signed with an authentication code, meaning they will be considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the cookie method on a Illuminate\\Http\\Request instance: $value = $request->cookie('name'); Alternatively, you may use the Cookie facade to access cookie values: $value = Cookie::get('name');","title":"Cookies"},{"location":"developerdoc/laravel_routing/#attaching-cookies-to-responses","text":"You may attach a cookie to an outgoing Illuminate\\Http\\Response instance using the cookie method. You should pass the name, value, and number of minutes the cookie should be considered valid to this method: return response('Hello World')->cookie( 'name', 'value', $minutes ); The cookie method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native setcookie method: return response('Hello World')->cookie( 'name', 'value', $minutes, $path, $domain, $secure, $httpOnly ); Alternatively, you can use the Cookie facade to \"queue\" cookies for attachment to the outgoing response from your application. The queue method accepts a Cookie instance or the arguments needed to create a Cookie instance. These cookies will be attached to the outgoing response before it is sent to the browser: Cookie::queue(Cookie::make('name', 'value', $minutes)); Cookie::queue('name', 'value', $minutes);","title":"Attaching Cookies To Responses"},{"location":"developerdoc/laravel_routing/#generating-cookie-instances","text":"If you would like to generate a Symfony\\Component\\HttpFoundation\\Cookie instance that can be given to a response instance at a later time, you may use the global cookie helper. This cookie will not be sent back to the client unless it is attached to a response instance: $cookie = cookie('name', 'value', $minutes); return response('Hello World')->cookie($cookie); Files Retrieving Uploaded Files You may access uploaded files from a Illuminate\\Http\\Request instance using the file method or using dynamic properties. The file method returns an instance of the Illuminate\\Http\\UploadedFile class, which extends the PHP SplFileInfo class and provides a variety of methods for interacting with the file: $file = $request->file('photo'); $file = $request->photo; You may determine if a file is present on the request using the hasFile method: if ($request->hasFile('photo')) { // } Validating Successful Uploads In addition to checking if the file is present, you may verify that there were no problems uploading the file via the isValid method: if ($request->file('photo')->isValid()) { // } File Paths & Extensions The UploadedFile class also contains methods for accessing the file's fully-qualified path and its extension. The extension method will attempt to guess the file's extension based on its contents. This extension may be different from the extension that was supplied by the client: $path = $request->photo->path(); $extension = $request->photo->extension(); Other File Methods There are a variety of other methods available on UploadedFile instances. Check out the API documentation for the class for more information regarding these methods. Storing Uploaded Files To store an uploaded file, you will typically use one of your configured filesystems. The UploadedFile class has a store method which will move an uploaded file to one of your disks, which may be a location on your local filesystem or even a cloud storage location like Amazon S3. The store method accepts the path where the file should be stored relative to the filesystem's configured root directory. This path should not contain a file name, since a unique ID will automatically be generated to serve as the file name. The store method also accepts an optional second argument for the name of the disk that should be used to store the file. The method will return the path of the file relative to the disk's root: $path = $request->photo->store('images'); $path = $request->photo->store('images', 's3'); If you do not want a file name to be automatically generated, you may use the storeAs method, which accepts the path, file name, and disk name as its arguments: $path = $request->photo->storeAs('images', 'filename.jpg'); $path = $request->photo->storeAs('images', 'filename.jpg', 's3'); Configuring Trusted Proxies When running your applications behind a load balancer that terminates TLS / SSL certificates, you may notice your application sometimes does not generate HTTPS links. Typically this is because your application is being forwarded traffic from your load balancer on port 80 and does not know it should generate secure links. To solve this, you may use the App\\Http\\Middleware\\TrustProxies middleware that is included in your Laravel application, which allows you to quickly customize the load balancers or proxies that should be trusted by your application. Your trusted proxies should be listed as an array on the $proxies property of this middleware. In addition to configuring the trusted proxies, you may configure the proxy $headers that should be trusted: <?php namespace App\\Http\\Middleware; use Illuminate\\Http\\Request; use Fideloper\\Proxy\\TrustProxies as Middleware; class TrustProxies extends Middleware { /** * The trusted proxies for this application. * * @var array */ protected $proxies = [ '192.168.1.1', '192.168.1.2', ]; /** * The headers that should be used to detect proxies. * * @var string */ protected $headers = Request::HEADER_X_FORWARDED_ALL; } If you are using AWS Elastic Load Balancing, your $headers value should be Request::HEADER_X_FORWARDED_AWS_ELB. For more information on the constants that may be used in the $headers property, check out Symfony's documentation on trusting proxies.","title":"Generating Cookie Instances"},{"location":"developerdoc/laravel_routing/#trusting-all-proxies","text":"If you are using Amazon AWS or another \"cloud\" load balancer provider, you may not know the IP addresses of your actual balancers. In this case, you may use * to trust all proxies: /** * The trusted proxies for this application. * * @var array */ protected $proxies = '*';","title":"Trusting All Proxies"},{"location":"developerdoc/laravel_routing/#response","text":"","title":"Response"},{"location":"developerdoc/laravel_routing/#creating-responses","text":"","title":"Creating Responses"},{"location":"developerdoc/laravel_routing/#strings-arrays","text":"All routes and controllers should return a response to be sent back to the user's browser. Laravel provides several different ways to return responses. The most basic response is returning a string from a route or controller. The framework will automatically convert the string into a full HTTP response: Route::get('/', function () { return 'Hello World'; }); In addition to returning strings from your routes and controllers, you may also return arrays. The framework will automatically convert the array into a JSON response: Route::get('/', function () { return [1, 2, 3]; }); Did you know you can also return Eloquent collections from your routes or controllers? They will automatically be converted to JSON. Give it a shot!","title":"Strings &amp; Arrays"},{"location":"developerdoc/laravel_routing/#response-objects","text":"Typically, you won't just be returning simple strings or arrays from your route actions. Instead, you will be returning full Illuminate\\Http\\Response instances or views. Returning a full Response instance allows you to customize the response's HTTP status code and headers. A Response instance inherits from the Symfony\\Component\\HttpFoundation\\Response class, which provides a variety of methods for building HTTP responses: Route::get('home', function () { return response('Hello World', 200) ->header('Content-Type', 'text/plain'); }); Attaching Headers To Responses Keep in mind that most response methods are chainable, allowing for the fluent construction of response instances. For example, you may use the header method to add a series of headers to the response before sending it back to the user: return response($content) ->header('Content-Type', $type) ->header('X-Header-One', 'Header Value') ->header('X-Header-Two', 'Header Value'); Or, you may use the withHeaders method to specify an array of headers to be added to the response: return response($content) ->withHeaders([ 'Content-Type' => $type, 'X-Header-One' => 'Header Value', 'X-Header-Two' => 'Header Value', ]); Cache Control Middleware Laravel includes a cache.headers middleware, which may be used to quickly set the Cache-Control header for a group of routes. If etag is specified in the list of directives, an MD5 hash of the response content will automatically be set as the ETag identifier: Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function() { Route::get('privacy', function () { // ... }); Route::get('terms', function () { // ... }); }); Attaching Cookies To Responses The cookie method on response instances allows you to easily attach cookies to the response. For example, you may use the cookie method to generate a cookie and fluently attach it to the response instance like so: return response($content) ->header('Content-Type', $type) ->cookie('name', 'value', $minutes); The cookie method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native setcookie method: ->cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly) Alternatively, you can use the Cookie facade to \"queue\" cookies for attachment to the outgoing response from your application. The queue method accepts a Cookie instance or the arguments needed to create a Cookie instance. These cookies will be attached to the outgoing response before it is sent to the browser: Cookie::queue(Cookie::make('name', 'value', $minutes)); Cookie::queue('name', 'value', $minutes); Cookies & Encryption By default, all cookies generated by Laravel are encrypted and signed so that they can't be modified or read by the client. If you would like to disable encryption for a subset of cookies generated by your application, you may use the $except property of the App\\Http\\Middleware\\EncryptCookies middleware, which is located in the app/Http/Middleware directory: /* * The names of the cookies that should not be encrypted. * * @var array / protected $except = [ 'cookie_name', ]; Redirects Redirect responses are instances of the Illuminate\\Http\\RedirectResponse class, and contain the proper headers needed to redirect the user to another URL. There are several ways to generate a RedirectResponse instance. The simplest method is to use the global redirect helper: Route::get('dashboard', function () { return redirect('home/dashboard'); }); Sometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid. You may do so by using the global back helper function. Since this feature utilizes the session, make sure the route calling the back function is using the web middleware group or has all of the session middleware applied: Route::post('user/profile', function () { // Validate the request... return back()->withInput(); }); Redirecting To Named Routes When you call the redirect helper with no parameters, an instance of Illuminate\\Routing\\Redirector is returned, allowing you to call any method on the Redirector instance. For example, to generate a RedirectResponse to a named route, you may use the route method: return redirect()->route('login'); If your route has parameters, you may pass them as the second argument to the route method: // For a route with the following URI: profile/{id} return redirect()->route('profile', ['id' => 1]); Populating Parameters Via Eloquent Models If you are redirecting to a route with an \"ID\" parameter that is being populated from an Eloquent model, you may pass the model itself. The ID will be extracted automatically: // For a route with the following URI: profile/{id} return redirect()->route('profile', [$user]); If you would like to customize the value that is placed in the route parameter, you should override the getRouteKey method on your Eloquent model: /* * Get the value of the model's route key. * * @return mixed / public function getRouteKey() { return $this->slug; } Redirecting To Controller Actions You may also generate redirects to controller actions. To do so, pass the controller and action name to the action method. Remember, you do not need to specify the full namespace to the controller since Laravel's RouteServiceProvider will automatically set the base controller namespace: return redirect()->action('HomeController@index'); If your controller route requires parameters, you may pass them as the second argument to the action method: return redirect()->action( 'UserController@profile', ['id' => 1] ); Redirecting To External Domains Sometimes you may need to redirect to a domain outside of your application. You may do so by calling the away method, which creates a RedirectResponse without any additional URL encoding, validation, or verification: return redirect()->away('https://www.google.com'); Redirecting With Flashed Session Data Redirecting to a new URL and flashing data to the session are usually done at the same time. Typically, this is done after successfully performing an action when you flash a success message to the session. For convenience, you may create a RedirectResponse instance and flash data to the session in a single, fluent method chain: Route::post('user/profile', function () { // Update the user's profile... return redirect('dashboard')->with('status', 'Profile updated!'); }); After the user is redirected, you may display the flashed message from the session. For example, using Blade syntax: @if (session('status')) {{ session('status') }} @endif Other Response Types The response helper may be used to generate other types of response instances. When the response helper is called without arguments, an implementation of the Illuminate\\Contracts\\Routing\\ResponseFactory contract is returned. This contract provides several helpful methods for generating responses. View Responses If you need control over the response's status and headers but also need to return a view as the response's content, you should use the view method: return response() ->view('hello', $data, 200) ->header('Content-Type', $type); Of course, if you do not need to pass a custom HTTP status code or custom headers, you should use the global view helper function. JSON Responses The json method will automatically set the Content-Type header to application/json, as well as convert the given array to JSON using the json_encode PHP function: return response()->json([ 'name' => 'Abigail', 'state' => 'CA' ]); If you would like to create a JSONP response, you may use the json method in combination with the withCallback method: return response() ->json(['name' => 'Abigail', 'state' => 'CA']) ->withCallback($request->input('callback')); File Downloads The download method may be used to generate a response that forces the user's browser to download the file at the given path. The download method accepts a file name as the second argument to the method, which will determine the file name that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third argument to the method: return response()->download($pathToFile); return response()->download($pathToFile, $name, $headers); return response()->download($pathToFile)->deleteFileAfterSend(); Symfony HttpFoundation, which manages file downloads, requires the file being downloaded to have an ASCII file name. Streamed Downloads Sometimes you may wish to turn the string response of a given operation into a downloadable response without having to write the contents of the operation to disk. You may use the streamDownload method in this scenario. This method accepts a callback, file name, and an optional array of headers as its arguments: return response()->streamDownload(function () { echo GitHub::api('repo') ->contents() ->readme('laravel', 'laravel')['contents']; }, 'laravel-readme.md'); File Responses The file method may be used to display a file, such as an image or PDF, directly in the user's browser instead of initiating a download. This method accepts the path to the file as its first argument and an array of headers as its second argument: return response()->file($pathToFile); return response()->file($pathToFile, $headers); Response Macros If you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use the macro method on the Response facade. For example, from a service provider's boot method: namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Support\\Facades\\Response; class ResponseMacroServiceProvider extends ServiceProvider { /* * Register the application's response macros. * * @return void / public function boot() { Response::macro('caps', function ($value) { return Response::make(strtoupper($value)); }); } } The macro function accepts a name as its first argument, and a Closure as its second. The macro's Closure will be executed when calling the macro name from a ResponseFactory implementation or the response helper: return response()->caps('foo');","title":"Response Objects"},{"location":"developerdoc/laravel_routing/#view","text":"Creating Views Looking for more information on how to write Blade templates? Check out the full Blade documentation to get started. Views contain the HTML served by your application and separate your controller / application logic from your presentation logic. Views are stored in the resources/views directory. A simple view might look something like this:","title":"View"},{"location":"developerdoc/laravel_routing/#url-generation","text":"Introduction Laravel provides several helpers to assist you in generating URLs for your application. These are mainly helpful when building links in your templates and API responses, or when generating redirect responses to another part of your application. The Basics Generating Basic URLs The url helper may be used to generate arbitrary URLs for your application. The generated URL will automatically use the scheme (HTTP or HTTPS) and host from the current request: $post = App\\Post::find(1); echo url(\"/posts/{$post->id}\"); // http://example.com/posts/1 Accessing The Current URL If no path is provided to the url helper, a Illuminate\\Routing\\UrlGenerator instance is returned, allowing you to access information about the current URL: // Get the current URL without the query string... echo url()->current(); // Get the current URL including the query string... echo url()->full(); // Get the full URL for the previous request... echo url()->previous(); Each of these methods may also be accessed via the URL facade: use Illuminate\\Support\\Facades\\URL; echo URL::current(); URLs For Named Routes The route helper may be used to generate URLs to named routes. Named routes allow you to generate URLs without being coupled to the actual URL defined on the route. Therefore, if the route's URL changes, no changes need to be made to your route function calls. For example, imagine your application contains a route defined like the following: Route::get('/post/{post}', function () { // })->name('post.show'); To generate a URL to this route, you may use the route helper like so: echo route('post.show', ['post' => 1]); // http://example.com/post/1 You will often be generating URLs using the primary key of Eloquent models. For this reason, you may pass Eloquent models as parameter values. The route helper will automatically extract the model's primary key: echo route('post.show', ['post' => $post]); The route helper may also be used to generate URLs for routes with multiple parameters: Route::get('/post/{post}/comment/{comment}', function () { // })->name('comment.show'); echo route('comment.show', ['post' => 1, 'comment' => 3]); // http://example.com/post/1/comment/3 Signed URLs Laravel allows you to easily create \"signed\" URLs to named routes. These URLs have a \"signature\" hash appended to the query string which allows Laravel to verify that the URL has not been modified since it was created. Signed URLs are especially useful for routes that are publicly accessible yet need a layer of protection against URL manipulation. For example, you might use signed URLs to implement a public \"unsubscribe\" link that is emailed to your customers. To create a signed URL to a named route, use the signedRoute method of the URL facade: use Illuminate\\Support\\Facades\\URL; return URL::signedRoute('unsubscribe', ['user' => 1]); If you would like to generate a temporary signed route URL that expires, you may use the temporarySignedRoute method: use Illuminate\\Support\\Facades\\URL; return URL::temporarySignedRoute( 'unsubscribe', now()->addMinutes(30), ['user' => 1] ); Validating Signed Route Requests To verify that an incoming request has a valid signature, you should call the hasValidSignature method on the incoming Request: use Illuminate\\Http\\Request; Route::get('/unsubscribe/{user}', function (Request $request) { if (! $request->hasValidSignature()) { abort(401); } // ... })->name('unsubscribe'); Alternatively, you may assign the Illuminate\\Routing\\Middleware\\ValidateSignature middleware to the route. If it is not already present, you should assign this middleware a key in your HTTP kernel's routeMiddleware array: /* * The application's route middleware. * * These middleware may be assigned to groups or used individually. * * @var array / protected $routeMiddleware = [ 'signed' => \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, ]; Once you have registered the middleware in your kernel, you may attach it to a route. If the incoming request does not have a valid signature, the middleware will automatically return a 403 error response: Route::post('/unsubscribe/{user}', function (Request $request) { // ... })->name('unsubscribe')->middleware('signed'); URLs For Controller Actions The action function generates a URL for the given controller action. You do not need to pass the full namespace of the controller. Instead, pass the controller class name relative to the App\\Http\\Controllers namespace: $url = action('HomeController@index'); You may also reference actions with a \"callable\" array syntax: use App\\Http\\Controllers\\HomeController; $url = action([HomeController::class, 'index']); If the controller method accepts route parameters, you may pass them as the second argument to the function: $url = action('UserController@profile', ['id' => 1]); Default Values For some applications, you may wish to specify request-wide default values for certain URL parameters. For example, imagine many of your routes define a {locale} parameter: Route::get('/{locale}/posts', function () { // })->name('post.index'); It is cumbersome to always pass the locale every time you call the route helper. So, you may use the URL::defaults method to define a default value for this parameter that will always be applied during the current request. You may wish to call this method from a route middleware so that you have access to the current request: namespace App\\Http\\Middleware; use Closure; use Illuminate\\Support\\Facades\\URL; class SetDefaultLocaleForUrls { public function handle($request, Closure $next) { URL::defaults(['locale' => $request->user()->locale]); return $next($request); } } Once the default value for the locale parameter has been set, you are no longer required to pass its value when generating URLs via the route helper.","title":"Url Generation"},{"location":"developerdoc/laravel_routing/#session","text":"Introduction Since HTTP driven applications are stateless, sessions provide a way to store information about the user across multiple requests. Laravel ships with a variety of session backends that are accessed through an expressive, unified API. Support for popular backends such as Memcached, Redis, and databases is included out of the box. Configuration The session configuration file is stored at config/session.php. Be sure to review the options available to you in this file. By default, Laravel is configured to use the file session driver, which will work well for many applications. In production applications, you may consider using the memcached or redis drivers for even faster session performance. The session driver configuration option defines where session data will be stored for each request. Laravel ships with several great drivers out of the box: file - sessions are stored in storage/framework/sessions. cookie - sessions are stored in secure, encrypted cookies. database - sessions are stored in a relational database. memcached / redis - sessions are stored in one of these fast, cache based stores. array - sessions are stored in a PHP array and will not be persisted. The array driver is used during testing and prevents the data stored in the session from being persisted. Driver Prerequisites Database When using the database session driver, you will need to create a table to contain the session items. Below is an example Schema declaration for the table: Schema::create('sessions', function ($table) { $table->string('id')->unique(); $table->unsignedInteger('user_id')->nullable(); $table->string('ip_address', 45)->nullable(); $table->text('user_agent')->nullable(); $table->text('payload'); $table->integer('last_activity'); }); You may use the session:table Artisan command to generate this migration: php artisan session:table php artisan migrate Redis Before using Redis sessions with Laravel, you will need to install the predis/predis package (~1.0) via Composer. You may configure your Redis connections in the database configuration file. In the session configuration file, the connection option may be used to specify which Redis connection is used by the session. Using The Session Retrieving Data There are two primary ways of working with session data in Laravel: the global session helper and via a Request instance. First, let's look at accessing the session via a Request instance, which can be type-hinted on a controller method. Remember, controller method dependencies are automatically injected via the Laravel service container: namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /* * Show the profile for the given user. * * @param Request $request * @param int $id * @return Response / public function show(Request $request, $id) { $value = $request->session()->get('key'); // } } When you retrieve an item from the session, you may also pass a default value as the second argument to the get method. This default value will be returned if the specified key does not exist in the session. If you pass a Closure as the default value to the get method and the requested key does not exist, the Closure will be executed and its result returned: $value = $request->session()->get('key', 'default'); $value = $request->session()->get('key', function () { return 'default'; }); The Global Session Helper You may also use the global session PHP function to retrieve and store data in the session. When the session helper is called with a single, string argument, it will return the value of that session key. When the helper is called with an array of key / value pairs, those values will be stored in the session: Route::get('home', function () { // Retrieve a piece of data from the session... $value = session('key'); // Specifying a default value... $value = session('key', 'default'); // Store a piece of data in the session... session(['key' => 'value']); }); There is little practical difference between using the session via an HTTP request instance versus using the global session helper. Both methods are testable via the assertSessionHas method which is available in all of your test cases. Retrieving All Session Data If you would like to retrieve all the data in the session, you may use the all method: $data = $request->session()->all(); Determining If An Item Exists In The Session To determine if an item is present in the session, you may use the has method. The has method returns true if the item is present and is not null: if ($request->session()->has('users')) { // } To determine if an item is present in the session, even if its value is null, you may use the exists method. The exists method returns true if the item is present: if ($request->session()->exists('users')) { // } Storing Data To store data in the session, you will typically use the put method or the session helper: // Via a request instance... $request->session()->put('key', 'value'); // Via the global helper... session(['key' => 'value']); Pushing To Array Session Values The push method may be used to push a new value onto a session value that is an array. For example, if the user.teams key contains an array of team names, you may push a new value onto the array like so: $request->session()->push('user.teams', 'developers'); Retrieving & Deleting An Item The pull method will retrieve and delete an item from the session in a single statement: $value = $request->session()->pull('key', 'default'); Flash Data Sometimes you may wish to store items in the session only for the next request. You may do so using the flash method. Data stored in the session using this method will only be available during the subsequent HTTP request, and then will be deleted. Flash data is primarily useful for short-lived status messages: $request->session()->flash('status', 'Task was successful!'); If you need to keep your flash data around for several requests, you may use the reflash method, which will keep all of the flash data for an additional request. If you only need to keep specific flash data, you may use the keep method: $request->session()->reflash(); $request->session()->keep(['username', 'email']); Deleting Data The forget method will remove a piece of data from the session. If you would like to remove all data from the session, you may use the flush method: // Forget a single key... $request->session()->forget('key'); // Forget multiple keys... $request->session()->forget(['key1', 'key2']); $request->session()->flush(); Regenerating The Session ID Regenerating the session ID is often done in order to prevent malicious users from exploiting a session fixation attack on your application. Laravel automatically regenerates the session ID during authentication if you are using the built-in LoginController; however, if you need to manually regenerate the session ID, you may use the regenerate method. $request->session()->regenerate(); Adding Custom Session Drivers Implementing The Driver Your custom session driver should implement the SessionHandlerInterface. This interface contains just a few simple methods we need to implement. A stubbed MongoDB implementation looks something like this: namespace App\\Extensions; class MongoSessionHandler implements \\SessionHandlerInterface { public function open($savePath, $sessionName) {} public function close() {} public function read($sessionId) {} public function write($sessionId, $data) {} public function destroy($sessionId) {} public function gc($lifetime) {} } Laravel does not ship with a directory to contain your extensions. You are free to place them anywhere you like. In this example, we have created an Extensions directory to house the MongoSessionHandler. Since the purpose of these methods is not readily understandable, let's quickly cover what each of the methods do: The open method would typically be used in file based session store systems. Since Laravel ships with a file session driver, you will almost never need to put anything in this method. You can leave it as an empty stub. It is a fact of poor interface design (which we'll discuss later) that PHP requires us to implement this method. The close method, like the open method, can also usually be disregarded. For most drivers, it is not needed. The read method should return the string version of the session data associated with the given $sessionId. There is no need to do any serialization or other encoding when retrieving or storing session data in your driver, as Laravel will perform the serialization for you. The write method should write the given $data string associated with the $sessionId to some persistent storage system, such as MongoDB, Dynamo, etc. Again, you should not perform any serialization - Laravel will have already handled that for you. The destroy method should remove the data associated with the $sessionId from persistent storage. The gc method should destroy all session data that is older than the given $lifetime, which is a UNIX timestamp. For self-expiring systems like Memcached and Redis, this method may be left empty. Registering The Driver Once your driver has been implemented, you are ready to register it with the framework. To add additional drivers to Laravel's session backend, you may use the extend method on the Session facade. You should call the extend method from the boot method of a service provider. You may do this from the existing AppServiceProvider or create an entirely new provider: namespace App\\Providers; use App\\Extensions\\MongoSessionHandler; use Illuminate\\Support\\Facades\\Session; use Illuminate\\Support\\ServiceProvider; class SessionServiceProvider extends ServiceProvider { /* * Register bindings in the container. * * @return void / public function register() { // } /** * Bootstrap any application services. * * @return void */ public function boot() { Session::extend('mongo', function ($app) { // Return implementation of SessionHandlerInterface... return new MongoSessionHandler; }); } } Once the session driver has been registered, you may use the mongo driver in your config/session.php configuration file.","title":"Session"},{"location":"developerdoc/laravel_routing/#validation","text":"Introduction Laravel provides several different approaches to validate your application's incoming data. By default, Laravel's base controller class uses a ValidatesRequests trait which provides a convenient method to validate incoming HTTP request with a variety of powerful validation rules. Validation Quickstart To learn about Laravel's powerful validation features, let's look at a complete example of validating a form and displaying the error messages back to the user. Defining The Routes First, let's assume we have the following routes defined in our routes/web.php file: Route::get('post/create', 'PostController@create'); Route::post('post', 'PostController@store'); The GET route will display a form for the user to create a new blog post, while the POST route will store the new blog post in the database. Creating The Controller Next, let's take a look at a simple controller that handles these routes. We'll leave the store method empty for now: namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class PostController extends Controller { /* * Show the form to create a new blog post. * * @return Response / public function create() { return view('post.create'); } /** * Store a new blog post. * * @param Request $request * @return Response */ public function store(Request $request) { // Validate and store the blog post... } } Writing The Validation Logic Now we are ready to fill in our store method with the logic to validate the new blog post. To do this, we will use the validate method provided by the Illuminate\\Http\\Request object. If the validation rules pass, your code will keep executing normally; however, if validation fails, an exception will be thrown and the proper error response will automatically be sent back to the user. In the case of a traditional HTTP request, a redirect response will be generated, while a JSON response will be sent for AJAX requests. To get a better understanding of the validate method, let's jump back into the store method: /* * Store a new blog post. * * @param Request $request * @return Response / public function store(Request $request) { $validatedData = $request->validate([ 'title' => 'required|unique:posts|max:255', 'body' => 'required', ]); // The blog post is valid... } As you can see, we pass the desired validation rules into the validate method. Again, if the validation fails, the proper response will automatically be generated. If the validation passes, our controller will continue executing normally. Stopping On First Validation Failure Sometimes you may wish to stop running validation rules on an attribute after the first validation failure. To do so, assign the bail rule to the attribute: $request->validate([ 'title' => 'bail|required|unique:posts|max:255', 'body' => 'required', ]); In this example, if the unique rule on the title attribute fails, the max rule will not be checked. Rules will be validated in the order they are assigned. A Note On Nested Attributes If your HTTP request contains \"nested\" parameters, you may specify them in your validation rules using \"dot\" syntax: $request->validate([ 'title' => 'required|unique:posts|max:255', 'author.name' => 'required', 'author.description' => 'required', ]); Displaying The Validation Errors So, what if the incoming request parameters do not pass the given validation rules? As mentioned previously, Laravel will automatically redirect the user back to their previous location. In addition, all of the validation errors will automatically be flashed to the session. Again, notice that we did not have to explicitly bind the error messages to the view in our GET route. This is because Laravel will check for errors in the session data, and automatically bind them to the view if they are available. The $errors variable will be an instance of Illuminate\\Support\\MessageBag. For more information on working with this object, check out its documentation. The $errors variable is bound to the view by the Illuminate\\View\\Middleware\\ShareErrorsFromSession middleware, which is provided by the web middleware group. When this middleware is applied an $errors variable will always be available in your views, allowing you to conveniently assume the $errors variable is always defined and can be safely used. So, in our example, the user will be redirected to our controller's create method when validation fails, allowing us to display the error messages in the view:","title":"Validation"},{"location":"developerdoc/laravel_routing/#error-handling","text":"Introduction When you start a new Laravel project, error and exception handling is already configured for you. The App\\Exceptions\\Handler class is where all exceptions triggered by your application are logged and then rendered back to the user. We'll dive deeper into this class throughout this documentation. Configuration The debug option in your config/app.php configuration file determines how much information about an error is actually displayed to the user. By default, this option is set to respect the value of the APP_DEBUG environment variable, which is stored in your .env file. For local development, you should set the APP_DEBUG environment variable to true. In your production environment, this value should always be false. If the value is set to true in production, you risk exposing sensitive configuration values to your application's end users. The Exception Handler The Report Method All exceptions are handled by the App\\Exceptions\\Handler class. This class contains two methods: report and render. We'll examine each of these methods in detail. The report method is used to log exceptions or send them to an external service like Bugsnag or Sentry. By default, the report method passes the exception to the base class where the exception is logged. However, you are free to log exceptions however you wish. For example, if you need to report different types of exceptions in different ways, you may use the PHP instanceof comparison operator: /* * Report or log an exception. * * This is a great spot to send exceptions to Sentry, Bugsnag, etc. * * @param \\Exception $exception * @return void / public function report(Exception $exception) { if ($exception instanceof CustomException) { // } parent::report($exception); } Instead of making a lot of instanceof checks in your report method, consider using reportable exceptions Global Log Context If available, Laravel automatically adds the current user's ID to every exception's log message as contextual data. You may define your own global contextual data by overriding the context method of your application's App\\Exceptions\\Handler class. This information will be included in every exception's log message written by your application: /* * Get the default context variables for logging. * * @return array / protected function context() { return array_merge(parent::context(), [ 'foo' => 'bar', ]); } The report Helper Sometimes you may need to report an exception but continue handling the current request. The report helper function allows you to quickly report an exception using your exception handler's report method without rendering an error page: public function isValid($value) { try { // Validate the value... } catch (Exception $e) { report($e); return false; } } Ignoring Exceptions By Type The $dontReport property of the exception handler contains an array of exception types that will not be logged. For example, exceptions resulting from 404 errors, as well as several other types of errors, are not written to your log files. You may add other exception types to this array as needed: /* * A list of the exception types that should not be reported. * * @var array / protected $dontReport = [ \\Illuminate\\Auth\\AuthenticationException::class, \\Illuminate\\Auth\\Access\\AuthorizationException::class, \\Symfony\\Component\\HttpKernel\\Exception\\HttpException::class, \\Illuminate\\Database\\Eloquent\\ModelNotFoundException::class, \\Illuminate\\Validation\\ValidationException::class, ]; The Render Method The render method is responsible for converting a given exception into an HTTP response that should be sent back to the browser. By default, the exception is passed to the base class which generates a response for you. However, you are free to check the exception type or return your own custom response: /* * Render an exception into an HTTP response. * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $exception * @return \\Illuminate\\Http\\Response / public function render($request, Exception $exception) { if ($exception instanceof CustomException) { return response()->view('errors.custom', [], 500); } return parent::render($request, $exception); } Reportable & Renderable Exceptions Instead of type-checking exceptions in the exception handler's report and render methods, you may define report and render methods directly on your custom exception. When these methods exist, they will be called automatically by the framework: namespace App\\Exceptions; use Exception; class RenderException extends Exception { /* * Report the exception. * * @return void / public function report() { // } /** * Render the exception into an HTTP response. * * @param \\Illuminate\\Http\\Request * @return \\Illuminate\\Http\\Response */ public function render($request) { return response(...); } } You may type-hint any required dependencies of the report method and they will automatically be injected into the method by Laravel's service container. HTTP Exceptions Some exceptions describe HTTP error codes from the server. For example, this may be a \"page not found\" error (404), an \"unauthorized error\" (401) or even a developer generated 500 error. In order to generate such a response from anywhere in your application, you may use the abort helper: abort(404); The abort helper will immediately raise an exception which will be rendered by the exception handler. Optionally, you may provide the response text: abort(403, 'Unauthorized action.'); Custom HTTP Error Pages Laravel makes it easy to display custom error pages for various HTTP status codes. For example, if you wish to customize the error page for 404 HTTP status codes, create a resources/views/errors/404.blade.php. This file will be served on all 404 errors generated by your application. The views within this directory should be named to match the HTTP status code they correspond to. The HttpException instance raised by the abort function will be passed to the view as an $exception variable:","title":"Error Handling"},{"location":"developerdoc/laravel_routing/#logging","text":"Introduction To help you learn more about what's happening within your application, Laravel provides robust logging services that allow you to log messages to files, the system error log, and even to Slack to notify your entire team. Under the hood, Laravel utilizes the Monolog library, which provides support for a variety of powerful log handlers. Laravel makes it a cinch to configure these handlers, allowing you to mix and match them to customize your application's log handling. Configuration All of the configuration for your application's logging system is housed in the config/logging.php configuration file. This file allows you to configure your application's log channels, so be sure to review each of the available channels and their options. We'll review a few common options below. By default, Laravel will use the stack channel when logging messages. The stack channel is used to aggregate multiple log channels into a single channel. For more information on building stacks, check out the documentation below. Configuring The Channel Name By default, Monolog is instantiated with a \"channel name\" that matches the current environment, such as production or local. To change this value, add a name option to your channel's configuration: 'stack' => [ 'driver' => 'stack', 'name' => 'channel-name', 'channels' => ['single', 'slack'], ], Available Channel Drivers Name Description stack A wrapper to facilitate creating \"multi-channel\" channels single A single file or path based logger channel (StreamHandler) daily A RotatingFileHandler based Monolog driver which rotates daily slack A SlackWebhookHandler based Monolog driver papertrail A SyslogUdpHandler based Monolog driver syslog A SyslogHandler based Monolog driver errorlog A ErrorLogHandler based Monolog driver monolog A Monolog factory driver that may use any supported Monolog handler custom A driver that calls a specified factory to create a channel Check out the documentation on advanced channel customization to learn more about the monolog and custom drivers. Configuring The Single and Daily Channels The single and daily channels have three optional configuration options: bubble, permission, and locking. Name Description Default bubble Indicates if messages should bubble up to other channels after being handled true permission The log file's permissions 0644 locking Attempt to lock the log file before writing to it false Configuring The Papertrail Channel The papertrail channel requires the url and port configuration options. You can obtain these values from Papertrail. Configuring The Slack Channel The slack channel requires a url configuration option. This URL should match a URL for an incoming webhook that you have configured for your Slack team. Building Log Stacks As previously mentioned, the stack driver allows you to combine multiple channels into a single log channel. To illustrate how to use log stacks, let's take a look at an example configuration that you might see in a production application: 'channels' => [ 'stack' => [ 'driver' => 'stack', 'channels' => ['syslog', 'slack'], ], 'syslog' => [ 'driver' => 'syslog', 'level' => 'debug', ], 'slack' => [ 'driver' => 'slack', 'url' => env('LOG_SLACK_WEBHOOK_URL'), 'username' => 'Laravel Log', 'emoji' => ':boom:', 'level' => 'critical', ], ], Let's dissect this configuration. First, notice our stack channel aggregates two other channels via its channels option: syslog and slack. So, when logging messages, both of these channels will have the opportunity to log the message. Log Levels Take note of the level configuration option present on the syslog and slack channel configurations in the example above. This option determines the minimum \"level\" a message must be in order to be logged by the channel. Monolog, which powers Laravel's logging services, offers all of the log levels defined in the RFC 5424 specification: emergency, alert, critical, error, warning, notice, info, and debug. So, imagine we log a message using the debug method: Log::debug('An informational message.'); Given our configuration, the syslog channel will write the message to the system log; however, since the error message is not critical or above, it will not be sent to Slack. However, if we log an emergency message, it will be sent to both the system log and Slack since the emergency level is above our minimum level threshold for both channels: Log::emergency('The system is down!'); Writing Log Messages You may write information to the logs using the Log facade. As previously mentioned, the logger provides the eight logging levels defined in the RFC 5424 specification: emergency, alert, critical, error, warning, notice, info and debug: Log::emergency($message); Log::alert($message); Log::critical($message); Log::error($message); Log::warning($message); Log::notice($message); Log::info($message); Log::debug($message); So, you may call any of these methods to log a message for the corresponding level. By default, the message will be written to the default log channel as configured by your config/logging.php configuration file: namespace App\\Http\\Controllers; use App\\User; use Illuminate\\Support\\Facades\\Log; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /* * Show the profile for the given user. * * @param int $id * @return Response / public function showProfile($id) { Log::info('Showing user profile for user: '.$id); return view('user.profile', ['user' => User::findOrFail($id)]); } } Contextual Information An array of contextual data may also be passed to the log methods. This contextual data will be formatted and displayed with the log message: Log::info('User failed to login.', ['id' => $user->id]); Writing To Specific Channels Sometimes you may wish to log a message to a channel other than your application's default channel. You may use the channel method on the Log facade to retrieve and log to any channel defined in your configuration file: Log::channel('slack')->info('Something happened!'); If you would like to create an on-demand logging stack consisting of multiple channels, you may use the stack method: Log::stack(['single', 'slack'])->info('Something happened!'); Advanced Monolog Channel Customization Customizing Monolog For Channels Sometimes you may need complete control over how Monolog is configured for an existing channel. For example, you may want to configure a custom Monolog FormatterInterface implementation for a given channel's handlers. To get started, define a tap array on the channel's configuration. The tap array should contain a list of classes that should have an opportunity to customize (or \"tap\" into) the Monolog instance after it is created: 'single' => [ 'driver' => 'single', 'tap' => [App\\Logging\\CustomizeFormatter::class], 'path' => storage_path('logs/laravel.log'), 'level' => 'debug', ], Once you have configured the tap option on your channel, you're ready to define the class that will customize your Monolog instance. This class only needs a single method: __invoke, which receives an Illuminate\\Log\\Logger instance. The Illuminate\\Log\\Logger instance proxies all method calls to the underlying Monolog instance: namespace App\\Logging; class CustomizeFormatter { /* * Customize the given logger instance. * * @param \\Illuminate\\Log\\Logger $logger * @return void / public function __invoke($logger) { foreach ($logger->getHandlers() as $handler) { $handler->setFormatter(...); } } } All of your \"tap\" classes are resolved by the service container, so any constructor dependencies they require will automatically be injected. Creating Monolog Handler Channels Monolog has a variety of available handlers. In some cases, the type of logger you wish to create is merely a Monolog driver with an instance of a specific handler. These channels can be created using the monolog driver. When using the monolog driver, the handler configuration option is used to specify which handler will be instantiated. Optionally, any constructor parameters the handler needs may be specified using the with configuration option: 'logentries' => [ 'driver' => 'monolog', 'handler' => Monolog\\Handler\\SyslogUdpHandler::class, 'with' => [ 'host' => 'my.logentries.internal.datahubhost.company.com', 'port' => '10000', ], ], Monolog Formatters When using the monolog driver, the Monolog LineFormatter will be used as the default formatter. However, you may customize the type of formatter passed to the handler using the formatter and formatter_with configuration options: 'browser' => [ 'driver' => 'monolog', 'handler' => Monolog\\Handler\\BrowserConsoleHandler::class, 'formatter' => Monolog\\Formatter\\HtmlFormatter::class, 'formatter_with' => [ 'dateFormat' => 'Y-m-d', ], ], If you are using a Monolog handler that is capable of providing its own formatter, you may set the value of the formatter configuration option to default: 'newrelic' => [ 'driver' => 'monolog', 'handler' => Monolog\\Handler\\NewRelicHandler::class, 'formatter' => 'default', ], Creating Channels Via Factories If you would like to define an entirely custom channel in which you have full control over Monolog's instantiation and configuration, you may specify a custom driver type in your config/logging.php configuration file. Your configuration should include a via option to point to the factory class which will be invoked to create the Monolog instance: 'channels' => [ 'custom' => [ 'driver' => 'custom', 'via' => App\\Logging\\CreateCustomLogger::class, ], ], Once you have configured the custom channel, you're ready to define the class that will create your Monolog instance. This class only needs a single method: __invoke, which should return the Monolog instance: namespace App\\Logging; use Monolog\\Logger; class CreateCustomLogger { /* * Create a custom Monolog instance. * * @param array $config * @return \\Monolog\\Logger / public function __invoke(array $config) { return new Logger(...); } }","title":"Logging"},{"location":"developerdoc/laravel_schedule/","text":"Laravel Schedule Introduction In the past, you may have generated a Cron entry for each task you needed to schedule on your server. However, this can quickly become a pain, because your task schedule is no longer in source control and you must SSH into your server to add additional Cron entries. Laravel's command scheduler allows you to fluently and expressively define your command schedule within Laravel itself. When using the scheduler, only a single Cron entry is needed on your server. Your task schedule is defined in the app/Console/Kernel.php file's schedule method. To help you get started, a simple example is defined within the method. Starting The Scheduler When using the scheduler, you only need to add the following Cron entry to your server. If you do not know how to add Cron entries to your server, consider using a service such as Laravel Forge which can manage the Cron entries for you: cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1 This Cron will call the Laravel command scheduler every minute. When the schedule:run command is executed, Laravel will evaluate your scheduled tasks and runs the tasks that are due. Defining Schedules You may define all of your scheduled tasks in the schedule method of the App\\Console\\Kernel class. To get started, let's look at an example of scheduling a task. In this example, we will schedule a Closure to be called every day at midnight. Within the Closure we will execute a database query to clear a table: namespace App\\Console; use Illuminate\\Support\\Facades\\DB; use Illuminate\\Console\\Scheduling\\Schedule; use Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel; class Kernel extends ConsoleKernel { /* * The Artisan commands provided by your application. * * @var array / protected $commands = [ // ]; /** * Define the application's command schedule. * * @param \\Illuminate\\Console\\Scheduling\\Schedule $schedule * @return void */ protected function schedule(Schedule $schedule) { $schedule->call(function () { DB::table('recent_users')->delete(); })->daily(); } } In addition to scheduling using Closures, you may also use invokable objects. Invokable objects are simple PHP classes that contain an __invoke method: $schedule->call(new DeleteRecentUsers)->daily(); Scheduling Artisan Commands In addition to scheduling Closure calls, you may also schedule Artisan commands and operating system commands. For example, you may use the command method to schedule an Artisan command using either the command's name or class: $schedule->command('emails:send Taylor --force')->daily(); $schedule->command(EmailsCommand::class, ['Taylor', '--force'])->daily(); Scheduling Queued Jobs The job method may be used to schedule a queued job. This method provides a convenient way to schedule jobs without using the call method to manually create Closures to queue the job: $schedule->job(new Heartbeat)->everyFiveMinutes(); // Dispatch the job to the \"heartbeats\" queue... $schedule->job(new Heartbeat, 'heartbeats')->everyFiveMinutes(); Scheduling Shell Commands The exec method may be used to issue a command to the operating system: $schedule->exec('node /home/forge/script.js')->daily(); Schedule Frequency Options There are a variety of schedules you may assign to your task: Method Description ->cron(' * * *'); Run the task on a custom Cron schedule ->everyMinute(); Run the task every minute ->everyFiveMinutes(); Run the task every five minutes ->everyTenMinutes(); Run the task every ten minutes ->everyFifteenMinutes(); Run the task every fifteen minutes ->everyThirtyMinutes(); Run the task every thirty minutes ->hourly(); Run the task every hour ->hourlyAt(17); Run the task every hour at 17 mins past the hour ->daily(); Run the task every day at midnight ->dailyAt('13:00'); Run the task every day at 13:00 ->twiceDaily(1, 13); Run the task daily at 1:00 & 13:00 ->weekly(); Run the task every week ->weeklyOn(1, '8:00'); Run the task every week on Monday at 8:00 ->monthly(); Run the task every month ->monthlyOn(4, '15:00'); Run the task every month on the 4th at 15:00 ->quarterly(); Run the task every quarter ->yearly(); Run the task every year ->timezone('America/New_York'); Set the timezone These methods may be combined with additional constraints to create even more finely tuned schedules that only run on certain days of the week. For example, to schedule a command to run weekly on Monday: // Run once per week on Monday at 1 PM... $schedule->call(function () { // })->weekly()->mondays()->at('13:00'); // Run hourly from 8 AM to 5 PM on weekdays... $schedule->command('foo') ->weekdays() ->hourly() ->timezone('America/Chicago') ->between('8:00', '17:00'); Below is a list of the additional schedule constraints: Method Description ->weekdays(); Limit the task to weekdays ->weekends(); Limit the task to weekends ->sundays(); Limit the task to Sunday ->mondays(); Limit the task to Monday ->tuesdays(); Limit the task to Tuesday ->wednesdays(); Limit the task to Wednesday ->thursdays(); Limit the task to Thursday ->fridays(); Limit the task to Friday ->saturdays(); Limit the task to Saturday ->between($start, $end); Limit the task to run between start and end times ->when(Closure); Limit the task based on a truth test ->environments($env); Limit the task to specific environments Between Time Constraints The between method may be used to limit the execution of a task based on the time of day: $schedule->command('reminders:send') ->hourly() ->between('7:00', '22:00'); Similarly, the unlessBetween method can be used to exclude the execution of a task for a period of time: $schedule->command('reminders:send') ->hourly() ->unlessBetween('23:00', '4:00'); Truth Test Constraints The when method may be used to limit the execution of a task based on the result of a given truth test. In other words, if the given Closure returns true, the task will execute as long as no other constraining conditions prevent the task from running: $schedule->command('emails:send')->daily()->when(function () { return true; }); The skip method may be seen as the inverse of when. If the skip method returns true, the scheduled task will not be executed: $schedule->command('emails:send')->daily()->skip(function () { return true; }); When using chained when methods, the scheduled command will only execute if all when conditions return true. Environment Constraints The environments method may be used to execute tasks only on the given environments: $schedule->command('emails:send') ->daily() ->environments(['staging', 'production']); Timezones Using the timezone method, you may specify that a scheduled task's time should be interpreted within a given timezone: $schedule->command('report:generate') ->timezone('America/New_York') ->at('02:00') If you are assigning the same timezone to all of your scheduled tasks, you may wish to define a scheduleTimezone method in your app/Console/Kernel.php file. This method should return the default timezone that should be assigned to all scheduled tasks: /* * Get the timezone that should be used by default for scheduled events. * * @return \\DateTimeZone|string|null / protected function scheduleTimezone() { return 'America/Chicago'; } Remember that some timezones utilize daylight savings time. When daylight saving time changes occur, your scheduled task may run twice or even not run at all. For this reason, we recommend avoiding timezone scheduling when possible. Preventing Task Overlaps By default, scheduled tasks will be run even if the previous instance of the task is still running. To prevent this, you may use the withoutOverlapping method: $schedule->command('emails:send')->withoutOverlapping(); In this example, the emails:send Artisan command will be run every minute if it is not already running. The withoutOverlapping method is especially useful if you have tasks that vary drastically in their execution time, preventing you from predicting exactly how long a given task will take. If needed, you may specify how many minutes must pass before the \"without overlapping\" lock expires. By default, the lock will expire after 24 hours: $schedule->command('emails:send')->withoutOverlapping(10); Running Tasks On One Server To utilize this feature, your application must be using the memcached or redis cache driver as your application's default cache driver. In addition, all servers must be communicating with the same central cache server. If your application is running on multiple servers, you may limit a scheduled job to only execute on a single server. For instance, assume you have a scheduled task that generates a new report every Friday night. If the task scheduler is running on three worker servers, the scheduled task will run on all three servers and generate the report three times. Not good! To indicate that the task should run on only one server, use the onOneServer method when defining the scheduled task. The first server to obtain the task will secure an atomic lock on the job to prevent other servers from running the same task at the same time: $schedule->command('report:generate') ->fridays() ->at('17:00') ->onOneServer(); Background Tasks By default, multiple commands scheduled at the same time will execute sequentially. If you have long-running commands, this may cause subsequent commands to start much later than anticipated. If you would like to run commands in the background so that they may all run simultaneously, you may use the runInBackground method: $schedule->command('analytics:report') ->daily() ->runInBackground(); The runInBackground method may only be used when scheduling tasks via the command and exec methods. Maintenance Mode Laravel's scheduled tasks will not run when Laravel is in maintenance mode, since we don't want your tasks to interfere with any unfinished maintenance you may be performing on your server. However, if you would like to force a task to run even in maintenance mode, you may use the evenInMaintenanceMode method: $schedule->command('emails:send')->evenInMaintenanceMode(); Task Output The Laravel scheduler provides several convenient methods for working with the output generated by scheduled tasks. First, using the sendOutputTo method, you may send the output to a file for later inspection: $schedule->command('emails:send') ->daily() ->sendOutputTo($filePath); If you would like to append the output to a given file, you may use the appendOutputTo method: $schedule->command('emails:send') ->daily() ->appendOutputTo($filePath); Using the emailOutputTo method, you may e-mail the output to an e-mail address of your choice. Before e-mailing the output of a task, you should configure Laravel's e-mail services: $schedule->command('foo') ->daily() ->sendOutputTo($filePath) ->emailOutputTo('foo@example.com'); If you only want to e-mail the output if the command fails, use the emailOutputOnFailure method: $schedule->command('foo') ->daily() ->emailOutputOnFailure('foo@example.com'); The emailOutputTo, emailOutputOnFailure, sendOutputTo, and appendOutputTo methods are exclusive to the command and exec methods. Task Hooks Using the before and after methods, you may specify code to be executed before and after the scheduled task is complete: $schedule->command('emails:send') ->daily() ->before(function () { // Task is about to start... }) ->after(function () { // Task is complete... }); The onSuccess and onFailure methods allow you to specify code to be executed if the scheduled task succeeds or fails: $schedule->command('emails:send') ->daily() ->onSuccess(function () { // The task succeeded... }) ->onFailure(function () { // The task failed... }); Pinging URLs Using the pingBefore and thenPing methods, the scheduler can automatically ping a given URL before or after a task is complete. This method is useful for notifying an external service, such as Laravel Envoyer, that your scheduled task is commencing or has finished execution: $schedule->command('emails:send') ->daily() ->pingBefore($url) ->thenPing($url); The pingBeforeIf and thenPingIf methods may be used to ping a given URL only if the given condition is true: $schedule->command('emails:send') ->daily() ->pingBeforeIf($condition, $url) ->thenPingIf($condition, $url); The pingOnSuccess and pingOnFailure methods may be used to ping a given URL only if the task succeeds or fails: $schedule->command('emails:send') ->daily() ->pingOnSuccess($successUrl) ->pingOnFailure($failureUrl); All of the ping methods require the Guzzle HTTP library. You can add Guzzle to your project using the Composer package manager: composer require guzzlehttp/guzzle","title":"Laravel Schedule"},{"location":"developerdoc/laravel_schedule/#laravel-schedule","text":"Introduction In the past, you may have generated a Cron entry for each task you needed to schedule on your server. However, this can quickly become a pain, because your task schedule is no longer in source control and you must SSH into your server to add additional Cron entries. Laravel's command scheduler allows you to fluently and expressively define your command schedule within Laravel itself. When using the scheduler, only a single Cron entry is needed on your server. Your task schedule is defined in the app/Console/Kernel.php file's schedule method. To help you get started, a simple example is defined within the method. Starting The Scheduler When using the scheduler, you only need to add the following Cron entry to your server. If you do not know how to add Cron entries to your server, consider using a service such as Laravel Forge which can manage the Cron entries for you: cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1 This Cron will call the Laravel command scheduler every minute. When the schedule:run command is executed, Laravel will evaluate your scheduled tasks and runs the tasks that are due. Defining Schedules You may define all of your scheduled tasks in the schedule method of the App\\Console\\Kernel class. To get started, let's look at an example of scheduling a task. In this example, we will schedule a Closure to be called every day at midnight. Within the Closure we will execute a database query to clear a table: namespace App\\Console; use Illuminate\\Support\\Facades\\DB; use Illuminate\\Console\\Scheduling\\Schedule; use Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel; class Kernel extends ConsoleKernel { /* * The Artisan commands provided by your application. * * @var array / protected $commands = [ // ]; /** * Define the application's command schedule. * * @param \\Illuminate\\Console\\Scheduling\\Schedule $schedule * @return void */ protected function schedule(Schedule $schedule) { $schedule->call(function () { DB::table('recent_users')->delete(); })->daily(); } } In addition to scheduling using Closures, you may also use invokable objects. Invokable objects are simple PHP classes that contain an __invoke method: $schedule->call(new DeleteRecentUsers)->daily(); Scheduling Artisan Commands In addition to scheduling Closure calls, you may also schedule Artisan commands and operating system commands. For example, you may use the command method to schedule an Artisan command using either the command's name or class: $schedule->command('emails:send Taylor --force')->daily(); $schedule->command(EmailsCommand::class, ['Taylor', '--force'])->daily(); Scheduling Queued Jobs The job method may be used to schedule a queued job. This method provides a convenient way to schedule jobs without using the call method to manually create Closures to queue the job: $schedule->job(new Heartbeat)->everyFiveMinutes(); // Dispatch the job to the \"heartbeats\" queue... $schedule->job(new Heartbeat, 'heartbeats')->everyFiveMinutes(); Scheduling Shell Commands The exec method may be used to issue a command to the operating system: $schedule->exec('node /home/forge/script.js')->daily(); Schedule Frequency Options There are a variety of schedules you may assign to your task: Method Description ->cron(' * * *'); Run the task on a custom Cron schedule ->everyMinute(); Run the task every minute ->everyFiveMinutes(); Run the task every five minutes ->everyTenMinutes(); Run the task every ten minutes ->everyFifteenMinutes(); Run the task every fifteen minutes ->everyThirtyMinutes(); Run the task every thirty minutes ->hourly(); Run the task every hour ->hourlyAt(17); Run the task every hour at 17 mins past the hour ->daily(); Run the task every day at midnight ->dailyAt('13:00'); Run the task every day at 13:00 ->twiceDaily(1, 13); Run the task daily at 1:00 & 13:00 ->weekly(); Run the task every week ->weeklyOn(1, '8:00'); Run the task every week on Monday at 8:00 ->monthly(); Run the task every month ->monthlyOn(4, '15:00'); Run the task every month on the 4th at 15:00 ->quarterly(); Run the task every quarter ->yearly(); Run the task every year ->timezone('America/New_York'); Set the timezone These methods may be combined with additional constraints to create even more finely tuned schedules that only run on certain days of the week. For example, to schedule a command to run weekly on Monday: // Run once per week on Monday at 1 PM... $schedule->call(function () { // })->weekly()->mondays()->at('13:00'); // Run hourly from 8 AM to 5 PM on weekdays... $schedule->command('foo') ->weekdays() ->hourly() ->timezone('America/Chicago') ->between('8:00', '17:00'); Below is a list of the additional schedule constraints: Method Description ->weekdays(); Limit the task to weekdays ->weekends(); Limit the task to weekends ->sundays(); Limit the task to Sunday ->mondays(); Limit the task to Monday ->tuesdays(); Limit the task to Tuesday ->wednesdays(); Limit the task to Wednesday ->thursdays(); Limit the task to Thursday ->fridays(); Limit the task to Friday ->saturdays(); Limit the task to Saturday ->between($start, $end); Limit the task to run between start and end times ->when(Closure); Limit the task based on a truth test ->environments($env); Limit the task to specific environments Between Time Constraints The between method may be used to limit the execution of a task based on the time of day: $schedule->command('reminders:send') ->hourly() ->between('7:00', '22:00'); Similarly, the unlessBetween method can be used to exclude the execution of a task for a period of time: $schedule->command('reminders:send') ->hourly() ->unlessBetween('23:00', '4:00'); Truth Test Constraints The when method may be used to limit the execution of a task based on the result of a given truth test. In other words, if the given Closure returns true, the task will execute as long as no other constraining conditions prevent the task from running: $schedule->command('emails:send')->daily()->when(function () { return true; }); The skip method may be seen as the inverse of when. If the skip method returns true, the scheduled task will not be executed: $schedule->command('emails:send')->daily()->skip(function () { return true; }); When using chained when methods, the scheduled command will only execute if all when conditions return true. Environment Constraints The environments method may be used to execute tasks only on the given environments: $schedule->command('emails:send') ->daily() ->environments(['staging', 'production']); Timezones Using the timezone method, you may specify that a scheduled task's time should be interpreted within a given timezone: $schedule->command('report:generate') ->timezone('America/New_York') ->at('02:00') If you are assigning the same timezone to all of your scheduled tasks, you may wish to define a scheduleTimezone method in your app/Console/Kernel.php file. This method should return the default timezone that should be assigned to all scheduled tasks: /* * Get the timezone that should be used by default for scheduled events. * * @return \\DateTimeZone|string|null / protected function scheduleTimezone() { return 'America/Chicago'; } Remember that some timezones utilize daylight savings time. When daylight saving time changes occur, your scheduled task may run twice or even not run at all. For this reason, we recommend avoiding timezone scheduling when possible. Preventing Task Overlaps By default, scheduled tasks will be run even if the previous instance of the task is still running. To prevent this, you may use the withoutOverlapping method: $schedule->command('emails:send')->withoutOverlapping(); In this example, the emails:send Artisan command will be run every minute if it is not already running. The withoutOverlapping method is especially useful if you have tasks that vary drastically in their execution time, preventing you from predicting exactly how long a given task will take. If needed, you may specify how many minutes must pass before the \"without overlapping\" lock expires. By default, the lock will expire after 24 hours: $schedule->command('emails:send')->withoutOverlapping(10); Running Tasks On One Server To utilize this feature, your application must be using the memcached or redis cache driver as your application's default cache driver. In addition, all servers must be communicating with the same central cache server. If your application is running on multiple servers, you may limit a scheduled job to only execute on a single server. For instance, assume you have a scheduled task that generates a new report every Friday night. If the task scheduler is running on three worker servers, the scheduled task will run on all three servers and generate the report three times. Not good! To indicate that the task should run on only one server, use the onOneServer method when defining the scheduled task. The first server to obtain the task will secure an atomic lock on the job to prevent other servers from running the same task at the same time: $schedule->command('report:generate') ->fridays() ->at('17:00') ->onOneServer(); Background Tasks By default, multiple commands scheduled at the same time will execute sequentially. If you have long-running commands, this may cause subsequent commands to start much later than anticipated. If you would like to run commands in the background so that they may all run simultaneously, you may use the runInBackground method: $schedule->command('analytics:report') ->daily() ->runInBackground(); The runInBackground method may only be used when scheduling tasks via the command and exec methods. Maintenance Mode Laravel's scheduled tasks will not run when Laravel is in maintenance mode, since we don't want your tasks to interfere with any unfinished maintenance you may be performing on your server. However, if you would like to force a task to run even in maintenance mode, you may use the evenInMaintenanceMode method: $schedule->command('emails:send')->evenInMaintenanceMode(); Task Output The Laravel scheduler provides several convenient methods for working with the output generated by scheduled tasks. First, using the sendOutputTo method, you may send the output to a file for later inspection: $schedule->command('emails:send') ->daily() ->sendOutputTo($filePath); If you would like to append the output to a given file, you may use the appendOutputTo method: $schedule->command('emails:send') ->daily() ->appendOutputTo($filePath); Using the emailOutputTo method, you may e-mail the output to an e-mail address of your choice. Before e-mailing the output of a task, you should configure Laravel's e-mail services: $schedule->command('foo') ->daily() ->sendOutputTo($filePath) ->emailOutputTo('foo@example.com'); If you only want to e-mail the output if the command fails, use the emailOutputOnFailure method: $schedule->command('foo') ->daily() ->emailOutputOnFailure('foo@example.com'); The emailOutputTo, emailOutputOnFailure, sendOutputTo, and appendOutputTo methods are exclusive to the command and exec methods. Task Hooks Using the before and after methods, you may specify code to be executed before and after the scheduled task is complete: $schedule->command('emails:send') ->daily() ->before(function () { // Task is about to start... }) ->after(function () { // Task is complete... }); The onSuccess and onFailure methods allow you to specify code to be executed if the scheduled task succeeds or fails: $schedule->command('emails:send') ->daily() ->onSuccess(function () { // The task succeeded... }) ->onFailure(function () { // The task failed... }); Pinging URLs Using the pingBefore and thenPing methods, the scheduler can automatically ping a given URL before or after a task is complete. This method is useful for notifying an external service, such as Laravel Envoyer, that your scheduled task is commencing or has finished execution: $schedule->command('emails:send') ->daily() ->pingBefore($url) ->thenPing($url); The pingBeforeIf and thenPingIf methods may be used to ping a given URL only if the given condition is true: $schedule->command('emails:send') ->daily() ->pingBeforeIf($condition, $url) ->thenPingIf($condition, $url); The pingOnSuccess and pingOnFailure methods may be used to ping a given URL only if the task succeeds or fails: $schedule->command('emails:send') ->daily() ->pingOnSuccess($successUrl) ->pingOnFailure($failureUrl); All of the ping methods require the Guzzle HTTP library. You can add Guzzle to your project using the Composer package manager: composer require guzzlehttp/guzzle","title":"Laravel Schedule"},{"location":"developerdoc/tugas/","text":"Tugas Latihan Tugas 1 Install software yang dibutuhkan untuk development Laravel di masing-masing PC. Tugas 2 Buat GIT Repository Project Laravel tentang sistem perpustakaan di Git Server artemisdev.polytron.co.id:3000. Spesifikasi aplikasi Sistem Perpustakaan sebagai berikut latihan membuat halaman login Tampilan dibuat menggunakan CSS Bootstrap, dan JQuery. Tampilan semua halaman harus seragam Buat object model: User, Author, Book, BookStock, Borrower, BorrowData Relasikan object-object yang dibuat. Tugas 3 Buat aplikasi sistem perpustakaan, simpan perubahan project ke Git Server untuk dinilai Spesifikasi aplikasi Sistem Perpustakaan sebagai berikut Spesifikasi seperti tugas 2 User role: User normal dan admin perpustakaan. Menu yang harus dibuat: Halaman Login Halaman Daftar buku dengan status peminjaman.(dapat diakses tanpa login) Halaman Peminjaman buku (hanya dapat diakses oleh admin) Halaman riwayat peminjaman buku Tugas 4 clone project repository artemis ke repository masing-masing. Buat menu perpustakaan di dalam Artemis dengan UI dan standard coding Artemis.","title":"Tugas"},{"location":"developerdoc/tugas/#tugas-latihan","text":"","title":"Tugas Latihan"},{"location":"developerdoc/tugas/#tugas-1","text":"Install software yang dibutuhkan untuk development Laravel di masing-masing PC.","title":"Tugas 1"},{"location":"developerdoc/tugas/#tugas-2","text":"Buat GIT Repository Project Laravel tentang sistem perpustakaan di Git Server artemisdev.polytron.co.id:3000.","title":"Tugas 2"},{"location":"developerdoc/tugas/#spesifikasi-aplikasi-sistem-perpustakaan-sebagai-berikut","text":"latihan membuat halaman login Tampilan dibuat menggunakan CSS Bootstrap, dan JQuery. Tampilan semua halaman harus seragam Buat object model: User, Author, Book, BookStock, Borrower, BorrowData Relasikan object-object yang dibuat.","title":"Spesifikasi aplikasi Sistem Perpustakaan sebagai berikut"},{"location":"developerdoc/tugas/#tugas-3","text":"Buat aplikasi sistem perpustakaan, simpan perubahan project ke Git Server untuk dinilai","title":"Tugas 3"},{"location":"developerdoc/tugas/#spesifikasi-aplikasi-sistem-perpustakaan-sebagai-berikut_1","text":"Spesifikasi seperti tugas 2 User role: User normal dan admin perpustakaan. Menu yang harus dibuat: Halaman Login Halaman Daftar buku dengan status peminjaman.(dapat diakses tanpa login) Halaman Peminjaman buku (hanya dapat diakses oleh admin) Halaman riwayat peminjaman buku","title":"Spesifikasi aplikasi Sistem Perpustakaan sebagai berikut"},{"location":"developerdoc/tugas/#tugas-4","text":"clone project repository artemis ke repository masing-masing. Buat menu perpustakaan di dalam Artemis dengan UI dan standard coding Artemis.","title":"Tugas 4"},{"location":"functionaldoc/","text":"Artemis Documentation for Functionals Dokumen ini berisi tentang panduan dasar Artemis untuk para functional (system analyst). Materi yang akan dipelajari Artemis Introduction Artemis UI Design Standard Artemis Database and Model Objects PhpMyAdmin Gitea Git Server Artemis Documentation Editing","title":"Home"},{"location":"functionaldoc/#artemis-documentation-for-functionals","text":"Dokumen ini berisi tentang panduan dasar Artemis untuk para functional (system analyst).","title":"Artemis Documentation for Functionals"},{"location":"functionaldoc/#materi-yang-akan-dipelajari","text":"Artemis Introduction Artemis UI Design Standard Artemis Database and Model Objects PhpMyAdmin Gitea Git Server Artemis Documentation Editing","title":"Materi yang akan dipelajari"},{"location":"functionaldoc/artemis_db_and_model_objects/","text":"Database dan Object Model Artemis","title":"Artemis Database and Model Objects"},{"location":"functionaldoc/artemis_db_and_model_objects/#database-dan-object-model-artemis","text":"","title":"Database dan Object Model Artemis"},{"location":"functionaldoc/artemis_documentation_editing/","text":"Pembuatan Dokumentasi dalam Artemis","title":"Artemis Documentation Editing"},{"location":"functionaldoc/artemis_documentation_editing/#pembuatan-dokumentasi-dalam-artemis","text":"","title":"Pembuatan Dokumentasi dalam Artemis"},{"location":"functionaldoc/artemis_intro/","text":"Pengenalan Artemis Apa itu Artemis Artemis adalah aplikasi inhouse berbasis web yang dibuat dengan menggunakan PHP framework Laravel . Aplikasi ini berfungsi sebagai aplikasi 3rd party pendukung ke aplikasi utama di PT.HIT yaitu SAP dan Epicor. Berikut ini adalah gambaran awal tentang hubungan antara Artemis dengan aplikasi lain. Feature Artemis antara lain, Sebagai aplikasi 3rd party yang menjembatani SAP, Epicor dan HRIS. Berbasis web , sehingga dapat dijalankan di banyak platform pengguna tanpa instalasi. Dikembangkan secara inhouse PT.HIT, sehingga lebih dapat menyesuaikan kebutuhan. Dikembangkan dengan Laravel PHP Framework . Mendukung web service / API menggunakan Restful. Antar muka pengguna ( User Interface ) responsif menyesuaikan ukuran layar. Keamanan Server berlapis menggunakan protokol koneksi HTTPS dan form POST encryption . Ada notifikasi via email dan UI Notification . Menyediakan tampilan dashboard . Mendukung penggunaan pada mode KIOSK terminal. Mendukung authentikasi pengguna menggunakan active directory . Mendukung interfacing dengan perangkat IOT ( internet of thing ). Apa itu Restful Kalo dalam SAP kita mengenal web service SAP menggunakan protokol SOAP, di dalam Artemis kita menggunakan protokol REST ( REpresentational State Transfer ). Pada dasarnya REST menggunakan protokol komunikasi HTTP ( Hyper Text Transfer Protocol ). Pada REST, REST Server menyediakan resources(sumber daya/data) dan REST client mengakses dan menampilkan resource tersebut untuk penggunaan selanjutnya. Setiap resource diidentifikasi oleh URIs ( Universal Resource Identifiers ) atau global ID . Resource tersebut direpresentasikan dalam bentuk format teks, JSON atau XML. Metode HTTP yang umum digunakan dalam arsitektur berbasis REST, GET, menyediakan hanya akses baca pada resource PUT, digunakan untuk menciptakan resource baru DELETE, digunakan untuk menghapus resource POST, digunakan untuk memperbarui resource yang ada atau membuat resource baru OPTIONS, digunakan untuk mendapatkan operasi yang disupport pada resource Pengenalan Elemen Layar Halaman Sign-in Saat User belum signed-in, secara default akan diarahkan ke halaman Sign-in. Setelah User signed-in, User akan diarahkan ke halaman yang dituju sesuai URL yang dimasukkan sebelumnya. Struktur Halaman Tampilan halaman terdiri dari Left-Side menu Top menu Footer Main content (lihat user documentation untuk informasi selengkapnya) Hak Akses User Artemis untuk masing-masing menu Hak akses dasar menu Artemis dibagi menjadi: no access (tidak mempunyai akses) read only (hanya bisa membaca/report) write only (hanya bisa create/edit/delete) execute only (hanya bisa approve/confirm) read & write (bisa read/create/edit/delete/report) read & execute (bisa read/approve/confirm) full access (dapat melakukan semua hal) Jika seorang user tidak mempunyai hak akses untuk suatu action , maka link atau tombol untuk action tersebut akan disembunyikan (tidak ditampilkan). Otorisasi yang lebih detail misal per bagian atau per model tertentu akan diatur pada otorisasi tambahan per model sesuai kebutuhan. Mode akses masing-masing Group yang dimiliki User dikombinasikan dengan logika OR. Contoh: Group1: Read+Write Group2: Write+Execute Total hak akses Group: Read+Write+Execute Bila hak akses User didefinisikan, maka hak akses group akan diabaikan dan menggunakan hak akses User. Contoh: Total Hak akses group: Read+Write+Execute Hak akses User: Read Total hak akses: Read Navigation (menu) mempunyai mode 0 = disabled navigation -> tidak dapat diakses semua User. 1 = enabled -> akses mengikuti hak akses User dan Group, default akses 0. 2 = public access -> dapat diakses semua orang tanpa signed-in sekalipun, tetap mengikuti hak akses User dan Group, default akses 4. Navigation (menu) mempunyai aturan URL khusus Jika URL dimulai dengan dash (-) maka Navigation tersebut akan membuka window baru saat diklik. Navigation memiliki TCODE agar memudahkan User dalam mencari Navigation tersebut.","title":"Artemis Introduction"},{"location":"functionaldoc/artemis_intro/#pengenalan-artemis","text":"","title":"Pengenalan Artemis"},{"location":"functionaldoc/artemis_intro/#apa-itu-artemis","text":"Artemis adalah aplikasi inhouse berbasis web yang dibuat dengan menggunakan PHP framework Laravel . Aplikasi ini berfungsi sebagai aplikasi 3rd party pendukung ke aplikasi utama di PT.HIT yaitu SAP dan Epicor. Berikut ini adalah gambaran awal tentang hubungan antara Artemis dengan aplikasi lain.","title":"Apa itu Artemis"},{"location":"functionaldoc/artemis_intro/#feature-artemis-antara-lain","text":"Sebagai aplikasi 3rd party yang menjembatani SAP, Epicor dan HRIS. Berbasis web , sehingga dapat dijalankan di banyak platform pengguna tanpa instalasi. Dikembangkan secara inhouse PT.HIT, sehingga lebih dapat menyesuaikan kebutuhan. Dikembangkan dengan Laravel PHP Framework . Mendukung web service / API menggunakan Restful. Antar muka pengguna ( User Interface ) responsif menyesuaikan ukuran layar. Keamanan Server berlapis menggunakan protokol koneksi HTTPS dan form POST encryption . Ada notifikasi via email dan UI Notification . Menyediakan tampilan dashboard . Mendukung penggunaan pada mode KIOSK terminal. Mendukung authentikasi pengguna menggunakan active directory . Mendukung interfacing dengan perangkat IOT ( internet of thing ).","title":"Feature Artemis antara lain,"},{"location":"functionaldoc/artemis_intro/#apa-itu-restful","text":"Kalo dalam SAP kita mengenal web service SAP menggunakan protokol SOAP, di dalam Artemis kita menggunakan protokol REST ( REpresentational State Transfer ). Pada dasarnya REST menggunakan protokol komunikasi HTTP ( Hyper Text Transfer Protocol ). Pada REST, REST Server menyediakan resources(sumber daya/data) dan REST client mengakses dan menampilkan resource tersebut untuk penggunaan selanjutnya. Setiap resource diidentifikasi oleh URIs ( Universal Resource Identifiers ) atau global ID . Resource tersebut direpresentasikan dalam bentuk format teks, JSON atau XML. Metode HTTP yang umum digunakan dalam arsitektur berbasis REST, GET, menyediakan hanya akses baca pada resource PUT, digunakan untuk menciptakan resource baru DELETE, digunakan untuk menghapus resource POST, digunakan untuk memperbarui resource yang ada atau membuat resource baru OPTIONS, digunakan untuk mendapatkan operasi yang disupport pada resource","title":"Apa itu Restful"},{"location":"functionaldoc/artemis_intro/#pengenalan-elemen-layar","text":"","title":"Pengenalan Elemen Layar"},{"location":"functionaldoc/artemis_intro/#halaman-sign-in","text":"Saat User belum signed-in, secara default akan diarahkan ke halaman Sign-in. Setelah User signed-in, User akan diarahkan ke halaman yang dituju sesuai URL yang dimasukkan sebelumnya.","title":"Halaman Sign-in"},{"location":"functionaldoc/artemis_intro/#struktur-halaman","text":"Tampilan halaman terdiri dari Left-Side menu Top menu Footer Main content (lihat user documentation untuk informasi selengkapnya)","title":"Struktur Halaman"},{"location":"functionaldoc/artemis_intro/#hak-akses-user-artemis-untuk-masing-masing-menu","text":"Hak akses dasar menu Artemis dibagi menjadi: no access (tidak mempunyai akses) read only (hanya bisa membaca/report) write only (hanya bisa create/edit/delete) execute only (hanya bisa approve/confirm) read & write (bisa read/create/edit/delete/report) read & execute (bisa read/approve/confirm) full access (dapat melakukan semua hal) Jika seorang user tidak mempunyai hak akses untuk suatu action , maka link atau tombol untuk action tersebut akan disembunyikan (tidak ditampilkan). Otorisasi yang lebih detail misal per bagian atau per model tertentu akan diatur pada otorisasi tambahan per model sesuai kebutuhan. Mode akses masing-masing Group yang dimiliki User dikombinasikan dengan logika OR. Contoh: Group1: Read+Write Group2: Write+Execute Total hak akses Group: Read+Write+Execute Bila hak akses User didefinisikan, maka hak akses group akan diabaikan dan menggunakan hak akses User. Contoh: Total Hak akses group: Read+Write+Execute Hak akses User: Read Total hak akses: Read Navigation (menu) mempunyai mode 0 = disabled navigation -> tidak dapat diakses semua User. 1 = enabled -> akses mengikuti hak akses User dan Group, default akses 0. 2 = public access -> dapat diakses semua orang tanpa signed-in sekalipun, tetap mengikuti hak akses User dan Group, default akses 4.","title":"Hak Akses User Artemis untuk masing-masing menu"},{"location":"functionaldoc/artemis_intro/#navigation-menu-mempunyai-aturan-url-khusus","text":"Jika URL dimulai dengan dash (-) maka Navigation tersebut akan membuka window baru saat diklik. Navigation memiliki TCODE agar memudahkan User dalam mencari Navigation tersebut.","title":"Navigation (menu) mempunyai aturan URL khusus"},{"location":"functionaldoc/artemis_ui_standard/","text":"Artemis User Interface Standard","title":"Artemis UI Design Standard"},{"location":"functionaldoc/artemis_ui_standard/#artemis-user-interface-standard","text":"","title":"Artemis User Interface Standard"},{"location":"functionaldoc/gitea/","text":"Gitea Git Server","title":"Gitea Git Server Usage"},{"location":"functionaldoc/gitea/#gitea-git-server","text":"","title":"Gitea Git Server"},{"location":"functionaldoc/phpmyadmin/","text":"PHPMyAdmin","title":"PhpMyAdmin Usage"},{"location":"functionaldoc/phpmyadmin/#phpmyadmin","text":"","title":"PHPMyAdmin"},{"location":"projects/core/","text":"Artemis Core Module List Projects No. RICEF Description Status System PIC Dev.PIC 1. ART-CORE User Authentication DONE - Rudy G. 2. ART-CORE Group Authentication DONE - Rudy G. 3. ART-CORE Navigation DONE - Rudy G. 4. ART-CORE Notification DONE - Rudy G.","title":"Index"},{"location":"projects/core/#artemis-core-module","text":"","title":"Artemis Core Module"},{"location":"projects/core/#list-projects","text":"No. RICEF Description Status System PIC Dev.PIC 1. ART-CORE User Authentication DONE - Rudy G. 2. ART-CORE Group Authentication DONE - Rudy G. 3. ART-CORE Navigation DONE - Rudy G. 4. ART-CORE Notification DONE - Rudy G.","title":"List Projects"},{"location":"projects/core/user_auth/","text":"User Authentication Technical Specification Database Migrations Models and Relations Routes Class Testing","title":"User Auth"},{"location":"projects/core/user_auth/#user-authentication","text":"","title":"User Authentication"},{"location":"projects/core/user_auth/#technical-specification","text":"","title":"Technical Specification"},{"location":"projects/core/user_auth/#database-migrations","text":"","title":"Database Migrations"},{"location":"projects/core/user_auth/#models-and-relations","text":"","title":"Models and Relations"},{"location":"projects/core/user_auth/#routes","text":"","title":"Routes"},{"location":"projects/core/user_auth/#class-testing","text":"","title":"Class Testing"},{"location":"projects/tms/","text":"TMS (Traffic Management System) List Projects No. RICEF Description Status System PIC Dev.PIC 1.","title":"Index"},{"location":"projects/tms/#tms-traffic-management-system","text":"","title":"TMS (Traffic Management System)"},{"location":"projects/tms/#list-projects","text":"No. RICEF Description Status System PIC Dev.PIC 1.","title":"List Projects"},{"location":"sysadmindoc/","text":"Artemis Documentation for Server System Admin Sorry, not available yet","title":"Home"},{"location":"sysadmindoc/#artemis-documentation-for-server-system-admin","text":"Sorry, not available yet","title":"Artemis Documentation for Server System Admin"}]}