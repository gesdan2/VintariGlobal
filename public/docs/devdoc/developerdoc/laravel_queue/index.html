



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
        <meta name="author" content="ESD-Application">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../img/favicon.ico">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>Laravel Queue - Artemis Development Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.0284f74d.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.01803549.css">
      
      
        
        
        <meta name="theme-color" content="#ef5350">
      
    
    
      <script src="../../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="red" data-md-color-accent="red">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#queue" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="Artemis Development Documentation" class="md-header-nav__button md-logo">
          
            <img src="../../img/favicon.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Artemis Development Documentation
            </span>
            <span class="md-header-nav__topic">
              
                Laravel Queue
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="Artemis Development Documentation" class="md-nav__button md-logo">
      
        <img src="../../img/favicon.png" width="48" height="48">
      
    </a>
    Artemis Development Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      For Developers
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        For Developers
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../installation/" title="Installation" class="md-nav__link">
      Installation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../git/" title="Git" class="md-nav__link">
      Git
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../composer/" title="Composer" class="md-nav__link">
      Composer
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../laravel_basic/" title="Laravel Basic" class="md-nav__link">
      Laravel Basic
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../laravel_db_setting/" title="Laravel Database Setting" class="md-nav__link">
      Laravel Database Setting
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../laravel_routing/" title="Laravel Routing" class="md-nav__link">
      Laravel Routing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../laravel_blade/" title="Laravel Blade Templating" class="md-nav__link">
      Laravel Blade Templating
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../laravel_db_query/" title="Laravel Database Query" class="md-nav__link">
      Laravel Database Query
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../laravel_db_migration/" title="Laravel Database Migration" class="md-nav__link">
      Laravel Database Migration
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../laravel_eloquent/" title="Laravel Eloquent" class="md-nav__link">
      Laravel Eloquent
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Laravel Queue" class="md-nav__link md-nav__link--active">
      Laravel Queue
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../laravel_schedule/" title="Laravel Schedule" class="md-nav__link">
      Laravel Schedule
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../laravel_class_testing/" title="Laravel Class Testing" class="md-nav__link">
      Laravel Class Testing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../artemis_intro/" title="Artemis Introduction" class="md-nav__link">
      Artemis Introduction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../artemis_coding_standard/" title="Artemis Coding Standard" class="md-nav__link">
      Artemis Coding Standard
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../artemis_ui_standard/" title="Artemis UI Design Standard" class="md-nav__link">
      Artemis UI Design Standard
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../artemis_documentation_editing/" title="Artemis Documentation Editing" class="md-nav__link">
      Artemis Documentation Editing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tugas/" title="Tugas" class="md-nav__link">
      Tugas
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      For System Admins
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        For System Admins
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sysadmindoc/" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      For Functionals
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        For Functionals
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../functionaldoc/" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../functionaldoc/artemis_intro/" title="Artemis Introduction" class="md-nav__link">
      Artemis Introduction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../functionaldoc/artemis_ui_standard/" title="Artemis UI Design Standard" class="md-nav__link">
      Artemis UI Design Standard
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../functionaldoc/artemis_db_and_model_objects/" title="Artemis Database and Model Objects" class="md-nav__link">
      Artemis Database and Model Objects
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../functionaldoc/phpmyadmin/" title="PhpMyAdmin Usage" class="md-nav__link">
      PhpMyAdmin Usage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../functionaldoc/gitea/" title="Gitea Git Server Usage" class="md-nav__link">
      Gitea Git Server Usage
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../functionaldoc/artemis_documentation_editing/" title="Artemis Documentation Editing" class="md-nav__link">
      Artemis Documentation Editing
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Artemis Projects
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Artemis Projects
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-1" type="checkbox" id="nav-5-1">
    
    <label class="md-nav__link" for="nav-5-1">
      CORE
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-1">
        CORE
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../projects/core/" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../projects/core/user_auth/" title="User Auth" class="md-nav__link">
      User Auth
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5-2" type="checkbox" id="nav-5-2">
    
    <label class="md-nav__link" for="nav-5-2">
      TMS
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-5-2">
        TMS
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../projects/tms/" title="Index" class="md-nav__link">
      Index
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="queue">Queue</h1>
<p>Introduction
Laravel now offers Horizon, a beautiful dashboard and configuration system for your Redis powered queues. Check out the full Horizon documentation for more information.</p>
<p>Laravel queues provide a unified API across a variety of different queue backends, such as Beanstalk, Amazon SQS, Redis, or even a relational database. Queues allow you to defer the processing of a time consuming task, such as sending an email, until a later time. Deferring these time consuming tasks drastically speeds up web requests to your application.</p>
<p>The queue configuration file is stored in config/queue.php. In this file you will find connection configurations for each of the queue drivers that are included with the framework, which includes a database, Beanstalkd, Amazon SQS, Redis, and a synchronous driver that will execute jobs immediately (for local use). A null queue driver is also included which discards queued jobs.</p>
<p>Connections Vs. Queues
Before getting started with Laravel queues, it is important to understand the distinction between "connections" and "queues". In your config/queue.php configuration file, there is a  connections configuration option. This option defines a particular connection to a backend service such as Amazon SQS, Beanstalk, or Redis. However, any given queue connection may have multiple "queues" which may be thought of as different stacks or piles of queued jobs.</p>
<p>Note that each connection configuration example in the queue configuration file contains a  queue attribute. This is the default queue that jobs will be dispatched to when they are sent to a given connection. In other words, if you dispatch a job without explicitly defining which queue it should be dispatched to, the job will be placed on the queue that is defined in the queue attribute of the connection configuration:</p>
<p>// This job is sent to the default queue...
Job::dispatch();</p>
<p>// This job is sent to the "emails" queue...
Job::dispatch()-&gt;onQueue('emails');
Some applications may not need to ever push jobs onto multiple queues, instead preferring to have one simple queue. However, pushing jobs to multiple queues can be especially useful for applications that wish to prioritize or segment how jobs are processed, since the Laravel queue worker allows you to specify which queues it should process by priority. For example, if you push jobs to a high queue, you may run a worker that gives them higher processing priority:</p>
<p>php artisan queue:work --queue=high,default</p>
<p>Driver Notes &amp; Prerequisites
Database
In order to use the database queue driver, you will need a database table to hold the jobs. To generate a migration that creates this table, run the queue:table Artisan command. Once the migration has been created, you may migrate your database using the migrate command:</p>
<p>php artisan queue:table</p>
<p>php artisan migrate
Redis
In order to use the redis queue driver, you should configure a Redis database connection in your config/database.php configuration file.</p>
<p>Redis Cluster</p>
<p>If your Redis queue connection uses a Redis Cluster, your queue names must contain a key hash tag. This is required in order to ensure all of the Redis keys for a given queue are placed into the same hash slot:</p>
<p>'redis' =&gt; [
    'driver' =&gt; 'redis',
    'connection' =&gt; 'default',
    'queue' =&gt; '{default}',
    'retry_after' =&gt; 90,
],
Blocking</p>
<p>When using the Redis queue, you may use the block_for configuration option to specify how long the driver should wait for a job to become available before iterating through the worker loop and re-polling the Redis database.</p>
<p>Adjusting this value based on your queue load can be more efficient than continually polling the Redis database for new jobs. For instance, you may set the value to 5 to indicate that the driver should block for five seconds while waiting for a job to become available:</p>
<p>'redis' =&gt; [
    'driver' =&gt; 'redis',
    'connection' =&gt; 'default',
    'queue' =&gt; 'default',
    'retry_after' =&gt; 90,
    'block_for' =&gt; 5,
],
Other Driver Prerequisites
The following dependencies are needed for the listed queue drivers:</p>
<p>Amazon SQS: aws/aws-sdk-php ~3.0
Beanstalkd: pda/pheanstalk ~4.0
Redis: predis/predis ~1.0</p>
<p>Creating Jobs</p>
<p>Generating Job Classes
By default, all of the queueable jobs for your application are stored in the app/Jobs directory. If the app/Jobs directory doesn't exist, it will be created when you run the make:job Artisan command. You may generate a new queued job using the Artisan CLI:</p>
<p>php artisan make:job ProcessPodcast
The generated class will implement the Illuminate\Contracts\Queue\ShouldQueue interface, indicating to Laravel that the job should be pushed onto the queue to run asynchronously.</p>
<p>Class Structure
Job classes are very simple, normally containing only a handle method which is called when the job is processed by the queue. To get started, let's take a look at an example job class. In this example, we'll pretend we manage a podcast publishing service and need to process the uploaded podcast files before they are published:</p>
<?php

<p>namespace App\Jobs;</p>
<p>use App\Podcast;
use App\AudioProcessor;
use Illuminate\Bus\Queueable;
use Illuminate\Queue\SerializesModels;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;</p>
<p>class ProcessPodcast implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;</p>
<pre><code>protected $podcast;

/**
 * Create a new job instance.
 *
 * @param  Podcast  $podcast
 * @return void
 */
public function __construct(Podcast $podcast)
{
    $this-&gt;podcast = $podcast;
}

/**
 * Execute the job.
 *
 * @param  AudioProcessor  $processor
 * @return void
 */
public function handle(AudioProcessor $processor)
{
    // Process uploaded podcast...
}
</code></pre>
<p>}
In this example, note that we were able to pass an Eloquent model directly into the queued job's constructor. Because of the SerializesModels trait that the job is using, Eloquent models will be gracefully serialized and unserialized when the job is processing. If your queued job accepts an Eloquent model in its constructor, only the identifier for the model will be serialized onto the queue. When the job is actually handled, the queue system will automatically re-retrieve the full model instance from the database. It's all totally transparent to your application and prevents issues that can arise from serializing full Eloquent model instances.</p>
<p>The handle method is called when the job is processed by the queue. Note that we are able to type-hint dependencies on the handle method of the job. The Laravel service container automatically injects these dependencies.</p>
<p>If you would like to take total control over how the container injects dependencies into the  handle method, you may use the container's bindMethod method. The bindMethod method accepts a callback which receives the job and the container. Within the callback, you are free to invoke the handle method however you wish. Typically, you should call this method from a service provider:</p>
<p>use App\Jobs\ProcessPodcast;</p>
<p>$this-&gt;app-&gt;bindMethod(ProcessPodcast::class.'@handle', function ($job, $app) {
    return $job-&gt;handle($app-&gt;make(AudioProcessor::class));
});
Binary data, such as raw image contents, should be passed through the  base64_encode function before being passed to a queued job. Otherwise, the job may not properly serialize to JSON when being placed on the queue.</p>
<p>Dispatching Jobs
Once you have written your job class, you may dispatch it using the dispatch method on the job itself. The arguments passed to the dispatch method will be given to the job's constructor:</p>
<?php

<p>namespace App\Http\Controllers;</p>
<p>use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;</p>
<p>class PodcastController extends Controller
{
    /*<em>
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     </em>/
    public function store(Request $request)
    {
        // Create podcast...</p>
<pre><code>    ProcessPodcast::dispatch($podcast);
}
</code></pre>
<p>}</p>
<p>Delayed Dispatching
If you would like to delay the execution of a queued job, you may use the delay method when dispatching a job. For example, let's specify that a job should not be available for processing until 10 minutes after it has been dispatched:</p>
<?php

<p>namespace App\Http\Controllers;</p>
<p>use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;</p>
<p>class PodcastController extends Controller
{
    /*<em>
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     </em>/
    public function store(Request $request)
    {
        // Create podcast...</p>
<pre><code>    ProcessPodcast::dispatch($podcast)
            -&gt;delay(now()-&gt;addMinutes(10));
}
</code></pre>
<p>}
The Amazon SQS queue service has a maximum delay time of 15 minutes.</p>
<p>Synchronous Dispatching
If you would like to dispatch a job immediately (synchronously), you may use the dispatchNow method. When using this method, the job will not be queued and will be run immediately within the current process:</p>
<?php

<p>namespace App\Http\Controllers;</p>
<p>use Illuminate\Http\Request;
use App\Jobs\ProcessPodcast;
use App\Http\Controllers\Controller;</p>
<p>class PodcastController extends Controller
{
    /*<em>
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     </em>/
    public function store(Request $request)
    {
        // Create podcast...</p>
<pre><code>    ProcessPodcast::dispatchNow($podcast);
}
</code></pre>
<p>}</p>
<p>Job Chaining
Job chaining allows you to specify a list of queued jobs that should be run in sequence. If one job in the sequence fails, the rest of the jobs will not be run. To execute a queued job chain, you may use the withChain method on any of your dispatchable jobs:</p>
<p>ProcessPodcast::withChain([
    new OptimizePodcast,
    new ReleasePodcast
])-&gt;dispatch();
Deleting jobs using the $this-&gt;delete() method will not prevent chained jobs from being processed. The chain will only stop executing if a job in the chain fails.</p>
<p>Chain Connection &amp; Queue
If you would like to specify the default connection and queue that should be used for the chained jobs, you may use the allOnConnection and allOnQueue methods. These methods specify the queue connection and queue name that should be used unless the queued job is explicitly assigned a different connection / queue:</p>
<p>ProcessPodcast::withChain([
    new OptimizePodcast,
    new ReleasePodcast
])-&gt;dispatch()-&gt;allOnConnection('redis')-&gt;allOnQueue('podcasts');</p>
<p>Customizing The Queue &amp; Connection
Dispatching To A Particular Queue
By pushing jobs to different queues, you may "categorize" your queued jobs and even prioritize how many workers you assign to various queues. Keep in mind, this does not push jobs to different queue "connections" as defined by your queue configuration file, but only to specific queues within a single connection. To specify the queue, use the onQueue method when dispatching the job:</p>
<?php

<p>namespace App\Http\Controllers;</p>
<p>use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;</p>
<p>class PodcastController extends Controller
{
    /*<em>
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     </em>/
    public function store(Request $request)
    {
        // Create podcast...</p>
<pre><code>    ProcessPodcast::dispatch($podcast)-&gt;onQueue('processing');
}
</code></pre>
<p>}
Dispatching To A Particular Connection
If you are working with multiple queue connections, you may specify which connection to push a job to. To specify the connection, use the onConnection method when dispatching the job:</p>
<?php

<p>namespace App\Http\Controllers;</p>
<p>use App\Jobs\ProcessPodcast;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;</p>
<p>class PodcastController extends Controller
{
    /*<em>
     * Store a new podcast.
     *
     * @param  Request  $request
     * @return Response
     </em>/
    public function store(Request $request)
    {
        // Create podcast...</p>
<pre><code>    ProcessPodcast::dispatch($podcast)-&gt;onConnection('sqs');
}
</code></pre>
<p>}
You may chain the onConnection and onQueue methods to specify the connection and the queue for a job:</p>
<p>ProcessPodcast::dispatch($podcast)
              -&gt;onConnection('sqs')
              -&gt;onQueue('processing');
Alternatively, you may specify the connection as a property on the job class:</p>
<?php

<p>namespace App\Jobs;</p>
<p>class ProcessPodcast implements ShouldQueue
{
    /*<em>
     * The queue connection that should handle the job.
     *
     * @var string
     </em>/
    public $connection = 'sqs';
}</p>
<p>Specifying Max Job Attempts / Timeout Values
Max Attempts
One approach to specifying the maximum number of times a job may be attempted is via the  --tries switch on the Artisan command line:</p>
<p>php artisan queue:work --tries=3
However, you may take a more granular approach by defining the maximum number of attempts on the job class itself. If the maximum number of attempts is specified on the job, it will take precedence over the value provided on the command line:</p>
<?php

<p>namespace App\Jobs;</p>
<p>class ProcessPodcast implements ShouldQueue
{
    /*<em>
     * The number of times the job may be attempted.
     *
     * @var int
     </em>/
    public $tries = 5;
}</p>
<p>Time Based Attempts
As an alternative to defining how many times a job may be attempted before it fails, you may define a time at which the job should timeout. This allows a job to be attempted any number of times within a given time frame. To define the time at which a job should timeout, add a  retryUntil method to your job class:</p>
<p>/*<em>
 * Determine the time at which the job should timeout.
 *
 * @return \DateTime
 </em>/
public function retryUntil()
{
    return now()-&gt;addSeconds(5);
}
You may also define a retryUntil method on your queued event listeners.</p>
<p>Timeout
The timeout feature is optimized for PHP 7.1+ and the pcntl PHP extension.</p>
<p>Likewise, the maximum number of seconds that jobs can run may be specified using the  --timeout switch on the Artisan command line:</p>
<p>php artisan queue:work --timeout=30
However, you may also define the maximum number of seconds a job should be allowed to run on the job class itself. If the timeout is specified on the job, it will take precedence over any timeout specified on the command line:</p>
<?php

<p>namespace App\Jobs;</p>
<p>class ProcessPodcast implements ShouldQueue
{
    /*<em>
     * The number of seconds the job can run before timing out.
     *
     * @var int
     </em>/
    public $timeout = 120;
}</p>
<p>Rate Limiting
This feature requires that your application can interact with a Redis server.</p>
<p>If your application interacts with Redis, you may throttle your queued jobs by time or concurrency. This feature can be of assistance when your queued jobs are interacting with APIs that are also rate limited.</p>
<p>For example, using the throttle method, you may throttle a given type of job to only run 10 times every 60 seconds. If a lock can not be obtained, you should typically release the job back onto the queue so it can be retried later:</p>
<p>Redis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () {
    // Job logic...
}, function () {
    // Could not obtain lock...</p>
<pre><code>return $this-&gt;release(10);
</code></pre>
<p>});
In the example above, the key may be any string that uniquely identifies the type of job you would like to rate limit. For example, you may wish to construct the key based on the class name of the job and the IDs of the Eloquent models it operates on.</p>
<p>Releasing a throttled job back onto the queue will still increment the job's total number of attempts.</p>
<p>Alternatively, you may specify the maximum number of workers that may simultaneously process a given job. This can be helpful when a queued job is modifying a resource that should only be modified by one job at a time. For example, using the funnel method, you may limit jobs of a given type to only be processed by one worker at a time:</p>
<p>Redis::funnel('key')-&gt;limit(1)-&gt;then(function () {
    // Job logic...
}, function () {
    // Could not obtain lock...</p>
<pre><code>return $this-&gt;release(10);
</code></pre>
<p>});
When using rate limiting, the number of attempts your job will need to run successfully can be hard to determine. Therefore, it is useful to combine rate limiting with time based attempts.</p>
<p>Error Handling
If an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it may be attempted again. The job will continue to be released until it has been attempted the maximum number of times allowed by your application. The maximum number of attempts is defined by the --tries switch used on the queue:work Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself. More information on running the queue worker can be found below.</p>
<p>Queueing Closures
Instead of dispatching a job class to the queue, you may also dispatch a Closure. This is great for quick, simple tasks that need to be executed outside of the current request cycle:</p>
<p>$podcast = App\Podcast::find(1);</p>
<p>dispatch(function () use ($podcast) {
    $podcast-&gt;publish();
});
When dispatching Closures to the queue, the Closure's code contents is cryptographically signed so it can not be modified in transit.</p>
<p>Running The Queue Worker
Laravel includes a queue worker that will process new jobs as they are pushed onto the queue. You may run the worker using the queue:work Artisan command. Note that once the  queue:work command has started, it will continue to run until it is manually stopped or you close your terminal:</p>
<p>php artisan queue:work
To keep the queue:work process running permanently in the background, you should use a process monitor such as Supervisor to ensure that the queue worker does not stop running.</p>
<p>Remember, queue workers are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to restart your queue workers.</p>
<p>Alternatively, you may run the queue:listen command. When using the queue:listen command, you don't have to manually restart the worker after your code is changed; however, this command is not as efficient as queue:work:</p>
<p>php artisan queue:listen
Specifying The Connection &amp; Queue
You may also specify which queue connection the worker should utilize. The connection name passed to the work command should correspond to one of the connections defined in your  config/queue.php configuration file:</p>
<p>php artisan queue:work redis
You may customize your queue worker even further by only processing particular queues for a given connection. For example, if all of your emails are processed in an emails queue on your  redis queue connection, you may issue the following command to start a worker that only processes only that queue:</p>
<p>php artisan queue:work redis --queue=emails
Processing A Single Job
The --once option may be used to instruct the worker to only process a single job from the queue:</p>
<p>php artisan queue:work --once
Processing All Queued Jobs &amp; Then Exiting
The --stop-when-empty option may be used to instruct the worker to process all jobs and then exit gracefully. This option can be useful when working Laravel queues within a Docker container if you wish to shutdown the container after the queue is empty:</p>
<p>php artisan queue:work --stop-when-empty
Resource Considerations
Daemon queue workers do not "reboot" the framework before processing each job. Therefore, you should free any heavy resources after each job completes. For example, if you are doing image manipulation with the GD library, you should free the memory with imagedestroy when you are done.</p>
<p>Queue Priorities
Sometimes you may wish to prioritize how your queues are processed. For example, in your  config/queue.php you may set the default queue for your redis connection to low. However, occasionally you may wish to push a job to a high priority queue like so:</p>
<p>dispatch((new Job)-&gt;onQueue('high'));
To start a worker that verifies that all of the high queue jobs are processed before continuing to any jobs on the low queue, pass a comma-delimited list of queue names to the work command:</p>
<p>php artisan queue:work --queue=high,low</p>
<p>Queue Workers &amp; Deployment
Since queue workers are long-lived processes, they will not pick up changes to your code without being restarted. So, the simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You may gracefully restart all of the workers by issuing the queue:restart command:</p>
<p>php artisan queue:restart
This command will instruct all queue workers to gracefully "die" after they finish processing their current job so that no existing jobs are lost. Since the queue workers will die when the  queue:restart command is executed, you should be running a process manager such as Supervisor to automatically restart the queue workers.</p>
<p>The queue uses the cache to store restart signals, so you should verify a cache driver is properly configured for your application before using this feature.</p>
<p>Job Expirations &amp; Timeouts
Job Expiration
In your config/queue.php configuration file, each queue connection defines a retry_after option. This option specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example, if the value of retry_after is set to 90, the job will be released back onto the queue if it has been processing for 90 seconds without being deleted. Typically, you should set the retry_after value to the maximum number of seconds your jobs should reasonably take to complete processing.</p>
<p>The only queue connection which does not contain a retry_after value is Amazon SQS. SQS will retry the job based on the Default Visibility Timeout which is managed within the AWS console.</p>
<p>Worker Timeouts
The queue:work Artisan command exposes a --timeout option. The --timeout option specifies how long the Laravel queue master process will wait before killing off a child queue worker that is processing a job. Sometimes a child queue process can become "frozen" for various reasons, such as an external HTTP call that is not responding. The --timeout option removes frozen processes that have exceeded that specified time limit:</p>
<p>php artisan queue:work --timeout=60
The retry_after configuration option and the --timeout CLI option are different, but work together to ensure that jobs are not lost and that jobs are only successfully processed once.</p>
<p>The --timeout value should always be at least several seconds shorter than your  retry_after configuration value. This will ensure that a worker processing a given job is always killed before the job is retried. If your --timeout option is longer than your retry_after configuration value, your jobs may be processed twice.</p>
<p>Worker Sleep Duration
When jobs are available on the queue, the worker will keep processing jobs with no delay in between them. However, the sleep option determines how long (in seconds) the worker will "sleep" if there are no new jobs available. While sleeping, the worker will not process any new jobs - the jobs will be processed after the worker wakes up again.</p>
<p>php artisan queue:work --sleep=3</p>
<p>Supervisor Configuration
Installing Supervisor
Supervisor is a process monitor for the Linux operating system, and will automatically restart your queue:work process if it fails. To install Supervisor on Ubuntu, you may use the following command:</p>
<p>sudo apt-get install supervisor
If configuring Supervisor yourself sounds overwhelming, consider using Laravel Forge, which will automatically install and configure Supervisor for your Laravel projects.</p>
<p>Configuring Supervisor
Supervisor configuration files are typically stored in the /etc/supervisor/conf.d directory. Within this directory, you may create any number of configuration files that instruct supervisor how your processes should be monitored. For example, let's create a laravel-worker.conf file that starts and monitors a queue:work process:</p>
<p>[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3
autostart=true
autorestart=true
user=forge
numprocs=8
redirect_stderr=true
stdout_logfile=/home/forge/app.com/worker.log
In this example, the numprocs directive will instruct Supervisor to run 8 queue:work processes and monitor all of them, automatically restarting them if they fail. You should change the  queue:work sqs portion of the command directive to reflect your desired queue connection.</p>
<p>Starting Supervisor
Once the configuration file has been created, you may update the Supervisor configuration and start the processes using the following commands:</p>
<p>sudo supervisorctl reread</p>
<p>sudo supervisorctl update</p>
<p>sudo supervisorctl start laravel-worker:*
For more information on Supervisor, consult the Supervisor documentation.</p>
<p>Dealing With Failed Jobs
Sometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to specify the maximum number of times a job should be attempted. After a job has exceeded this amount of attempts, it will be inserted into the failed_jobs database table. To create a migration for the failed_jobs table, you may use the  queue:failed-table command:</p>
<p>php artisan queue:failed-table</p>
<p>php artisan migrate
Then, when running your queue worker, you should specify the maximum number of times a job should be attempted using the --tries switch on the queue:work command. If you do not specify a value for the --tries option, jobs will be attempted indefinitely:</p>
<p>php artisan queue:work redis --tries=3
In addition, you may specify how many seconds Laravel should wait before retrying a job that has failed using the --delay option. By default, a job is retried immediately:</p>
<p>php artisan queue:work redis --tries=3 --delay=3
If you would like to configure the failed job retry delay on a per-job basis, you may do so by defining a retryAfter property on your queued job class:</p>
<p>/*<em>
 * The number of seconds to wait before retrying the job.
 *
 * @var int
 </em>/
public $retryAfter = 3;</p>
<p>Cleaning Up After Failed Jobs
You may define a failed method directly on your job class, allowing you to perform job specific clean-up when a failure occurs. This is the perfect location to send an alert to your users or revert any actions performed by the job. The Exception that caused the job to fail will be passed to the failed method:</p>
<?php

<p>namespace App\Jobs;</p>
<p>use Exception;
use App\Podcast;
use App\AudioProcessor;
use Illuminate\Bus\Queueable;
use Illuminate\Queue\SerializesModels;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;</p>
<p>class ProcessPodcast implements ShouldQueue
{
    use InteractsWithQueue, Queueable, SerializesModels;</p>
<pre><code>protected $podcast;

/**
 * Create a new job instance.
 *
 * @param  Podcast  $podcast
 * @return void
 */
public function __construct(Podcast $podcast)
{
    $this-&gt;podcast = $podcast;
}

/**
 * Execute the job.
 *
 * @param  AudioProcessor  $processor
 * @return void
 */
public function handle(AudioProcessor $processor)
{
    // Process uploaded podcast...
}

/**
 * The job failed to process.
 *
 * @param  Exception  $exception
 * @return void
 */
public function failed(Exception $exception)
{
    // Send user notification of failure, etc...
}
</code></pre>
<p>}</p>
<p>Failed Job Events
If you would like to register an event that will be called when a job fails, you may use the  Queue::failing method. This event is a great opportunity to notify your team via email or Slack. For example, we may attach a callback to this event from the AppServiceProvider that is included with Laravel:</p>
<?php

<p>namespace App\Providers;</p>
<p>use Illuminate\Support\Facades\Queue;
use Illuminate\Queue\Events\JobFailed;
use Illuminate\Support\ServiceProvider;</p>
<p>class AppServiceProvider extends ServiceProvider
{
    /*<em>
     * Register any application services.
     *
     * @return void
     </em>/
    public function register()
    {
        //
    }</p>
<pre><code>/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    Queue::failing(function (JobFailed $event) {
        // $event-&gt;connectionName
        // $event-&gt;job
        // $event-&gt;exception
    });
}
</code></pre>
<p>}</p>
<p>Retrying Failed Jobs
To view all of your failed jobs that have been inserted into your failed_jobs database table, you may use the queue:failed Artisan command:</p>
<p>php artisan queue:failed
The queue:failed command will list the job ID, connection, queue, and failure time. The job ID may be used to retry the failed job. For instance, to retry a failed job that has an ID of 5, issue the following command:</p>
<p>php artisan queue:retry 5
To retry all of your failed jobs, execute the queue:retry command and pass all as the ID:</p>
<p>php artisan queue:retry all
If you would like to delete a failed job, you may use the queue:forget command:</p>
<p>php artisan queue:forget 5
To delete all of your failed jobs, you may use the queue:flush command:</p>
<p>php artisan queue:flush</p>
<p>Ignoring Missing Models
When injecting an Eloquent model into a job, it is automatically serialized before being placed on the queue and restored when the job is processed. However, if the model has been deleted while the job was waiting to be processed by a worker, your job may fail with a  ModelNotFoundException.</p>
<p>For convenience, you may choose to automatically delete jobs with missing models by setting your job's deleteWhenMissingModels property to true:</p>
<p>/*<em>
 * Delete the job if its models no longer exist.
 *
 * @var bool
 </em>/
public $deleteWhenMissingModels = true;</p>
<p>Job Events
Using the before and after methods on the Queue facade, you may specify callbacks to be executed before or after a queued job is processed. These callbacks are a great opportunity to perform additional logging or increment statistics for a dashboard. Typically, you should call these methods from a service provider. For example, we may use the AppServiceProvider that is included with Laravel:</p>
<?php

<p>namespace App\Providers;</p>
<p>use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobProcessed;
use Illuminate\Queue\Events\JobProcessing;</p>
<p>class AppServiceProvider extends ServiceProvider
{
    /*<em>
     * Register any application services.
     *
     * @return void
     </em>/
    public function register()
    {
        //
    }</p>
<pre><code>/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    Queue::before(function (JobProcessing $event) {
        // $event-&gt;connectionName
        // $event-&gt;job
        // $event-&gt;job-&gt;payload()
    });

    Queue::after(function (JobProcessed $event) {
        // $event-&gt;connectionName
        // $event-&gt;job
        // $event-&gt;job-&gt;payload()
    });
}
</code></pre>
<p>}
Using the looping method on the Queue facade, you may specify callbacks that execute before the worker attempts to fetch a job from a queue. For example, you might register a Closure to rollback any transactions that were left open by a previously failed job:</p>
<p>Queue::looping(function () {
    while (DB::transactionLevel() &gt; 0) {
        DB::rollBack();
    }
});</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../laravel_eloquent/" title="Laravel Eloquent" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Laravel Eloquent
              </span>
            </div>
          </a>
        
        
          <a href="../laravel_schedule/" title="Laravel Schedule" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Laravel Schedule
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy;2019 ESD-Application
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>